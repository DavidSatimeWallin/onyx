package http

HTTP_Header :: enum {
    Content_Length;
    Content_Type;
    Expect;
    TransferEncoding;
    Server;
    Accept;
    AcceptEncoding;
    Location;
}

header_from_str :: (s: str) -> (HTTP_Header, success: bool) {
    switch s |> string.strip_whitespace() |> string.to_lowercase() {
        case "content-length"       do return .Content_Length, true;
        case "content-type"         do return .Content_Type, true;
        case "expect"               do return .Expect, true;
        case "transfer-encoding"    do return .TransferEncoding, true;
        case "accept"               do return .Accept, true;
        case "accept-encoding"      do return .AcceptEncoding, true;
        case "location"             do return .Location, true;
        case #default do return ~~ -1, false;
    }
}

#match string.as_str (v: HTTP_Header) -> str {
    switch v {
        case .Content_Length   do return "Content-Length";
        case .Content_Type     do return "Content-Type";
        case .Expect           do return "Expect";
        case .TransferEncoding do return "Transfer-Encoding";
        case .Server           do return "Server";
        case .Accept           do return "Accept";
        case .AcceptEncoding   do return "Accept-Encoding";
        case .Location         do return "Location";
        case #default          do return "";
    }
}

MediaType :: enum {
    PlainText;

    ApplicationJson;

    Png;
    Bmp;
    Gif;
    Jpeg;
}

media_type_from_str :: (s: str) -> (MediaType, success: bool) {
    switch s |> string.strip_whitespace() |> string.to_lowercase() {
        case "text/plain"       do return .PlainText, true;
        case "application/json" do return .ApplicationJson, true;
        case "image/png"        do return .Png, true;
        case "image/bmp"        do return .Bmp, true;
        case "image/gif"        do return .Gif, true;
        case "image/jpeg"       do return .Jpeg, true;
        case #default do return ~~ -1, false;
    }
}

#match string.as_str (v: MediaType) -> str {
    switch v {
        case .PlainText do return "text/plain";
        case .ApplicationJson do return "application/json";
        case .Png do return "image/png";
        case .Bmp do return "image/bmp";
        case .Gif do return "image/gif";
        case .Jpeg do return "image/jpeg";
        case #default do return "";
    }
}


HTTP_Headers :: struct {
    content_length: u32;
    content_type: MediaType;
    expect: bool;
    chunked: bool;
    accept: MediaType;
    location: str;
    custom_entries: Map(str, str);

    parse_header_line :: (use this: ^HTTP_Headers, line_: [] u8) -> bool {
        line := line_;
        header, content := do {
            header := string.read_until(^line, #char ":");
            string.advance(^line, 1);
            string.strip_leading_whitespace(^line);
            return header, line;
        };

        header_type: HTTP_Header;
        if header_type', success := header_from_str(header); !success {
            custom_entries[header] = string.strip_whitespace(content);
            return false;
        }

        switch header_type {
            case .Content_Length {
                content_length = ~~ conv.str_to_i64(content);
                return true;
            }

            case .Content_Type {
                content_type', success := media_type_from_str(content);
                return success;
            }

            case .Accept {
                accept', worked := media_type_from_str(content);
                return worked;
            }

            case .TransferEncoding {
                switch string.strip_whitespace(content) {
                    case "chunked" do chunked = true;
                    case "identity" ---
                    case #default do return false;
                }

                return true;
            }

            case .Expect {
                switch string.strip_whitespace(content) {
                    case "100-continue" {
                        expect = true;
                        return true;
                    }
                }

                return false;
            }

            case .AcceptEncoding {
                @TODO // This needs to be limited.
                return true;
            }

            case .Location {
                location = content |> string.strip_whitespace();
                return true;
            }

            case .Server {
                return true;
            }
        }

        return false;
    }
}
