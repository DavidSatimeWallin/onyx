package ui

use package core

@Temporary
DEFAULT_TEXT_SIZE :: 1.0f


UI_Id :: #type u32

#private hot_item    : UI_Id = 0
#private active_item : UI_Id = 0
#private hot_item_was_set := false

#private current_font : ^Font;

init_ui :: () {
    map.init(^font_registry, hash_count=4);

    map.init(^animation_states, default=.{}, hash_count=4);
    map.init(^workspace_states, default=.{}, hash_count=4);
    map.init(^scrollable_region_states, default=.{}, hash_count=4);

    // Register a default font so things don't break everywhere
    builtin_font := create_font(#file_contents "./fonts/builtin.fnt", #file_contents "./fonts/builtin.data");
    register_font(-1, builtin_font);
    use_font(-1);
}

// This function should be called at the end of drawing a frame, after all of the UI elements
// had a chance to interact with the hardware events.

end_frame :: () {
    mouse_state.left_button_just_up    = false;
    mouse_state.left_button_just_down  = false;
    mouse_state.right_button_just_up   = false;
    mouse_state.right_button_just_down = false;

    mouse_state.dwheel = 0;
    mouse_state.dx_ = 0;
    mouse_state.dy_ = 0;

    // I don't think these need to be cleared every frame, so long as you don't try
    // to use them without checking keys_down_this_frame first.
    // for ^key: keyboard_state.keycodes_down_this_frame do *key = .{};
    // for ^key: keyboard_state.keycodes_up_this_frame do *key = .{};

    keyboard_state.keys_down_this_frame = 0;
    keyboard_state.keys_up_this_frame = 0;

    hot_item_depth_needed = hot_item_depth;
    if !hot_item_was_set do set_hot_item(0);
    hot_item_depth = 0;
    hot_item_was_set = false;

    for ^s: keyboard_state.state {
        if *s == .Just_Down do *s = .Down;
        if *s == .Just_Up   do *s = .Up;
    }
}

set_active_item :: (id: UI_Id) -> bool {
    active_item = id;
    return true;
}

#private_file hot_item_depth := 0;
#private_file hot_item_depth_needed := 0;

set_hot_item :: (id: UI_Id, force := false) -> bool {
    if active_item != 0 do return false;

    if force {
        hot_item_was_set = true;
        hot_item = id;
        return true;
    }

    hot_item_depth += 1;
    if hot_item_depth >= hot_item_depth_needed {
        hot_item_was_set = true;
        hot_item = id;
        return true;
    } else {
        return false;
    }
}

is_active_item :: (id: UI_Id) -> bool {
    return active_item == id;
}

is_hot_item :: (id: UI_Id) -> bool {
    return hot_item == id;
}

@FontSizing // In the new font system, size is in ems, which can be set per font.
draw_text_raw :: (text: str, x: f32, y: f32, font: i32 = -1, size := DEFAULT_TEXT_SIZE, color := gfx.Color4.{1,1,1}) {
    use_font(font);
    if current_font == null do use_font(-1);
    current_font->render(text, x, y, size, color);
}

draw_rect :: #match {
    (use r: Rectangle, color := gfx.Color4.{1,1,1}) {
        gfx.set_texture();

        width, height := Rectangle.dimensions(r);
        gfx.rect(.{ x0, y0 }, .{ width, height }, color);
    },

    (x: f32, y: f32, w: f32, h: f32, color := gfx.Color4.{1,1,1}) {
        gfx.set_texture();
        gfx.rect(.{ x, y }, .{ w, h }, color);
    }
}

draw_text :: (use r: Rectangle, text: str, theme := ^default_text_theme, site := #callsite) {
    draw_text_raw(text, x0, y0 + current_font->get_baseline(theme.font_size), theme.font, theme.font_size, theme.text_color);
}

Rectangle :: struct {
    //
    // x0,y0 ------------+
    //   |               |
    //   |               |
    //   +------------ x1,y1
    //

    x0: f32 = 0;
    y0: f32 = 0;
    x1: f32 = 0;
    y1: f32 = 0;

    width  :: (use r: Rectangle) -> f32 do return math.abs(x1 - x0);
    height :: (use r: Rectangle) -> f32 do return math.abs(y1 - y0);

    dimensions :: (use r: Rectangle) -> (width: f32, height: f32) {
        return width(r), height(r);
    }

    top_left     :: (use r: Rectangle) -> (x: f32, y: f32) do return math.min(x0, x1), math.min(y0, y1);
    top_right    :: (use r: Rectangle) -> (x: f32, y: f32) do return math.max(x0, x1), math.min(y0, y1);
    bottom_left  :: (use r: Rectangle) -> (x: f32, y: f32) do return math.min(x0, x1), math.max(y0, y1);
    bottom_right :: (use r: Rectangle) -> (x: f32, y: f32) do return math.max(x0, x1), math.max(y0, y1);

    contains :: (use r: Rectangle, x: f32, y: f32) -> bool {
        return math.min(x0, x1) <= x && x <= math.max(x0, x1) &&
               math.min(y0, y1) <= y && y <= math.max(y0, y1);
    }

    intersects :: (use r: Rectangle, o: Rectangle) -> bool {
        return x1 >= o.x0 && x0 <= o.x1 && y1 >= o.y0 && y0 <= o.y1;
    }
}




@Relocate
Text_Theme :: struct {
    text_color := gfx.Color4.{ 1, 1, 1 };

    font       := 0; // Default to font index 0 
    font_size  := 1.0f;
}

default_text_theme := Text_Theme.{};


Animation_Theme :: struct {
    hover_speed       := 0.1f;
    click_decay_speed := 0.08f;
}



// Animation states are stored globally as there is not much to the state of a button.
// Forcing the end user to store a structure for each button that is just the animation
// state of the component feels very wrong.
#private animation_states : Map(UI_Id, Animation_State);

Animation_State :: struct {
    hover_time := 0.0f;
    click_time := 0.0f;
}

has_active_animation :: () -> bool {
    for ^anim: animation_states.entries {
        if anim.value.hover_time != 0.0f || anim.value.hover_time != 1.0f do return true;
        if anim.value.click_time != 0.0f || anim.value.click_time != 1.0f do return true;
    }

    return false;
}


// Utilities
get_site_hash :: macro (site: CallSite, increment := 0) -> UI_Id {
    hash :: package core.hash

    file_hash   := hash.to_u32(site.file);
    line_hash   := hash.to_u32(site.line);
    column_hash := hash.to_u32(site.column);

    return file_hash * 0x472839 + line_hash * 0x6849210 + column_hash * 0x1248382 + increment;
}

get_text_width :: (text: str, size := DEFAULT_TEXT_SIZE) -> f32 {
    return current_font->get_width(text, size);
}

get_text_height  :: (text: str, size := DEFAULT_TEXT_SIZE) -> f32 {
    return current_font->get_height(text, size);
}

@Relocate
move_towards :: macro (value: ^$T, target: T, step: T) {
    if *value < target do *value += step;
    if *value > target do *value -= step;
    if *value > target - step && *value < target + step do *value = target;
}

#private color_lerp :: macro (t: f32, c1: gfx.Color4, c2: gfx.Color4) -> gfx.Color4 {
    return .{
        r = c1.r * (1 - t) + c2.r * t,
        g = c1.g * (1 - t) + c2.g * t,
        b = c1.b * (1 - t) + c2.b * t,
        a = c1.a * (1 - t) + c2.a * t,   @Cleanup // should this be interpolating alphas?
    };
}
