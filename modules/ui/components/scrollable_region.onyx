package ui

use package core

Scrollable_Region_State :: struct {
    transform: gfx.Transform = .{
        translation = .{ 0, 0 },
        scale       = .{ 1, 1 },
    };
}

#private
scrollable_region_states : map.Map(UI_Id, Scrollable_Region_State);

scrollable_region_start :: (use r: Rectangle, minimum_y := 0.0f, maximum_y := 10000.0f, site := #callsite, state: ^Scrollable_Region_State = null) {
    hash := get_site_hash(site, 0);
    x, y := Rectangle.top_left(r);
    width, height := Rectangle.dimensions(r);

    if state == null {
        state = map.get_ptr(^scrollable_region_states, hash);

        if state == null {
            map.put(^scrollable_region_states, hash, .{});
            state = map.get_ptr(^scrollable_region_states, hash);
        }
    }

    mx, my := get_mouse_position();
    if Rectangle.contains(r, mx, my) {
        set_hot_item(hash);
    }

    if is_hot_item(hash) {
        speed :: 30.0f; @ThemeConfiguration

        if is_key_down(38)  do state.transform.translation.y += speed;
        if is_key_down(40)  do state.transform.translation.y -= speed;

        if mouse_state.dwheel > 0 do state.transform.translation.y += speed;
        if mouse_state.dwheel < 0 do state.transform.translation.y -= speed;

        state.transform.translation.y = math.clamp(state.transform.translation.y, -maximum_y, minimum_y);
    }

    gfx.push_scissor(x, y, width, height);
    gfx.push_matrix();
    gfx.apply_transform(state.transform);
}

scrollable_region_stop :: () {
    gfx.pop_scissor();
    gfx.pop_matrix();
}