package json
use package core

null_value : Value

Value :: struct {
    Type :: enum {
        Null :: 0x00;
        Bool;
        Integer;
        Float;
        String;
        Array;
        Object;
    }

    type : Type;
    allocator : Allocator;
    use value : struct #union {
        bool_   : bool;
        int_    : i64;
        float_  : f64;
        str_    : str;   // This is allocated out of the allocator above.

        @CompilerBug @Cleanup // I don't want these to be pointers in the long run. In theory, they should be
        // able to be normal values, but there is a compiler bug that prevents the size and alignment of Value
        // being known.
        //
        // Thinking about it a little more, I think having these be pointers will be better from a performance
        // point of view, because the overhead of copying the return/parameter values would be significant.
        array_  : [..] ^Value;
        object_ : [..] struct {
            key : str;        // This is allocated out of the allocator on the Value.
            value : ^Value;
        };
    };
}

is_null :: (v: ^Value) -> bool {
    if v == null do return true;
    return v == ^null_value || v.type == .Null;
}

to_str :: (v: ^Value) -> str do return null_str;

get :: (v: ^Value, key: str) -> ^Value {
    if v.type != .Object do return ^null_value;

    for ^entry: v.object_ {
        if entry.key == key do return entry.value;
    }
    return ^null_value;
}

free :: (v: ^Value) do switch v.type {
    case .String {
        raw_free(v.allocator, v.str_.data);
    }

    case .Array {
        for elem: v.array_ {
            free(elem);
        }
        array.free(^v.array_);
    }

    case .Object {
        for ^entry: v.object_ {
            raw_free(v.allocator, entry.key.data);
            free(entry.value);
        }
        array.free(^v.object_);
    }
}
