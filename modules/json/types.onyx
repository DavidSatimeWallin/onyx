package json
use package core

null_value := Value.{}

Json :: struct {
    // This is the allocator for all of the values in the JSON tree.
    // It is not the allocator the arrays and objects however. Those
    // have their own allocator, which I'm assuming will always be
    // the general purpose heap allocator.
    allocator: Allocator;

    root: ^Value;
}

Value :: struct {
    Type :: enum {
        Null :: 0x00;
        Bool;
        Integer;
        Float;
        String;
        Array;
        Object;
    }

    type := Type.Null;
}

Value_Bool :: struct {
    use base := Value.{ type = .Bool };
    bool_: bool;
}

Value_Integer :: struct {
    use base := Value.{ type = .Integer };
    int_: i64;
}

Value_Float :: struct {
    use base := Value.{ type = .Float };
    float_: f64;
}

Value_String :: struct {
    use base := Value.{ type = .String };
    str_: str;
}

Value_Array :: struct {
    use base := Value.{ type = .Array };
    array_: [..] ^Value;
}

Value_Object :: struct {
    use base := Value.{ type = .Object };
    object_: [..] struct {
        key   : str;
        value : ^Value;
    };
}

is_null :: (v: ^Value) -> bool {
    if v == null do return true;
    return v == ^null_value || v.type == .Null;
}

to_str :: (v: ^Value) -> str {
    if v == null do return null_str;

    switch v.type {
        case .String do return (cast(^Value_String) v).str_;
        case #default do return "";
    }
}

#operator [] get
get :: (v: ^Value, key: str) -> ^Value {
    if v.type != .Object do return ^null_value;

    v_obj := cast(^Value_Object) v;

    for ^entry: v_obj.object_ {
        if entry.key == key do return entry.value;
    }
    return ^null_value;
}

free :: proc {
    (v: ^Value, allocator: Allocator) do switch v.type {
        case .String {
            v_str := cast(^Value_String) v;
            raw_free(allocator, v_str.str_.data);
        }

        case .Array {
            v_arr := cast(^Value_Array) v;
            for elem: v_arr.array_ {
                free(elem, allocator);
            }
            array.free(^v_arr.array_);
        }

        case .Object {
            v_obj := cast(^Value_Object) v;
            for ^entry: v_obj.object_ {
                raw_free(allocator, entry.key.data);
                free(entry.value, allocator);
            }
            array.free(^v_obj.object_);
        }
    },

    (use j: Json) {
        free(root, allocator);
    },
}
