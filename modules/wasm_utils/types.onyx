package wasm_utils

WasmSection :: enum {
    Custom    :: 0x00;
    Type      :: 0x01;
    Import    :: 0x02;
    Function  :: 0x03;
    Table     :: 0x04;
    Memory    :: 0x05;
    Global    :: 0x06;
    Export    :: 0x07;
    Start     :: 0x08;
    Element   :: 0x09;
    Code      :: 0x0a;
    Data      :: 0x0b;
    DataCount :: 0x0c;
}

#add_match hash.to_u32, (w: WasmSection) -> u32 {
    return hash.to_u32(cast(u32) w);
}

WasmBinary :: struct {
    data: [] u8;

    // Section number -> Offset into data
    // This does not work for custom sections, as they all have the same section number
    section_locations : map.Map(WasmSection, i32);

    // So there is a custom section location that maps the name of the custom section
    // to the offset into the file. The backing-store for the keys is just the data
    // itself, as the names are in the data for the binary.
    custom_section_locations : map.Map(str, i32);
}

load :: (data: [] u8, allocator := context.allocator) -> WasmBinary {
    binary: WasmBinary;
    binary.data = data;
    
    #context_scope {
        context.allocator = allocator;
        map.init(^binary.section_locations, -1);
        map.init(^binary.custom_section_locations, -1);
    }

    assert(parse_section_locations(^binary), "Failed to parse WASM binary");

    return binary;
}


#private_file
parse_section_locations :: (use bin: ^WasmBinary) -> bool {
    stream := io.string_stream_make(data);
    reader := io.reader_make(^stream);

    {
        // Checking the magic string
        magic_buffer: [4] u8; 

        if !(io.read_bytes(^reader, cast([] u8) magic_buffer) == ~~u8.[ 0, #char "a", #char "s", #char "m" ]) do return false;
        if !(io.read_bytes(^reader, cast([] u8) magic_buffer) == ~~u8.[ 1, 0, 0, 0 ]) do return false; // This may not be necessary
    }
 
    while !io.stream_end_of_file(^stream) {
        section_number := cast(WasmSection) io.read_byte(^reader);
        section_size   := read_uleb128(^reader);
        _, pos := io.stream_tell(^stream);

        switch section_number {
            @Incomplete
            case .Custom ---

            case .Type, .Import, .Function, .Table, .Memory, .Global,
                .Export, .Start, .Element, .Code, .Data, .DataCount  {
                map.put(^section_locations, section_number, pos);
            }

            case #default {
                buffer: [128] u8;
                conv :: package core.conv
                assert(false, conv.str_format("Bad section number {}", ~~buffer, cast(i32) section_number));
            }
        }

        err := io.stream_seek(^stream, pos + ~~section_size, .Start);
        if err == .OutOfBounds do break;
    }

    return true;
}
