package bmfont

use package core
#private_file json :: package json

load_bmfont :: (fnt_data: [] u8) -> BMFont {
    bmf := create_bmfont();

    parse_bmfont(fnt_data, ^bmf);

    for ^it: bmf.glyphs.entries {
        it.value.tex_x = ~~ it.value.x / cast(f32) bmf.common.scale_width;        
        it.value.tex_y = ~~ it.value.y / cast(f32) bmf.common.scale_height;        
        it.value.tex_w = ~~ it.value.w / cast(f32) bmf.common.scale_width;        
        it.value.tex_h = ~~ it.value.h / cast(f32) bmf.common.scale_height;        
    }

    return bmf;
}

load_bmfont_from_json :: (fnt_data: [] u8) -> BMFont {
    bmf := create_bmfont();

    j := json.decode(fnt_data);
    defer json.free(j);

    extract_bmfont_from_json(^bmf, j.root);
}

#private_file
create_bmfont :: () -> BMFont {
    bmf: BMFont;
    memory.set(^bmf, 0, sizeof BMFont);

    map.init(^bmf.pages);
    map.init(^bmf.glyphs);

    return bmf;
}

#private_file
parse_bmfont :: (fnt_data: [] u8, font: ^BMFont) {
    R :: package core.string.reader

    parser_arena := alloc.arena.make(context.allocator, arena_size=4 * 1024);
    parser_allocator := alloc.arena.make_allocator(^parser_arena);
    defer alloc.arena.free(^parser_arena);

    reader := R.make(fnt_data);

    while !R.empty(^reader) {
        line := R.read_line(^reader);
        pieces := string.split(line, #char " ", allocator=parser_allocator);

        tag := pieces[0];
        pieces = pieces.data[1 .. pieces.count];

        if tag == "page" {
            id := -1;
            filename := null_str;

            for ^piece: pieces {
                key := string.read_until(piece, #char "=");
                string.advance(piece, 1);

                if key == "id"   do id = ~~ conv.str_to_i64(*piece);
                if key == "file" do filename = string.alloc_copy(*piece);
            }

            map.put(^font.pages, id, filename);
            continue;
        }

        if tag == "char" {
            char: BMFont_Glyph;

            for ^piece: pieces {
                key := string.read_until(piece, #char "=");
                string.advance(piece, 1);

                if     key == "id"       do char.id = ~~ conv.str_to_i64(*piece);
                elseif key == "x"        do char.x  = ~~ conv.str_to_i64(*piece);
                elseif key == "y"        do char.y  = ~~ conv.str_to_i64(*piece);
                elseif key == "width"    do char.w  = ~~ conv.str_to_i64(*piece);
                elseif key == "height"   do char.h  = ~~ conv.str_to_i64(*piece);
                elseif key == "xoffset"  do char.xoffset = ~~ conv.str_to_i64(*piece);
                elseif key == "yoffset"  do char.yoffset = ~~ conv.str_to_i64(*piece);
                elseif key == "xadvance" do char.xadvance = ~~ conv.str_to_i64(*piece);
                elseif key == "page"     do char.page = ~~ conv.str_to_i64(*piece);
                elseif key == "chhl"     do char.channel = ~~ conv.str_to_i64(*piece);
            }

            map.put(^font.glyphs, char.id, char);
            continue;
        }

        @Note // this for loop is very destructive of the data that is here, but
        // it is assumed that after a line is processed, the data will not be needed
        // again. To be clear, this means that it destroys the pieces from the split,
        // not the data in fnt_data.
        for ^piece: pieces {
            key := string.read_until(piece, #char "=");
            string.advance(piece, 1);

            if tag == "info"   do parse_info_tag(font, parser_allocator, key, *piece);
            if tag == "common" do parse_common_tag(font, parser_allocator, key, *piece);
        }
    }

    parse_info_tag :: (font: ^BMFont, parser_allocator: Allocator, key: str, value: str) {
        info := ^font.info;

        if     key == "face"     do info.face_name = string.alloc_copy(value);
        elseif key == "size"     do info.size = ~~ conv.str_to_i64(value);
        elseif key == "bold"     do info.bold   = value == "1";
        elseif key == "italic"   do info.italic = value == "1";
        elseif key == "charset"  do info.charset = string.alloc_copy(value);
        elseif key == "unicode"  do info.unicode = value == "1";
        elseif key == "stretchH" do info.stretchH = ~~ conv.str_to_i64(value);
        elseif key == "smooth"   do info.smooth = value == "1";
        elseif key == "aa"       do info.supersampling = ~~ conv.str_to_i64(value);

        elseif key == "padding" {
            values := string.split(value, #char ",", allocator=parser_allocator);
            info.padding.top    = ~~ conv.str_to_i64(values[0]);
            info.padding.right  = ~~ conv.str_to_i64(values[1]);
            info.padding.bottom = ~~ conv.str_to_i64(values[2]);
            info.padding.left   = ~~ conv.str_to_i64(values[3]);
        }

        elseif key == "spacing" {
            values := string.split(value, #char ",", allocator=parser_allocator);
            info.spacing.horizontal = ~~ conv.str_to_i64(values[0]);
            info.spacing.vertical   = ~~ conv.str_to_i64(values[1]);
        }
    }

    parse_common_tag :: (font: ^BMFont, parser_allocator: Allocator, key: str, value: str) {
        common := ^font.common;

        if     key == "lineHeight" do common.line_height = ~~ conv.str_to_i64(value);
        elseif key == "base"       do common.baseline = ~~ conv.str_to_i64(value);
        elseif key == "scaleW"     do common.scale_width = ~~ conv.str_to_i64(value);
        elseif key == "scaleH"     do common.scale_height = ~~ conv.str_to_i64(value);
        elseif key == "pages"      do common.page_count = ~~ conv.str_to_i64(value);
        elseif key == "packed"     do common.packed = value == "1";
        elseif key == "alphaChnl"  do common.alpha_channel = ~~ conv.str_to_i64(value);
        elseif key == "redChnl"    do common.red_channel   = ~~ conv.str_to_i64(value);
        elseif key == "greenChnl"  do common.alpha_channel = ~~ conv.str_to_i64(value);
        elseif key == "blueChnl"   do common.blue_channel  = ~~ conv.str_to_i64(value);
    }
}

#private_file
extract_bmfont_from_json :: (font: ^BMFont, root: ^json.Value) {
    font_info          := root["info"];
    font.info.face_name = font_info["face"]->as_str();
    font.info.size      = ~~font_info["size"]->as_int();
    font.info.bold      = font_info["bold"]->as_int() != 0;
    font.info.italic    = font_info["italic"]->as_int() != 0;
    font.info.unicode   = font_info["unicode"]->as_int() != 0;
    font.info.stretchH  = ~~font_info["stretchH"]->as_int();
    font.info.smooth    = font_info["smooth"]->as_int() != 0;
    font.info.supersampling = ~~font_info["aa"]->as_int();

    font_padding := font_info["padding"];
    font.info.padding.top    = ~~font_padding[0]->as_int();
    font.info.padding.right  = ~~font_padding[1]->as_int();
    font.info.padding.bottom = ~~font_padding[2]->as_int();
    font.info.padding.left   = ~~font_padding[3]->as_int();

    font_spacing := font_info["spacing"];
    font.info.spacing.horizontal = ~~font_spacing[0]->as_int();
    font.info.spacing.vertical   = ~~font_spacing[1]->as_int();

    font_common := root["common"];
    font.common.line_height   = ~~font_common["lineHeight"]->as_int();
    font.common.baseline      = ~~font_common["base"]->as_int();
    font.common.scale_width   = ~~font_common["scaleW"]->as_int();
    font.common.scale_height  = ~~font_common["scaleH"]->as_int();
    font.common.page_count    = ~~font_common["pages"]->as_int();
    font.common.packed        = font_common["packed"]->as_int() != 0;
    font.common.alpha_channel = ~~font_common["alphaChnl"]->as_int();
    font.common.red_channel   = ~~font_common["redChnl"]->as_int();
    font.common.green_channel = ~~font_common["greenChnl"]->as_int();
    font.common.blue_channel  = ~~font_common["blueChnl"]->as_int();

    i := 0;
    for page: root["pages"]->as_array() {
        defer i += 1;

        font.pages[i] = page->as_str();
    }

    for ch: root["chars"]->as_array() {
        id := cast(i32) ch["id"]->as_int();
        font.glyphs[id] = .{
            id = id,

            x = ~~ch["x"]->as_int(),
            y = ~~ch["y"]->as_int(),
            w = ~~ch["width"]->as_int(),
            h = ~~ch["height"]->as_int(),

            xoffset  = ~~ch["xoffset"]->as_int(),
            yoffset  = ~~ch["yoffset"]->as_int(),
            xadvance = ~~ch["xadvance"]->as_int(),

            page    = ~~ch["page"]->as_int(),
            channel = ~~ch["chnl"]->as_int(),
        };
    }
}
