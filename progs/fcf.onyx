use "progs/print_funcs"
use "progs/intrinsics"

use package printing

call_me :: proc (f: proc (i32) -> i32, val: i32) {
	f(val);
}

funcs : [5] proc (i32, i32) -> i32

add :: proc (a: i32, b: i32) -> i32 { return a + b; }
sub :: proc (a: i32, b: i32) -> i32 { return a - b; }
mul :: proc (a: i32, b: i32) -> i32 { return a * b; }
div :: proc (a: i32, b: i32) -> i32 { return a / b; }
mod :: proc (a: i32, b: i32) -> i32 { return a % b; }

DeferredCall :: struct {
    func  : proc (i32, i32) -> i32;
    left  : i32;
    right : i32;
}

execute :: proc (use dc: ^DeferredCall) -> i32 {
    return func(left, right);
}

echo :: proc (i: i32) -> i32 {
    print(i);
    return i;
}

I32Array :: struct {
    length : i32;
    data   : ^i32;
}

array_map :: proc (arr: I32Array, map: proc (i32) -> i32) {
    for i: 0, arr.length arr.data[i] = map(arr.data[i]);
}

minus_one :: proc (n: i32) -> i32 { return n - 1; }
double :: proc (n: i32) -> i32 { return n << 1; }

proc #export "main" {
	call_me(echo, 10);

    print(add as i32);

    funcs[0] = add;
    funcs[1] = sub;
    funcs[2] = mul;
    funcs[3] = div;
    funcs[4] = mod;

    for i: 0, 5 print(funcs[i](10, 3));

    dc := __heap_start as ^DeferredCall;
    dc.func = mod;
    dc.left = 40;
    dc.right = 19;

    print(execute(dc));

    len :: 10;
    data := (__heap_start as i32 + sizeof DeferredCall) as ^i32;
    for i: 0, len data[i] = i;
    print(data as [] i32, len);

    add_one :: proc (n: i32) -> i32 { return n + 1; };

    array_map(len, data, add_one);
    print(data as [] i32, len);
}
