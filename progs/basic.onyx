pointer_test :: proc {
    p := 0 as ^i32;
}

print :: proc
    #foreign "host" "print"
    (val: i32) ---

printf :: proc
    #foreign "host" "print"
    (val: f32) ---

test :: proc (a: bool) -> bool {
    return !a;
}

foo :: proc (n: i32) -> i32 {
    a :: shl_i32(n, 1);
    b :: shl_i32(n, 2);
    return or_i32(a, b);
}

// THOUGHT: This could be a WASM global that is immutable and it
// would be accessed using global.get
// OR
// This could be immediately substituted in the expression tree. i.e.
//      4 + global       =>       4 + (5 * 2 + 6)
global_value :: 5 * 2 + 6

// WASM globals would be declared as such:
wasm_global :: global i32

main :: proc #export {
    a := 16;
    print(clz_i32(a));

    wasm_global = 5 + global_value;
    print(wasm_global);

    print(4 + global_value);

    b := 1 + foo(2);
    if b == 13 b = 10;
    print(b);

    if b == 13 print(5678);
    else       print(1024);

    if b == 13 ---

    while true {
        while true {
            while true {
                foo := 20;
                foo = global_value + 10;
                print(foo);
                break;
            }
            break;
        }
        break;
    }

    cond :: true;
    print(test(cond) as i32);
}

use "progs/intrinsics"

