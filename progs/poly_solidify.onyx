#load "core/std"

use package core

max_f32 :: #solidify math.max_poly { T = f32 };

compose :: (a: $A, f: (A) -> $B, g: (B) -> $C) -> C do return g(f(a));

specific_compose_0 :: #solidify compose { B = f32 };
specific_compose_1 :: #solidify specific_compose_0 { A = f32 };
specific_compose_2 :: #solidify specific_compose_1 { C = f64 };

main :: (args: [] cstr) {
    use package runtime
    println(Runtime);
    println("==================================================");

    printf("max(1, 2) = %i\n", math.max(1, 2));
    printf("max_f32(1.0, 2.0) = %f\n", max_f32(1, 2));

    // printf("max_f32(1, 2) = %i\n", max_f32(cast(u32) 1, cast(u32) 2));

    println(specific_compose_2(
        2,
        (a: f32) -> f32 { return ~~(a * 2); },
        (b: f32) -> f64 { return ~~(b + 6); }));


    arr1 := array.make(f32);
    arr2 := array.make(i32);
    defer array.free(^arr1);
    defer array.free(^arr2);

    for i: 0 .. 10 {
        array.push(^arr1, ~~i);
        array.push(^arr2, ~~i);
    }
    print_arrays(arr1, arr2);

    array_map(arr1, double);
    array_map(arr2, double);

    print_arrays(arr1, arr2);

    print_arrays :: (arr1: [..] $T, arr2: [..] $R) {
        println("==================================================");
        print_array(arr1);
        print_array(arr2);
        println("==================================================");
    }
}

array_map :: (arr: [..] $T, f: (T) -> T) {
    foo := #solidify math.max_poly { T = T };
    is := (#type InternalStruct(T)).{ foo = foo(6, 2) };
    printf("%i\n", is.foo);

    for ^v: arr do *v = f(*v);

    {
        test2();

        test2 :: () {
            test();

            is : InternalStruct([] u32);

            println("WORLD!!!!");
        }

        test  :: () {
            println("HELLO!!!");
        }
    }

    InternalStruct :: struct (SOMETHING: type_expr) {
        foo : SOMETHING;
    }
}

double :: (v: $V) -> V do return v * 2;
