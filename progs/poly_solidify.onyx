#include_file "core/std/wasi"

use package core

max_f32 :: #solidify math.max { T = f32 };

compose :: proc (a: $A, f: proc (A) -> $B, g: proc (B) -> $C) -> C do return g(f(a));

specific_compose_0 :: #solidify compose { B = f32 };
specific_compose_1 :: #solidify specific_compose_0 { A = f32 };
specific_compose_2 :: #solidify specific_compose_1 { C = f64 };

main :: proc (args: [] cstr) {
	printf("max(1, 2) = %i\n", math.max(1, 2));
	printf("max_f32(1.0, 2.0) = %f\n", max_f32(1, 2));

	// printf("max_f32(1, 2) = %i\n", max_f32(cast(u32) 1, cast(u32) 2));

	println(specific_compose_2(
		2,
		proc (a: f32) -> f32 { return ~~(a * 2); },
		proc (b: f32) -> f64 { return ~~(b + 6); }));


    arr : [..] i32;
    array.init(^arr);
    defer array.free(^arr);


    for i: 0 .. 10 do array.push(^arr, ~~i);
    print_array(arr);

    array_map(arr, double);
    print_array(arr);
}

array_map :: proc (arr: [..] $T, f: proc (T) -> T) {
    for ^v: arr do *v = f(*v);
}

double :: proc (v: $V) -> V do return v * 2;