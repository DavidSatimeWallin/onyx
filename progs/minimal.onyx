
print       :: foreign "host" "print" proc (value i32) ---
print_float :: foreign "host" "print" proc (value f32) ---
print_if    :: foreign "host" "print" proc (i i32, f f32) ---

export main :: proc {
    output := do_stuff() - 1;

    if output == -66 {
        new_output := abs(output) * 2;
        print(new_output);

    } elseif output == -67 {
        print(factorial(6));

    } else {
        print(-1);
    }

    print(fib(5));

    print(output);
    print_float(float_test());

    print_if(output, float_test());
}

factorial :: proc (n i32) -> i32 {
    if n <= 1 { return 1; }

    return n * factorial(n - 1);
}

foo :: proc -> i32 {
    return 10;
}

add :: proc (a i32, b i32) -> i32 {
    return a + b;
}

// NOTE: There is a weird bug here if the else is used instead
// This is because the WASM embedder does not think that it
// is possible that all code paths are covered with returning
// an i32. This will need to be fixed.
abs :: proc (val i32) -> i32 {
    if val <= 0 { return -val; }
    // else { return val; };
    return val;
}

fib :: proc (n i32) -> i32 {
    if n <= 1 { return 1; }
    return fib(n - 1) + fib(n - 2);
}

diff_square :: proc (a i32, b i32) -> i32 {
    // Typechecked
    c := a - b; // Mutable
    d :: a + b; // Constant

    {
        c := a * 2;
        d := (b + a) * 2;
    }

    return c * d;
}

do_stuff :: proc -> i32 {
    res := diff_square(4 + 5, 2 + 3);
    res = res + foo();
    return res * -1;
}

float_test :: proc -> f32 {
    return 3.14159f;
}
