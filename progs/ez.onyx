use "progs/print_funcs"
use "progs/intrinsics"

use package printing {
    print, PrintableArray,
    print_f32 as pf32
}

Foo :: struct {
    x : i32;
    y : i32;

    st : SomeType;
}

foo_sum :: proc (use this: ^Foo) -> i32 {
    foo_other(this);
    return x + y;
}

foo_other :: proc (use this: ^Foo) {
    print(cast(i32) st);
}

asdf :: proc (pa: PrintableArray) {
    for i: 0, pa.len print(cast(i32) pa.data[i]);
}

SomeType :: enum {
    Value1;
    Value2;
    Value3;
    Value4;
}

print_st :: proc (st: SomeType, other: i32) {
    print(cast(i32) st);
}

single_int : u32

N :: 1024
array : [N] Foo

proc #export "main" {
    print("Hello World! this is slightly longer\n");

    print(cast(i32) __heap_start);

    single_int = 10;
    print(single_int);

    array[4].y = 1234;
    print(array[4].y);

    st: SomeType = SomeType.Value4;
    print_st(st, 10);

    foo := cast(^Foo) __heap_start;
    foo.x = 123;
    foo.y = 321;
    foo.st = st;
    print(alignof Foo);
    print(sizeof Foo);
    print(foo_sum(foo));
    print_st(foo.st, 20);

    pa := cast(^PrintableArray) (cast(i32) __heap_start + sizeof Foo);
    pa.data = cast(^u8) __heap_start;
    pa.len = 5;
    asdf(*pa);

    print(1234);

    pf32(sqrt_f32(123.0f));
}

