package main

#include_folder "/usr/share/onyx/core"

#include_file "builtin"
#include_file "wasi"
#include_file "alloc"
#include_file "intrinsics"
#include_file "random"
#include_file "string"

use package builtin

// NOTE: Didn't realize this would work so easily
use package core { string_builder_append as sba }
use package core

use package memory
use package wasi
use package intrinsics

print_u64_with_base :: proc (n_: u64, base: u64) {
    n := n_;
    str: [256] u8;
    for i: 0, 256 do str[i] = #char "\0";

    c := cast(^u8) ^str[255];
    *c = #char "\0";
    c -= 1;

    s :: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/";

    if n == 0l {
        *c = #char "0";
        c -= 1;
    } else {
        while n > 0l {
            m :: n % base;

            *c = s.data[cast(u32) m];
            c -= 1;

            n /= base;
        }
    }

    if base == 16l {
        *c = #char "x";
        c -= 1;
        *c = #char "0";
        c -= 1;
    }

    if base == 2l {
        *c = #char "b";
        c -= 1;
        *c = #char "0";
        c -= 1;
    }

    print(c + 1);
}

print_string :: proc (s: string) -> u32 {
    vec := IOVec.{ buf = s.data, len = s.count };
    tmp : Size;
    fd_write(1, IOVecArray.{ ^vec, 1 }, ^tmp);
    fd_datasync(1);

    return tmp;
}

print_u8 :: proc (s: cstring) -> u32 {
    return string_make(s) |> print_string();
}

print :: proc #overloaded { print_string, print_u8 }

print_rights :: proc (rights: Rights) {
    print_u64_with_base(cast(u64) rights, 2l);
    print("\n");

    if rights & Rights.DataSync != cast(Rights) 0 do print("DataSync\n");
    if rights & Rights.Read != cast(Rights) 0 do print("Read\n");
    if rights & Rights.Seek != cast(Rights) 0 do print("Seek\n");
    if rights & Rights.FdStatSetFlags != cast(Rights) 0 do print("FdStatSetFlags\n");
    if rights & Rights.Sync != cast(Rights) 0 do print("Sync\n");
    if rights & Rights.Tell != cast(Rights) 0 do print("Tell\n");
    if rights & Rights.Write != cast(Rights) 0 do print("Write\n");
    if rights & Rights.Advise != cast(Rights) 0 do print("Advise\n");
    if rights & Rights.Allocate != cast(Rights) 0 do print("Allocate\n");
    if rights & Rights.PathCreateDirectory != cast(Rights) 0 do print("PathCreateDirectory\n");
    if rights & Rights.PathCreateFile != cast(Rights) 0 do print("PathCreateFile\n");
    if rights & Rights.PathLinkSource != cast(Rights) 0 do print("PathLinkSource\n");
    if rights & Rights.PathLinkTarget != cast(Rights) 0 do print("PathLinkTarget\n");
    if rights & Rights.PathOpen != cast(Rights) 0 do print("PathOpen\n");
    if rights & Rights.ReadDir != cast(Rights) 0 do print("ReadDir\n");
    if rights & Rights.PathReadlink != cast(Rights) 0 do print("PathReadlink\n");
    if rights & Rights.PathRenameSource != cast(Rights) 0 do print("PathRenameSource\n");
    if rights & Rights.PathRenameTarget != cast(Rights) 0 do print("PathRenameTarget\n");
    if rights & Rights.PathFilestatGet != cast(Rights) 0 do print("PathFilestatGet\n");
    if rights & Rights.PathFilestateSetSize != cast(Rights) 0 do print("PathFilestateSetSize\n");
    if rights & Rights.PathFilestateSetTimes != cast(Rights) 0 do print("PathFilestateSetTimes\n");
    if rights & Rights.FilestatGet != cast(Rights) 0 do print("FilestatGet\n");
    if rights & Rights.FilestatSetSize != cast(Rights) 0 do print("FilestatSetSize\n");
    if rights & Rights.FilestatSetTimes != cast(Rights) 0 do print("FilestatSetTimes\n");
    if rights & Rights.PathSymlink != cast(Rights) 0 do print("PathSymlink\n");
    if rights & Rights.PathRemoveDirectory != cast(Rights) 0 do print("PathRemoveDirectory\n");
    if rights & Rights.PathUnlinkFile != cast(Rights) 0 do print("PathUnlinkFile\n");
    if rights & Rights.PollFDReadWrite != cast(Rights) 0 do print("PollFDReadWrite\n");
    if rights & Rights.SockShutdown != cast(Rights) 0 do print("SockShutdown\n");
}

readline :: proc (buf: ^u8, bufsize: u32) -> u32 {
    iov := IOVec.{ buf, bufsize };
    nread : Size;
    fd_pread(0, IOVecArray.{ ^iov, 1 }, 0l, ^nread);

    return nread;
}

readdir :: proc (fd: FileDescriptor) {
    buf : [1024] u8;
    bufused : Size;

    if fd_readdir(fd, cast(^u8) buf, 1024, cast(DirCookie) 0, ^bufused) != Errno.Success {
        print("Failed to readdir\n");
        return;
    }

    dirent := cast(^DirEnt) buf;
    while true {
        print(string.{ cast(^u8) (cast(u32) dirent + sizeof DirEnt), dirent.d_namlen });
        print("\n");

        print("\td_namlen: ");
        print_u64_with_base(cast(u64) dirent.d_namlen, 16l);
        print("\n");
        print("\td_type: ");
        print_u64_with_base(cast(u64) dirent.d_type, 16l);
        print("\n");

        bufused -= sizeof DirEnt + dirent.d_namlen;
        dirent = cast(^DirEnt) (cast(u32) dirent + sizeof DirEnt + dirent.d_namlen);

        if bufused <= 0 do break;
    }
}

timer_start :: proc -> Timestamp {
    curr_time: Timestamp;
    clock_time_get(ClockID.Realtime, cast(Timestamp) 1, ^curr_time);
    return curr_time;
}

timer_end :: proc (start_time: Timestamp) -> Timestamp {
    curr_time: Timestamp;
    clock_time_get(ClockID.Realtime, cast(Timestamp) 1, ^curr_time);
    return (curr_time - start_time) / 1000000l;
}

is_prime :: proc (n: u32) -> bool {
    sqrt :: cast(i32) (sqrt_f32(cast(f32) n));
    for i: 2, sqrt + 1 do if n % i == 0 do return false;
    return true;
}

Vec3 :: struct {
    x: f32;
    y: f32;
    z: f32;
}

S :: struct {
    name: string;
    age:  u32;
    pos:  Vec3;
}

output_s :: proc (sb: ^StringBuilder, s: ^S) -> ^StringBuilder {
    sb  |> sba("Hello, I'm ")
        |> sba(s.name)
        |> sba(". I am ")
        |> sba(cast(u64) s.age)
        |> sba(" years old. I am at (")
        |> sba(cast(u64) s.pos.x) |> sba(", ")
        |> sba(cast(u64) s.pos.y) |> sba(", ")
        |> sba(cast(u64) s.pos.z) |> sba(").\n");

    return sb;
}

print_arr :: proc (sb: ^StringBuilder, arr: []i32) {
    sb  |> string_builder_clear();

    a := arr.data;

    for i: 0, arr.count {
        sb |> sba(cast(u64) a[i]) |> sba(" ");
    }

    sb |> sba("\n") |> string_builder_to_string() |> print();
}

make_i32_arr :: proc (a: Allocator, len: u32) -> [] i32 {
    arr := cast(^i32) alloc(a, sizeof i32 * len);
    return arr[0 : len];
}

main :: proc (args: []cstring) {
    sb := string_builder_make(heap_allocator, 256);

    timer := timer_start();
    defer {
        ^sb |> string_builder_clear()
            |> sba("\nTime taken: ")
            |> sba(cast(u64) timer_end(timer), 10l)
            |> sba("ms\n")
            |> string_builder_to_string()
            |> print();
    }

    ^sb |> sba("There are ")
        |> sba(cast(u64) args.count)
        |> sba(" arguments.\n");

    for i: 0, args.count do ^sb |> sba(args.data[i]) |> sba(" ");
    ^sb |> sba("\n")
        |> string_builder_to_string()
        |> print();

    fd: FileDescriptor = -1;
    if err := path_open(3, LookupFlags.SymLinkFollow, string_make(args.data[1]), cast(OFlags) 0, Rights.DataSync | Rights.Write | Rights.Read | Rights.Tell | Rights.Seek | Rights.Advise | Rights.PathOpen | Rights.PathCreateFile, Rights.DataSync | Rights.Write | Rights.Read | Rights.Tell | Rights.Seek | Rights.Advise | Rights.PathOpen | Rights.PathCreateFile, FDFlags.Sync, ^fd); err != Errno.Success {
        print("Failed to open file\n");
        print("Error code: ");
        print_u64_with_base(cast(u64) err, 16l);
        proc_exit(1);
    }
    defer fd_close(fd);

    print_u64_with_base(cast(u64) fd, 16l);
    print("\n");

    filelen : Filesize;
    if fd_seek(fd, 0l, Whence.End, ^filelen) != Errno.Success {
        print("Failed to seek in file\n");
        proc_exit(1);
    }
    print("the size is: ");
    print_u64_with_base(cast(u64) filelen, 10l);
    print("\n");

    sum := 0l;
    for i: 0, 20000 do if is_prime(i) do sum += cast(u64) i;
    print("Sum of primes less than 20000 is: ");
    print_u64_with_base(sum, 10l);
    print("\n");

    matches := string_split(heap_allocator, "This is a test string to test splitting. It surprisingly works very well.", #char " ");
    defer free(heap_allocator, matches.data);

    string_builder_clear(^sb);
    for i: 0, matches.count {
        ^sb |> sba(matches.data[i])
            |> sba("\n");
    }

    ^sb |> string_builder_to_string() |> print();

    program := "+ + * s - /";
    tokens := string_split(heap_allocator, program, #char " ");
    defer free(heap_allocator, tokens.data);

    acc := 0;
    for i: 0, tokens.count {
        switch tokens.data[i].data[0] {
            case #char "+" do acc += 1;
            case #char "-" do acc -= 1;
            case #char "*" do acc *= 2;
            case #char "/" do acc /= 2;

            case #char "s" do acc *= acc;

            case #default {
                print("Unexpected token: ");
                print_u64_with_base(cast(u64) tokens.data[i].data[0], 16l);
                print("\n");
            }
        }
    }

    string_builder_clear(^sb);
    ^sb |> sba("The program evaluated to '") |> sba(cast(u64) acc) |> sba("'\n");
    ^sb |> string_builder_to_string() |> print();
    ^sb |> string_builder_clear();

    person := S.{ name = "Tester", age = 45, pos = Vec3.{ 1.0f, 2.0f, 3.0f } };
    ^sb |> output_s(^person)
        |> sba("Here is another message in the same string!\n")
        |> string_builder_to_string()
        |> print();

    if res := 5 + 4; res == 9 {
        ^sb |> string_builder_clear()
            |> sba("This worked! ")
            |> sba(cast(u64) ^res)
            |> sba("\n")
            |> string_builder_to_string()
            |> print();
    } else {
        ^sb |> string_builder_clear()
            |> sba("This did not work! ")
            |> sba(cast(u64) ^res)
            |> sba("\n")
            |> string_builder_to_string()
            |> print();
    }

    ^sb |> string_builder_clear();
    while i := 0; i < 10 {
        ^sb |> sba("Loop: ") |> sba(cast(u64) i) |> sba("\n");

        i += 1;
    } else {
        print("Never ran the loop\n");
    }

    ^sb |> string_builder_to_string() |> print();


    arr : [128] i32;
    for i: 0, 128 do arr[i] = i * i;

    print_arr(^sb, arr[5 : 10]);

    ss := string_substr("Hello, World!", "World");
    if ss.count > 0 {
        print(ss);
    }
}
