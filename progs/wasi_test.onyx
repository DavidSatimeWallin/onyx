package main

#include_folder "/usr/share/onyx/core"

#include_file "builtin"
#include_file "wasi"
#include_file "alloc"
#include_file "intrinsics"
#include_file "random"
#include_file "string"

use package builtin
use package core
use package memory
use package wasi
use package intrinsics

print_u64_with_base :: proc (n_: u64, base: u64) {
    n := n_;
    str: [256] u8;
    for i: 0, 256 do str[i] = #char "\0";

    c := cast(^u8) ^str[255];
    *c = #char "\0";
    c -= 1;

    s :: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/";

    if n == 0l {
        *c = #char "0";
        c -= 1;
    } else {
        while n > 0l {
            m :: n % base;

            *c = s.data[cast(u32) m];
            c -= 1;

            n /= base;
        }
    }

    if base == 16l {
        *c = #char "x";
        c -= 1;
        *c = #char "0";
        c -= 1;
    }

    if base == 2l {
        *c = #char "b";
        c -= 1;
        *c = #char "0";
        c -= 1;
    }

    print(c + 1);
}

print_string :: proc (s: string) {
	vec := IOVec.{ buf = s.data, len = s.len };
	tmp : Size;	
	fd_write(1, IOVecArray.{ ^vec, 1 }, ^tmp);
	fd_datasync(1);
}

print_u8 :: proc (s: cstring) {
	string_make(s) |> print_string();
}

print :: proc #overloaded { print_string, print_u8 }

print_rights :: proc (rights: Rights) {
	print_u64_with_base(cast(u64) rights, 2l);
	print("\n");

	if rights & Rights.DataSync != cast(Rights) 0 do print("DataSync\n");
	if rights & Rights.Read != cast(Rights) 0 do print("Read\n");
	if rights & Rights.Seek != cast(Rights) 0 do print("Seek\n");
	if rights & Rights.FdStatSetFlags != cast(Rights) 0 do print("FdStatSetFlags\n");
	if rights & Rights.Sync != cast(Rights) 0 do print("Sync\n");
	if rights & Rights.Tell != cast(Rights) 0 do print("Tell\n");
	if rights & Rights.Write != cast(Rights) 0 do print("Write\n");
	if rights & Rights.Advise != cast(Rights) 0 do print("Advise\n");
	if rights & Rights.Allocate != cast(Rights) 0 do print("Allocate\n");
	if rights & Rights.PathCreateDirectory != cast(Rights) 0 do print("PathCreateDirectory\n");
	if rights & Rights.PathCreateFile != cast(Rights) 0 do print("PathCreateFile\n");
	if rights & Rights.PathLinkSource != cast(Rights) 0 do print("PathLinkSource\n");
	if rights & Rights.PathLinkTarget != cast(Rights) 0 do print("PathLinkTarget\n");
	if rights & Rights.PathOpen != cast(Rights) 0 do print("PathOpen\n");
	if rights & Rights.ReadDir != cast(Rights) 0 do print("ReadDir\n");
	if rights & Rights.PathReadlink != cast(Rights) 0 do print("PathReadlink\n");
	if rights & Rights.PathRenameSource != cast(Rights) 0 do print("PathRenameSource\n");
	if rights & Rights.PathRenameTarget != cast(Rights) 0 do print("PathRenameTarget\n");
	if rights & Rights.PathFilestatGet != cast(Rights) 0 do print("PathFilestatGet\n");
	if rights & Rights.PathFilestateSetSize != cast(Rights) 0 do print("PathFilestateSetSize\n");
	if rights & Rights.PathFilestateSetTimes != cast(Rights) 0 do print("PathFilestateSetTimes\n");
	if rights & Rights.FilestatGet != cast(Rights) 0 do print("FilestatGet\n");
	if rights & Rights.FilestatSetSize != cast(Rights) 0 do print("FilestatSetSize\n");
	if rights & Rights.FilestatSetTimes != cast(Rights) 0 do print("FilestatSetTimes\n");
	if rights & Rights.PathSymlink != cast(Rights) 0 do print("PathSymlink\n");
	if rights & Rights.PathRemoveDirectory != cast(Rights) 0 do print("PathRemoveDirectory\n");
	if rights & Rights.PathUnlinkFile != cast(Rights) 0 do print("PathUnlinkFile\n");
	if rights & Rights.PollFDReadWrite != cast(Rights) 0 do print("PollFDReadWrite\n");
	if rights & Rights.SockShutdown != cast(Rights) 0 do print("SockShutdown\n");
}

readline :: proc (buf: ^u8, bufsize: u32) -> u32 {
	iov := IOVec.{ buf, bufsize };
	nread : Size;
	fd_pread(0, IOVecArray.{ ^iov, 1 }, 0l, ^nread);

	return nread;
}

readdir :: proc (fd: FileDescriptor) {
	buf : [1024] u8;
	bufused : Size;

	if fd_readdir(fd, cast(^u8) buf, 1024, cast(DirCookie) 0, ^bufused) != Errno.Success {
		print("Failed to readdir\n");
		return;
	}

	dirent := cast(^DirEnt) buf;
	while true {
		print(string.{ cast(^u8) (cast(u32) dirent + sizeof DirEnt), dirent.d_namlen });
		print("\n");

		print("\td_namlen: ");
		print_u64_with_base(cast(u64) dirent.d_namlen, 16l);
		print("\n");
		print("\td_type: ");
		print_u64_with_base(cast(u64) dirent.d_type, 16l);
		print("\n");

		bufused -= sizeof DirEnt + dirent.d_namlen;
		dirent = cast(^DirEnt) (cast(u32) dirent + sizeof DirEnt + dirent.d_namlen);

		if bufused <= 0 do break;
	}
}

main :: proc #export "_start" {
	memory_init();

	curr_time: Timestamp;
	clock_time_get(ClockID.Realtime, cast(Timestamp) 1, ^curr_time);
	print_u64_with_base(cast(u64) curr_time, 10l);
	print("\n");

	print("Hello World!\n");
	print_u64_with_base(cast(u64) 0x624abd, 16l);
	print("\n");
	print_u64_with_base(cast(u64) __stack_top, 16l);
	print("\n");
	print_u64_with_base(cast(u64) __heap_start, 16l);
	print("\n");

	fd : FileDescriptor;
	err := path_open(3,
		LookupFlags.SymLinkFollow,
		"./src/onyxmsgs.c".data, 16,
		cast(OFlags) 0,
		Rights.DataSync | Rights.Write | Rights.Read | Rights.Tell | Rights.Seek | Rights.Advise | Rights.PathOpen | Rights.PathCreateFile,
		Rights.DataSync | Rights.Write | Rights.Read | Rights.Tell | Rights.Seek | Rights.Advise | Rights.PathOpen | Rights.PathCreateFile,
		FDFlags.Sync,
		^fd);

	if err != Errno.Success {
		print("Failed to open file\n");
		print("Error code: ");
		print_u64_with_base(cast(u64) err, 16l);
		proc_exit(1);
	}

	print_u64_with_base(cast(u64) fd, 16l);
	print("\n");

	filelen : Filesize;
	if fd_seek(fd, 0l, Whence.End, ^filelen) != Errno.Success {
		print("Failed to seek in file\n");
		proc_exit(1);
	}
	print("the size is: ");
	print_u64_with_base(cast(u64) filelen, 10l);

	//buf : [128] u8;
	//hello_vec := IOVec.{ buf = cast(^u8) buf, len = 128 };
	//nread : Size;
	//if fd_read(fd, IOVecArray.{ ^hello_vec, 1 }, ^nread) != Errno.Success {
	//	print("Failed to read from file\n");
	//	print("Error code: ");
	//	print_u64_with_base(cast(u64) err, 10l);
	//	proc_exit(1);
	//	return;
	//}
//
	//print(string.{ nread, cast(^u8) buf });

	fd_close(fd);
}