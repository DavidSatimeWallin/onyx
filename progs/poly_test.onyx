package main

#include_folder "./core"

#include_file "builtin"
#include_file "wasi"
#include_file "alloc"
#include_file "intrinsics"
#include_file "random"
#include_file "string"
#include_file "file"

use package builtin
use package core
use package memory
use package wasi
use package intrinsics
use package random
use package file
use package stdio

print_arr_details :: proc (arr: ^[..] $T) {
    print("\nArray details:\n\tSize: ");
    print(arr.count);
    print("\n\tCapacity: ");
    print(arr.capacity);
    print("\n\tData ptr: ");
    print(cast(u32) arr.data, 16);
    print("\n\tSize of elements: ");
    print(sizeof T);
    print("\n\tAlignment of elements: ");
    print(alignof T);
    print("\n\n");
}

// This works on both slices and arrays
print_arr :: proc (arr: $T) {
    for i: 0, arr.count {
        print(arr.data[i]);
        print(" ");
    }

    print("\n");
}

print_vec :: proc #add_overload print (v: Vec3) {
    print("Vec3(");
    print(v.x);
    print(", ");
    print(v.y);
    print(", ");
    print(v.z);
    print(")");
}

// This demonstrates that we have something similar to static 'duck' typing.
get_count :: proc (x: $T) -> u32 do return x.count;


SOA :: struct {
    a  : [..] i32;
    b  : [..] i64;
}

soa_init :: proc (s: ^SOA) {
    array_init(^s.a);
    array_init(^s.b);
}

soa_deinit :: proc (s: ^SOA) {
    array_free(^s.a);
    array_free(^s.b);
}

main :: proc (args: [] cstring) {
    s : SOA;
    soa_init(^s);
    defer soa_deinit(^s);

    print_arr_details(^s.a);
    print_arr_details(^s.b);

    for i: 0, 100 {
        array_push(^s.a, 5 * i);
        array_push(^s.b, 3l * cast(i64) i);
    }

    print_arr(^s.a);
    array_to_slice(^s.a) |> print_arr();
    array_to_slice(^s.b) |> print_arr();

    print("After adding...\n");
    print_arr_details(^s.a);
    print_arr_details(^s.b);
}

main2 :: proc (args: [] cstring) {
    print(cast(u32) __heap_start, 16);

    iarr_backing : [32] i32;
    iarr : [..] i32;
    iarr.data = cast(^i32) iarr_backing;
    iarr.count = 0;
    iarr.capacity = 32;

    print_arr_details(^iarr);

    array_push(^iarr, 1234);

    for i: 0, 12 do array_push(^iarr, i % 5);

    print_arr_details(^iarr);
    print_arr(^iarr);

    array_delete(^iarr, 4);

    print_arr_details(^iarr);
    print_arr(^iarr);

    array_remove(^iarr, 1);
    array_remove(^iarr, 4);

    print_arr_details(^iarr);
    print_arr(^iarr);

    array_insert(^iarr, 2, 5678);

    print_arr_details(^iarr);
    print_arr(^iarr);
    print(array_average(^iarr));
    print("\n");



    barr : [..] i64;
    array_init(^barr, 10);
    defer array_free(^barr);

    for i: 0, 500 {
        array_push(^barr, cast(u64) (3 * i * i + 4 * i - 2));
    }

    print_arr_details(^barr);
    print_arr(^barr);
    array_average(^barr) |> print();
    print("\n");

    print("Does the array contain 2637? ");
    print(array_contains(^barr, 2637l));
    print("\n");



    varr : [..] Vec3;
    array_init(^varr);
    defer array_free(^varr);

    for i: 0, 20 {
        array_push(^varr, Vec3.{
            x = i,
            y = i * i,
            z = i * i * i,
        });
    }

    array_push(^varr, Vec3.{ 4, 2, 3 });

    print_arr_details(^varr);
    print_arr(varr);

    print(get_count(iarr));
    print("\n");
    print(get_count(barr));
    print("\n");
    print(get_count(varr));
    print("\n");
}

Vec3 :: struct {
    x: i32;
    y: i32;
    z: i32;
}
