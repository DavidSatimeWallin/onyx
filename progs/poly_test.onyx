package main

#include_file "core/std/wasi"

use package core

print_arr_details :: proc (arr: ^[..] $T) {
    print("\nArray details:\n\tSize: ");
    print(arr.count);
    print("\n\tCapacity: ");
    print(arr.capacity);
    print("\n\tData ptr: ");
    print(arr.data);
    print("\n\tSize of elements: ");
    print(sizeof T);
    print("\n\tAlignment of elements: ");
    print(alignof T);
    print("\n\n");
}

print_vec :: proc (v: Vec3) #add_overload print {
    print("Vec3(");
    print(v.x);
    print(", ");
    print(v.y);
    print(", ");
    print(v.z);
    print(")");
}

// This demonstrates that we have something similar to static 'duck' typing.
get_count :: proc (x: $T) -> u32 do return x.count;


// Because of the static duck typing, this will pass as an
// array/slice in most places.
Dummy :: struct {
    count : u32 = 5;
    data  : [5] u32;
}


/* This demos some of the power you have with the polymorphic types */
compose :: proc (a: A, f: proc ($A) -> $B, g: proc (B) -> $C) -> C {
    return a |> f() |> g();
}


SOA :: struct {
    a  : [..] i32;
    b  : [..] i64;
    c  : [..] V2;
}

soa_init :: proc (s: ^SOA) {
    array_init(^s.a);
    array_init(^s.b);
    array_init(^s.c);
}

soa_deinit :: proc (s: ^SOA) {
    array_free(^s.a);
    array_free(^s.b);
    array_free(^s.c);
}

get_range :: proc (arr: ^[..] $T) -> range {
    return 0 .. arr.count;
}

print_range :: proc (r: range) #add_overload print {
    print(r.low);
    print(" to ");
    print(r.high);
    print(" by ");
    print(r.step);
    print("\n");
}

// NOTE: This function will be very useful for for loops. i.e.
//        for i: 0 .. 100 |> by(2) {
//            ...
//        }
by :: proc (r: range, s: u32) -> range {
    return range.{ low = r.low, high = r.high, step = s };
}

V2 :: struct { x: i32; y: i32; }
print_v2 :: proc (v: V2) #add_overload print {
    print("V2(");
    print(v.x);
    print(", ");
    print(v.y);
    print(")");
}

main :: proc (args: [] cstring) {
    res := compose(5, proc (x: i32) -> i32 do return x * 3;,
                      proc (x: i32) -> i32 do return x + 5;);
    print(res);
    print("\n");

    s : SOA;
    soa_init(^s);
    defer {
        print("Clearing SOA...\n");
        soa_deinit(^s);
    }

    print("Evens from 6 to 34:\n");
    for i: 6 .. 34 |> by(2) {
        print(i);
        print(" ");
    }
    print("\n");

    print_arr_details(^s.a);
    print_arr_details(^s.b);

    for i: 0 .. 100 {
        array_push(^s.a, (5 * i) % 21);
        array_push(^s.b, 3l * cast(i64) i);
        array_push(^s.c, V2.{ i, i * i });
    }

    r := ^s.a |> get_range() |> by(3);
    print(r);
    print_array(^s.a);

    for vec: s.c {
        print(vec);
        print(" ");
    }
    print("\n");

    for ^vec: s.c {
        print(vec);
        print(" ");
    }
    print("\n");


    array_sort(^s.a, cmp_dec);
    array_sort(^s.b, cmp_dec);

    print_array(^s.a);
    print_array(^s.b);

    print("After adding...\n");
    print_arr_details(^s.a);
    print_arr_details(^s.b);

    print("Array A sum: ");
    print(array_fold(^s.a, 0, proc (x: i32, acc: i32) -> i32 do return x + acc;));
    print("\n\n");

    map : PtrMap;
    ptrmap_init(^map, 50);
    defer ptrmap_free(^map);

    for i: 0 .. 100 do ptrmap_put(^map, ^s.a[i], ^s.b[i]);

    print("Has ^a[20]? ");
    print(ptrmap_has(^map, ^s.a[20]));
    print("\n");

    print("Has null? ");
    print(ptrmap_has(^map, null));
    print("\n");

    print("Value at ^a[50]: ");
    print(ptrmap_get(^map, ^s.a[50]));
    print(" == ");
    print(^s.b[50]);
    print("\n");

    print("Deleteing ^a[20]\n");
    ptrmap_delete(^map, ^s.a[20]);

    print("Has ^a[20]? ");
    print(ptrmap_has(^map, ^s.a[20]));
    print("\n");
}

main2 :: proc (args: [] cstring) {
    print(cast(u32) __heap_start, 16);

    iarr_backing : [32] i32;
    iarr : [..] i32;
    iarr.data = cast(^i32) iarr_backing;
    iarr.count = 0;
    iarr.capacity = 32;

    print_arr_details(^iarr);

    array_push(^iarr, 1234);

    for i: 0 .. 12 do array_push(^iarr, i % 5);

    print_arr_details(^iarr);
    print_array(^iarr);

    array_delete(^iarr, 4);

    print_arr_details(^iarr);
    print_array(^iarr);

    array_remove(^iarr, 1);
    array_remove(^iarr, 4);

    print_arr_details(^iarr);
    print_array(^iarr);

    array_insert(^iarr, 2, 5678);

    print_arr_details(^iarr);
    print_array(^iarr);
    print(array_average(^iarr));
    print("\n");



    barr : [..] i64;
    array_init(^barr, 10);
    defer array_free(^barr);

    for i: 0 .. 500 {
        array_push(^barr, cast(u64) (3 * i * i + 4 * i - 2));
    }

    print_arr_details(^barr);
    print_array(^barr);
    array_average(^barr) |> print();
    print("\n");

    print("Does the array contain 2637? ");
    print(array_contains(^barr, 2637l));
    print("\n");



    varr : [..] Vec3;
    array_init(^varr);
    defer array_free(^varr);

    for i: 0 .. 20 {
        array_push(^varr, Vec3.{
            x = i,
            y = i * i,
            z = i * i * i,
        });
    }

    array_push(^varr, Vec3.{ 4, 2, 3 });
    array_sort(^varr, cmp_vec3);

    print_arr_details(^varr);
    print_array(varr, "\n");


    dummy := cast(^Dummy) calloc(sizeof Dummy);
    defer cfree(dummy);
    dummy.count = 5;
    for i: 0 .. dummy.count do dummy.data[i] = i * 5;

    print_array(dummy);

    print(get_count(iarr));
    print("\n");
    print(get_count(barr));
    print("\n");
    print(get_count(varr));
    print("\n");
    print(get_count(dummy));
    print("\n");
}

Vec3 :: struct {
    x: i32;
    y: i32;
    z: i32;
}

cmp_vec3 :: proc (v1: Vec3, v2: Vec3) -> i32 {
    if v1.x != v2.x do return v1.x - v2.x;
    if v1.y != v2.y do return v1.y - v2.y;
    return v1.z - v2.z;
}
