package main

#include_file "core/std/wasi"

use package builtin
use package core

print_arr_details :: proc (arr: ^[..] $T) {
    print("\nArray details:\n\tSize: ");
    print(arr.count);
    print("\n\tCapacity: ");
    print(arr.capacity);
    print("\n\tData ptr: ");
    print(arr.data);
    print("\n\tSize of elements: ");
    print(sizeof T);
    print("\n\tAlignment of elements: ");
    print(alignof T);
    print("\n\n");
}

print_vec :: proc (v: Vec3) #add_overload print {
    print("Vec3(");
    print(v.x);
    print(", ");
    print(v.y);
    print(", ");
    print(v.z);
    print(")");
}

// This demonstrates that we have something similar to static 'duck' typing.
get_count :: proc (x: $T) -> u32 do return x.count;


// Because of the static duck typing, this will pass as an
// array/slice in most places.
Dummy :: struct {
    count : u32 = 5;
    data  : ^u32;
}


/* TODO: Make this work at some point
   compose :: proc (a: $A, f: proc (A) -> $B, g: proc (B) -> $C) -> C {
      return a |> f() |> g();
   }
*/



SOA :: struct {
    b  : [..] i64;
    a  : [..] i32;
}

soa_init :: proc (s: ^SOA) {
    array_init(^s.a);
    array_init(^s.b);
}

soa_deinit :: proc (s: ^SOA) {
    array_free(^s.a);
    array_free(^s.b);
}

main2 :: proc (args: [] cstring) {
    s : SOA;
    soa_init(^s);
    defer soa_deinit(^s);

    print_arr_details(^s.a);
    print_arr_details(^s.b);

    for i: 0, 100 {
        array_push(^s.a, 5 * i);
        array_push(^s.b, 3l * cast(i64) i);
    }

    array_sort(^s.a, cmp_dec);
    array_sort(^s.b, cmp_asc);

    print_array(^s.a);
    print_array(^s.b);

    print("After adding...\n");
    print_arr_details(^s.a);
    print_arr_details(^s.b);
}

main :: proc (args: [] cstring) {
    print(cast(u32) __heap_start, 16);

    iarr_backing : [32] i32;
    iarr : [..] i32;
    iarr.data = cast(^i32) iarr_backing;
    iarr.count = 0;
    iarr.capacity = 32;

    print_arr_details(^iarr);

    array_push(^iarr, 1234);

    for i: 0, 12 do array_push(^iarr, i % 5);

    print_arr_details(^iarr);
    print_array(^iarr);

    array_delete(^iarr, 4);

    print_arr_details(^iarr);
    print_array(^iarr);

    array_remove(^iarr, 1);
    array_remove(^iarr, 4);

    print_arr_details(^iarr);
    print_array(^iarr);

    array_insert(^iarr, 2, 5678);

    print_arr_details(^iarr);
    print_array(^iarr);
    print(array_average(^iarr));
    print("\n");



    barr : [..] i64;
    array_init(^barr, 10);
    defer array_free(^barr);

    for i: 0, 500 {
        array_push(^barr, cast(u64) (3 * i * i + 4 * i - 2));
    }

    print_arr_details(^barr);
    print_array(^barr);
    array_average(^barr) |> print();
    print("\n");

    print("Does the array contain 2637? ");
    print(array_contains(^barr, 2637l));
    print("\n");



    varr : [..] Vec3;
    array_init(^varr);
    defer array_free(^varr);

    for i: 0, 20 {
        array_push(^varr, Vec3.{
            x = i,
            y = i * i,
            z = i * i * i,
        });
    }

    array_push(^varr, Vec3.{ 4, 2, 3 });
    array_sort(^varr, cmp_vec3);

    print_arr_details(^varr);
    print_array(varr, "\n");


    dummy := Dummy.{ data = calloc(sizeof [5] i32) };
    for i: 0, dummy.count do dummy.data[i] = i * 5;

    print_array(dummy);

    print(get_count(iarr));
    print("\n");
    print(get_count(barr));
    print("\n");
    print(get_count(varr));
    print("\n");
    print(get_count(dummy));
    print("\n");
}

Vec3 :: struct {
    x: i32;
    y: i32;
    z: i32;
}

cmp_vec3 :: proc (v1: Vec3, v2: Vec3) -> i32 {
    if v1.x != v2.x do return v1.x - v2.x;
    if v1.y != v2.y do return v1.y - v2.y;
    return v1.z - v2.z;
}