#include_file "core/std/wasi"
#include_file "progs/foo_test"

use package core

Foo :: struct {
    data1 : i32;
    data2 : f32;
}

Bar :: struct {
    use foo : Foo;
    bar_data : str;
    // bar_data2 : cstring;
}

// BUG: This should cause some kind of error since this should be
// infinite in size, but it doesn't so... fix that.
//                                      - brendanfh   2020/09/08
// Link :: struct {
//     data : i32;
//     next : Link;
// }


// bar : Bar;
// bar.data1 = 123;
// bar.data2 = 524782.1f;

// asdf :: proc (f: Foo) -> ...
// asdf(bar.foo);

print_foo :: proc (f: ^Foo) {
    print("Foo: \n");
    print(f.data1);
    print("\n");
    print(cast(i32) f.data2);
    print("\n");
}

print_bar :: proc (bar: ^Bar) {
    print(bar.data1);
    print("\n");
    print(cast(i32) bar.data2);
    print("\n");
    print(bar.bar_data);
    print("\n");
}

make_bar :: proc () -> Bar {
    bar : Bar;
    bar.data1 = 1234;
    bar.data2 = 12.34f;
    bar.bar_data = "This is a test";

    return bar;
}

main :: proc (args: [] cstr) {
    use package test { foo as foo_pkg }
    use package test as test
    use test.foo.SomeEnum

    printf("Val2: %i\n", cast(i32) Val2);
    printf("Val3: %i\n", cast(i32) Val3);

    foo_pkg.print_foo();
    foo := test.foo.TestFoo.{ a = 1234 };
    printf("foo.a: %i\n", foo.a);

    bar := make_bar();

    print(sizeof Bar);
    print("\n");
    print_bar(^bar);
    print_foo(^bar.foo);
    print(bar.foo.data1);
    print("\n");

    program := "+ + * s - /";
    accumulator := 0;

    for token: program {
        switch token {
            case #char "+" do accumulator += 1;
            case #char "-" do accumulator -= 1;
            case #char "*" do accumulator *= 2;
            case #char "/" do accumulator /= 2;
            case #char "s" do accumulator *= accumulator;
            case #default ---
        }
    }

    printf("The program \"%s\" calculates the value %i\n", program, accumulator);
}
