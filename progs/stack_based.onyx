package main

#include_folder "./core"

#include_file "printing"
#include_file "alloc"

use package printing
use package memory

sort :: proc (arr: [N]i32, cmp: proc (i32, i32) -> i32) {
    for i: 0, N {
        smallest_idx := i;

        for j: i, N do if cmp(arr[j], arr[smallest_idx]) < 0 do smallest_idx = j;

        tmp :: arr[i];
        arr[i] = arr[smallest_idx];
        arr[smallest_idx] = tmp;
    }
}

ret_val :: proc (x: i32, y: i32) -> i32 {
    big_arr : [128] i32;
    big_arr[0] = 1234;
    big_arr[1] = 1234;
    big_arr[127] = 1234;
    return big_arr[127] + x + y;
}

N :: 10

sumN :: proc (x: [N] i32) -> i32 {
    s := 0;
    for i: 0, N do s += x[i];
    return s;
}

summing :: proc (x: ^i32) -> i32 {
    s := 0;
    for i: 0, N do s += x[i];
    return s;
}

Vec3 :: struct {
    x: i32;
    y: i32;
    z: i32;
}

mag_squared :: proc (v: Vec3) -> i32 {
    return v.x * v.x + v.y * v.y + v.z * v.z;
}

vec_add :: proc (v: Vec3, u: Vec3, use out: ^Vec3) {
    x = v.x + u.x;
    y = v.y + u.y;
    z = v.z + u.z;
}

some_value := 20 + 30 * 4 + 15 / 5;

start :: proc #export {
    heap_init();

    print("Hello, World!");
    print_hex(cast(u64) some_value);
    print("Hello, World!");
    print_ptr(__heap_start);
    print_ptr(__stack_base);
    print_ptr(__stack_top);
    print_bin(42l);
    print_hex(42l);

    print(cast(u32) (#char "a" + #char "0"));

    for i: #char "a", #char "f" do print_hex(cast(u64) i);

    a := 12345;

    arr: [N][N] i32;
    arr[1][0] = 10;
    arr[1][1] = 20;
    arr[1][2] = 30;
    arr[1][3] = 40;
    arr[1][4] = 50;
    arr[1][9] = 123;
    print(arr[1] 'sumN());
    print(summing(cast(^i32) arr[1]));

    v1: Vec3;
    v1.x = 2;
    v1.y = 4;
    v1.z = 10;

    v2: Vec3;
    v2.x = 4;
    v2.y = 2;
    v2.z = 1;

    v3: Vec3;
    vec_add(v1, v2, ^v3);
    print(v3.x);
    print(v3.y);
    print(v3.z);

    print(v3'mag_squared());

    print(10'ret_val(4));
    
    for i: 0, N do print(arr[1][i]);

    soa: struct { x: [5] i32; y: [5] i32; };
    for i: 0, 5 {
        soa.x[i] = i;
        soa.y[i] = i * i;
    }
    print(soa.y[3]);
    print_ptr(^soa.y[3]);

    fancy : [5 + 3 * 4] i32;
    fancy[2] = 123;
    print(fancy[2]);


    something : [N] i32;
    for i: 0, N do something[i] = N - i;
    for i: 0, N do print(something[i]);

    something'sort(proc (a: i32, b: i32) -> i32 { return a - b; });

    for i: 0, N do print(something[i]);
}