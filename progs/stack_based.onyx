package main

#include_folder "/usr/share/onyx/core"

#include_file "printing"
#include_file "alloc"
#include_file "string"

use package printing
use package memory
use package core

sort :: proc (arr: [N]i32, cmp: proc (i32, i32) -> i32) -> [N] i32 {
    for i: 0, N {
        smallest_idx := i;

        for j: i, N do if cmp(arr[j], arr[smallest_idx]) < 0 do smallest_idx = j;

        tmp :: arr[i];
        arr[i] = arr[smallest_idx];
        arr[smallest_idx] = tmp;
    }

    return arr;
}

ret_val :: proc (x: i32, y: i32) -> i32 {
    big_arr : [128] i32;
    big_arr[0] = 1234;
    big_arr[1] = 1234;
    big_arr[127] = 1234;
    return big_arr[127] + x + y;
}

N :: 10

sumN :: proc (x: [N] i32) -> i32 {
    s := 0;
    for i: 0, N do s += x[i];
    return s;
}

summing :: proc (x: ^i32) -> i32 {
    s := 0;
    for i: 0, N do s += x[i];
    return s;
}

get_value :: proc (x: i32, y: i32) -> i32 {
    return x + 2 * y;
}

Vec3 :: struct {
    x: i32 = get_value(10, 20);
    y: i32 = 0;
    z: i32 = 0;
}

mag_squared :: proc (use v: Vec3) -> i32 {
    return x * x + y * y + z * z;
}

clamp :: proc (v: i32, lo: i32, hi: i32) -> i32 {
    if v < lo do return lo;
    if v > hi do return hi;
    return v;
}

// NOTE: Anonymous functions do NOT have closure,
// so in either of these function scopes, the
// parameter 'n' is not accessible.
//
// This is intended behavior since creating new
// procs at runtime is very difficult with WASM
stupid_idea :: proc (n: i32) -> proc (i32) -> i32 {
    if n == 1234 {
        return proc (a: i32) -> i32 { return 5678 + a; };
    }

    return proc (a: i32) -> i32 { return -1 + a; };
}

some_value := 20 + 30 * 4 + 15 / 5;

start :: proc #export {
    memory_init();

    print("Hello, World!");
    print_hex(cast(u64) some_value);
    print("Hello, World!");
    print_bin(42l);
    print_hex(42l);

    print(cast(u32) (#char "a" + #char "0"));

    for i: #char "a", #char "f" do print_hex(cast(u64) i);

    a := 12345;

    arr: [N][N] i32;
    arr[1][0] = 10;
    arr[1][1] = 20;
    arr[1][2] = 30;
    arr[1][3] = 40;
    arr[1][4] = 50;
    arr[1][9] = 123;
    print(arr[1]|>sumN());
    print(summing(cast(^i32) arr[1]));

    print(10 |> ret_val(4));
    print(11 |> ret_val(5));

    for i: 0, N do print(arr[1][i]);

    soa: struct { x: [5] i32; y: [5] i32; };
    for i: 0, 5 {
        soa.x[i] = i;
        soa.y[i] = i * i;
    }
    print(soa.y[3]);
    print_ptr(^soa.y[3]);

    fancy : [5 + 3 * 4] i32;
    fancy[2] = 123;
    print(fancy[2]);


    something : [N] i32;
    for i: 0, N do something[i] = N - i;
    for i: 0, N do print(something[i]);

    something
            |> sort(proc (a: i32, b: i32) -> i32 { return a - b; })
            |> sumN()
            |> clamp(30, 100)
            |> print();

    for i: 0, N do
        something[i]
            |> clamp(3, 6)
            |> print();

    stupid_idea(1234)(1234) |> print();

    varr : [5] Vec3;
    varr[2] = Vec3.{4, 5, 6};

    mag_squared(varr[2]) |> print();

    v1 := Vec3.{};
    v2 := vmul(vadd(v1, Vec3.{ 1, 2, 3 }), 3);

    print(v2.x);
    print(v2.y);
    print(v2.z);

    un : UnionTest;
    un.f = 1.25f;
    print_hex(cast(u64) un.i);

    s1 :: string_make("Hello, ");
    s2 :: string_make("World!");
    s3 :: string_concat(heap_allocator, s1, s2);
    defer string_free(heap_allocator, s3);
    string_print(s3);
}

vadd :: proc (v1: Vec3, v2: Vec3) -> Vec3 {
    return Vec3.{
        v1.x + v2.x,
        v1.y + v2.y,
        v1.z + v2.z,
    };
}

vmul :: proc (use v: Vec3, s: i32) -> Vec3 {
    return Vec3.{ x * s, y * s, z * s };
}

UnionTest :: struct #union {
    i : i32;
    f : f32;
}
