package main

use "progs/print_funcs"
use "progs/alloc"

use package printing
use package memory

ret_val :: proc (x: i32, y: i32) -> i32 {
    big_arr : [128] i32;
    big_arr[0] = 1234;
    big_arr[1] = 1234;
    big_arr[127] = 1234;
    return big_arr[127] + x + y;
}

N :: 10

sumN :: proc (x: [N] i32) -> i32 {
    s := 0;
    for i: 0, N do s += x[i];
    return s;
}

summing :: proc (x: ^i32) -> i32 {
    s := 0;
    for i: 0, N do s += x[i];
    return s;
}

Vec3 :: struct {
    x: i32;
    y: i32;
    z: i32;
}

mag_squared :: proc (v: Vec3) -> i32 {
    return v.x * v.x + v.y * v.y + v.z * v.z;
}

vec_add :: proc (v: Vec3, u: Vec3, use out: ^Vec3) {
    x = v.x + u.x;
    y = v.y + u.y;
    z = v.z + u.z;
}

start :: proc #export {
    heap_init();
    print("Hello, World!");
    print_ptr(__heap_start);
    print_ptr(__stack_base);
    print_ptr(__stack_top);
    print_bin(42l);
    print_hex(42l);

    print_hex(cast(u64) #char "a");

    a := 12345;

    arr: [N][N] i32;
    arr[1][0] = 10;
    arr[1][1] = 20;
    arr[1][2] = 30;
    arr[1][3] = 40;
    arr[1][4] = 50;
    arr[1][9] = 123;
    print(sumN(arr[1]));
    print(summing(cast(^i32) arr[1]));

    v1: Vec3;
    v1.x = 2;
    v1.y = 4;
    v1.z = 10;

    v2: Vec3;
    v2.x = 4;
    v2.y = 2;
    v2.z = 1;

    v3: Vec3;
    vec_add(v1, v2, ^v3);
    print(v3.x);
    print(v3.y);
    print(v3.z);
    print(mag_squared(v3));

    print(ret_val(10, 4));
    
    for i: 0, N do print(arr[1][i]);

    soa: struct { x: [5] i32; y: [5] i32; };
    for i: 0, 5 {
        soa.x[i] = i;
        soa.y[i] = i * i;
    }
    print(soa.y[3]);
    print_ptr(^soa.y[3]);
}