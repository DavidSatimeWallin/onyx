package main

#include_folder "./core"

#include_file "printing"
#include_file "alloc"

use package printing
use package memory

sort :: proc (arr: [N]i32, cmp: proc (i32, i32) -> i32) -> [N] i32 {
    for i: 0, N {
        smallest_idx := i;

        for j: i, N do if cmp(arr[j], arr[smallest_idx]) < 0 do smallest_idx = j;

        tmp :: arr[i];
        arr[i] = arr[smallest_idx];
        arr[smallest_idx] = tmp;
    }

    return arr;
}

ret_val :: proc (x: i32, y: i32) -> i32 {
    big_arr : [128] i32;
    big_arr[0] = 1234;
    big_arr[1] = 1234;
    big_arr[127] = 1234;
    return big_arr[127] + x + y;
}

N :: 10

sumN :: proc (x: [N] i32) -> i32 {
    s := 0;
    for i: 0, N do s += x[i];
    return s;
}

summing :: proc (x: ^i32) -> i32 {
    s := 0;
    for i: 0, N do s += x[i];
    return s;
}

Vec3 :: struct {
    x: i32;
    y: i32;
    z: i32;
}

mag_squared :: proc (v: Vec3) -> i32 {
    return v.x * v.x + v.y * v.y + v.z * v.z;
}

vec_add :: proc (v: Vec3, u: Vec3, use out: ^Vec3) {
    x = v.x + u.x;
    y = v.y + u.y;
    z = v.z + u.z;
}

clamp :: proc (v: i32, lo: i32, hi: i32) -> i32 {
    if v < lo do return lo;
    if v > hi do return hi;
    return v;
}

// NOTE: Anonymous functions do NOT have closure,
// so in either of these function scopes, the
// parameter 'n' is not accessible.
//
// This is intended behavior since creating new
// procs at runtime is very difficult with WASM
stupid_idea :: proc (n: i32) -> proc () -> i32 {
    if n == 1234 {
        return proc -> i32 { return 5678; };
    }

    return proc -> i32 { return -1; };
}

some_value := 20 + 30 * 4 + 15 / 5;

start :: proc #export {
    heap_init();

    print("Hello, World!");
    print_hex(cast(u64) some_value);
    print("Hello, World!");
    print_bin(42l);
    print_hex(42l);

    print(cast(u32) (#char "a" + #char "0"));

    for i: #char "a", #char "f" do print_hex(cast(u64) i);

    a := 12345;

    arr: [N][N] i32;
    arr[1][0] = 10;
    arr[1][1] = 20;
    arr[1][2] = 30;
    arr[1][3] = 40;
    arr[1][4] = 50;
    arr[1][9] = 123;
    print(arr[1]|>sumN());
    print(summing(cast(^i32) arr[1]));

    print(10 |> ret_val(4));
    print(11 |> ret_val(5));
    
    for i: 0, N do print(arr[1][i]);

    soa: struct { x: [5] i32; y: [5] i32; };
    for i: 0, 5 {
        soa.x[i] = i;
        soa.y[i] = i * i;
    }
    print(soa.y[3]);
    print_ptr(^soa.y[3]);

    fancy : [5 + 3 * 4] i32;
    fancy[2] = 123;
    print(fancy[2]);


    something : [N] i32;
    for i: 0, N do something[i] = N - i;
    for i: 0, N do print(something[i]);

    val := something
            |> sort(proc (a: i32, b: i32) -> i32 { return a - b; })
            |> sumN()
            |> clamp(30, 100);
    print(val);

    for i: 0, N do
        something[i]
            |> clamp(3, 6)
            |> print();

    stupid_idea(1234)() |> print();

    varr : [5] Vec3;
    varr[2].x = 4;
    varr[2].y = 5;
    varr[2].z = 6;
    mag_squared(varr[2]) |> print();

    v1 : Vec3;
    v1.x = 1;
    v1.y = 2;
    v1.z = 4;

    v2 := ^v1;

    v3 : Vec3;
    vec_add(v1, *v2, ^v3);
    print(v3.x);
    print(v3.y);
    print(v3.z);
}