package alloc

use "progs/intrinsics"

use package printing { print }

use package intrinsics {
    memory_size, memory_grow
}

// Need to define this somewhere
null :: cast(rawptr) 0;

heap_state : struct {
    free_list       : ^heap_block;
    next_alloc      : rawptr;
    remaining_space : u32;
}

heap_block :: struct {
    size : i32;
    next : ^heap_block;
}

heap_init :: proc {
    heap_state.free_list = null;
    heap_state.next_alloc = __heap_start;
    heap_state.remaining_space = (memory_size() << 16) - cast(u32) __heap_start;
}

heap_align_to :: 16

heap_alloc :: proc (size_: i32) -> rawptr {
    if size_ == 0 return null;

    size := size_ + sizeof heap_block;
    if size % heap_align_to != 0 {
        size += heap_align_to - (size % heap_align_to);
    }

    prev := ^heap_state.free_list;
    hb := heap_state.free_list;
    while hb != null {
        if hb.size >= size {
            *prev = hb.next;
            hb.next = null;

            return cast(rawptr) (cast(u32) hb + sizeof heap_block);
        }

        prev = ^hb.next;
        hb = hb.next;
    }

    if size < heap_state.remaining_space {
        ret := cast(^heap_block) heap_state.next_alloc;
        ret.size = size;
        ret.next = null;

        heap_state.next_alloc = cast(rawptr) (cast(u32) heap_state.next_alloc + size);
        heap_state.remaining_space -= size;

        return cast(rawptr) (cast(u32) ret + sizeof heap_block);
    }
    
    // grow the memory with memory_grow
    return cast(rawptr) -1;
}

heap_free :: proc (ptr: rawptr) {
    hb_ptr := cast(^heap_block) (cast(u32) ptr - sizeof heap_block);
    hb_ptr.next = heap_state.free_list;
    heap_state.free_list = hb_ptr;
}