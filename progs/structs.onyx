use "progs/print_funcs"
use "progs/intrinsics"

N :: 5

Foo :: struct {
    v   : Vec3;
    i   : i32;
    l   : i64;
    f   : f32;
    d   : f64;
    foo : ^Foo;
}

alloc :: proc (size: u32) -> rawptr {
    heap_u32    :: __heap_start as ^u32;

    curr_offset := *heap_u32;
    if curr_offset == 0 curr_offset = 8;

    *heap_u32   = curr_offset + size;

    return ((__heap_start as u32) + curr_offset) as rawptr;
}

foo_make :: proc -> ^Foo {
    return alloc(sizeof Foo) as ^Foo; 
}

foo_get :: proc (fooarr: []Foo, i: i32) -> ^Foo {
    return ^fooarr[i];
}

Mut1 :: struct {
    bar : i32;
    other : Mut2;
}

Mut2 :: struct {
    foo : i32;
    other : ^Mut1;
}

mut_func :: proc #export (mut: ^Mut1) -> ^Mut1 {
    return mut.other.other;
}


Link :: struct {
    data : i32;
    next : ^Link;
}

link_create :: proc (data: i32, parent: ^^Link) {
    link := alloc(sizeof Link) as ^Link;
    link.data = data;
    link.next = *parent;
    *parent = link;
}

link_print :: proc (start: ^Link) -> i32 {
    count := 0;

    walker := start;
    while (walker as i32) != 0 {
        print(walker.data);
        walker = walker.next;
        count += 1;
    }

    return count;
}

link_test :: proc #export "main4" {
    node_head := alloc(sizeof ^Link) as ^^Link;
    *node_head = 0 as ^Link;

    link_create(0, node_head);
    link_create(1, node_head);
    link_create(2, node_head);
    link_create(3, node_head);
    link_create(4, node_head);

    link_print(*node_head);
}



// TODO: Make everything below this comment work
multi_arr :: proc #export "main2" {
    arr1 := alloc(sizeof [5][5] i32) as [5][5] i32; // Sizeof 25 * 4
    arr2 := alloc(sizeof [5]^ i32) as [5]^ i32; // Sizeof 20

    arr2[3][2] = 5; // (arr1 + (3 * 5 * 4) + (2 * 4))
    print(arr2[3][2]);
    // arr2[3][2] = 5; // (arr1[3] + 2 * 4)
}
                
Vec2 :: struct {
    x : i32;
    y : i32;
}

Vec3 :: struct {
    x : i32;
    y : i32;
    z : i32;
}

v2magnitude :: proc (v: ^Vec2) -> f32 {
    return sqrt_f32((v.x * v.x + v.y * v.y) as f32);
}

v3magnitude :: proc (v: ^Vec3) -> f32 {
    return sqrt_f32((v.x * v.x + v.y * v.y + v.z * v.z) as f32);
}

magnitude :: proc #overloaded { v2magnitude, v3magnitude };

minus :: proc (n: i32, k: i32) -> i32 {
    return n - k;
}

Fool :: struct {
    bar : ^Bar;
}

Bar :: struct {
    i: i32;
    j: i64;
}

print_bar :: proc (bar: Bar) {
    print(bar.i);
    print(bar.j);
}

proc #export "main" {
    v2 := alloc(sizeof Vec2) as ^Vec2;
    v2.x = 5;
    v2.y = 12;
    print(v2.magnitude());

    v3 := alloc(sizeof Vec3) as ^Vec3;
    v3.x = 1;
    v3.y = 1;
    v3.z = 1;
    print(v3.magnitude());

    (*v2).vec2_splat(*v3);

    print((1).minus(2));

    foo := alloc(sizeof Fool) as ^Fool;
    foo.bar = alloc(sizeof Bar) as ^Bar;
    foo.bar.i = 50;
    foo.bar.j = 70 as i64;

    (*foo.bar).print_bar();
}

SOA :: struct {
    positions  : [10] Vec2;
    velocities : [10] Vec2;
    things     : [10] ^Vec2;
}

vec2_set :: proc (v: ^Vec2) {
    v.x = 1234;
    v.y = 5678;
}

vec2_splat :: proc (v: Vec2, other: Vec3) {
    print(other.x);
    print(other.y);
    print(other.z);

    print(v.x);
    print(v.y);
}

soa_test :: proc #export "main9" {

    // print(sizeof SOA);  // 240

    soa := alloc(sizeof SOA + 20 * sizeof Vec2) as ^SOA;

    for i: 0, 10 {
        soa.things[i] = alloc(sizeof Vec2) as ^Vec2;
    }

    soa.velocities[2].x = 10;
    soa.velocities[2].y = 12;
    soa.positions[5].x = 1;
    soa.positions[5].y = 2;
    soa.positions[2].x = 1001;
    (^(soa.positions[6])).vec2_set();
    vec2_set(soa.things[2]);

    print((^(soa.positions[6])).v2magnitude());

    print(soa.positions[5].y);
    print(soa.velocities[2].x);
    print(soa.things[2].x);
    print(soa.things[2].y);
    print(soa.positions[6].x);
    print(soa.positions[6].y);

    m_arr := alloc(sizeof [5][5]i32) as [5][5]i32;

    for y: 0, 5 {
        for x: 0, 5 {
            m_arr[y][x] = x + y * 5;
        }
    }

    for i: 0, 25 print((m_arr as [] i32)[i]);
}