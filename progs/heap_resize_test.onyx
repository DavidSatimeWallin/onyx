#include_folder "./core"

#include_file "printing"
#include_file "alloc"

use package memory
use package printing

Vec2 :: struct {
    x : i32;
    y : i32; 
}

other :: proc (use v: ^Vec2) -> i32 {
    o : Vec2;
    o.x = -100;
    o.y = -10;

    return x * o.x + y * o.y;
}

proc #export "start" {
    heap_init();

    v : Vec2;
    v.x = 10;
    v.y = 100;

    other(^v) |> print();
}

// proc #export "start2" {
//     heap_init();
// 
//     print("Creating initial memories");
//     arr1 := cast(^u32) malloc(sizeof [10] u32);
//     print_hex(cast(u64) arr1);
// 
//     arr2 := cast(^u32) malloc(sizeof [40] u32);
//     print_hex(cast(u64) arr2);
// 
//     print("Freeing arr1");
//     mfree(arr1);
// 
//     print("Resizing arr2 (shouldn't change location)");
//     arr2 = cast(^u32) mresize(arr2, sizeof [60] u32);
//     print_hex(cast(u64) arr2);
// 
//     print("Allocating arr3 (should be bigger than arr2)");
//     arr3 := cast(^u32) malloc(sizeof [30] u32);
//     print_hex(cast(u64) arr3);
// 
//     print("Allocating arr1 (should be in the same place as before)");
//     arr1 = cast(^u32) malloc(sizeof [5] u32);
//     print_hex(cast(u64) arr1);
//     for i: 0, 5 do arr1[i] = i;
// 
//     print("Resizing arr1 (should be in the same place as before)");
//     arr1 = cast(^u32) mresize(arr1, sizeof[10] u32);
//     print_hex(cast(u64) arr1);
// 
//     print("Resizing arr1 (should have moved to after arr3)");
//     arr1 = cast(^u32) mresize(arr1, sizeof[100] u32);
//     print_hex(cast(u64) arr1);
// 
//     print("Testing if the data was copied.");
//     for i: 0, 5 do print(arr1[i]);
// }// 