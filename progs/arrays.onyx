use "progs/intrinsics"
use "progs/print_funcs"

global_arr :: global ^i32;

min_i32 :: proc (a: i32, b: i32) -> i32 {
    least := a;
    if b < a least = b;
    return least;
}

min_i64 :: proc (a: i64, b: i64) -> i64 {
    least := a;
    if b < a least = b;
    return least;
}

min :: proc #overloaded {
    min_i32, min_i64, min_f32, min_f64
}

// NOTE: in-place insertion sort
sort :: proc (src: ^i32, len: i32) {
    for i: 0, len {
        smallest := i;

        for j: i + 1, len
            if src[j] < src[smallest] smallest = j;

        tmp :: src[smallest];
        src[smallest] = src[i];
        src[i] = tmp;
    }
}

for_test :: proc {
    // 0 to 9
    for i: 0, 10 print(i);
}

str_test :: proc #export {
    hello_str :: "Hello World! 123";

    // Address of and dereference cancel each other out
    print(^*hello_str);

    print(hello_str, 5);

    for i: 0, 10, 2 print(i);

    for y: 0, 5 for x: 0, 5 print(x + y * 5);
}

// Don't need to bind this function to a symbol
proc #export "main2" {
    print(__heap_start as i32);

    len :: 10;
    global_arr = alloc((len * 4) as u32) as ^i32;
    other_arr := alloc((len * 4) as u32) as ^i32;

    print(global_arr as i32);
    print(other_arr as i32);

    for i: 0, len global_arr[i] = (len - i) * 10;

    print(global_arr, len);

    sort(global_arr, len);

    print(1234567);
    print(global_arr, len);
}












alloc :: proc (size: u32) -> rawptr {
    heap_u32    :: __heap_start as ^u32;

    curr_offset := *heap_u32;
    if curr_offset == 0 curr_offset = 8;

    *heap_u32   = curr_offset + size;

    return ((__heap_start as u32) + curr_offset) as rawptr;
}

alloc_2darr :: proc (rows: u32, cols: u32) -> ^^i32 {
    arr := alloc(rows * 4) as ^^i32;
    for i: 0, cols arr[i] = alloc(cols * 4) as ^i32;
    return arr;
}

multi_arr_test :: proc #export "main" {
    arrs := alloc_2darr(10, 10);

    for y: 0, 10 for x: 0, 10 arrs[y][x] = x + y * 10;
    for y: 0, 10 for x: 0, 10 print(arrs[x][y]);
}
