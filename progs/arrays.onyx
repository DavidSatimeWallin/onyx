use "progs/intrinsics"
use "progs/print_funcs"

global_arr :: global ^i32;

min_i32 :: proc (a: i32, b: i32) -> i32 {
    least := a;
    if b < a least = b;
    return least;
}

min_i64 :: proc (a: i64, b: i64) -> i64 {
    least := a;
    if b < a least = b;
    return least;
}

min :: proc #overloaded {
    min_i32, min_i64, min_f32, min_f64
}

// NOTE: in-place insertion sort
sort :: proc (src: ^i32, len: i32) {
    for i: 0, len {
        smallest := i;

        for j: i + 1, len
            if src[j] < src[smallest] smallest = j;

        tmp :: src[smallest];
        src[smallest] = src[i];
        src[i] = tmp;
    }
}

for_test :: proc {
    // 0 to 9
    for i: 0, 10 print(i);
}

str_test :: proc #export {
    hello_str :: "Hello World! 123";

    // Address of and dereference cancel each other out
    print(^*hello_str);

    print(hello_str, 5);

    for i: 0, 10, 2 print(i);

    for y: 0, 5 for x: 0, 5 print(x + y * 5);
}

// Don't need to bind this function to a symbol
proc #export "main" {
    print(__heap_start as i32);

    global_arr = __heap_start as ^i32;
    len :: 10;

    for i: 0, len global_arr[i] = (len - i) * 10;

    print(global_arr, len);

    sort(global_arr, len);

    print(1234567);
    print(global_arr, len);
}
