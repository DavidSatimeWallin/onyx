
// Foreign functions are included this way:
//      sym_name :: foreign "module" "name" proc ...

// TODO: Make this work
// use "progs/other";

print_i32 :: foreign "host" "print" proc (value i32) ---
print_f32 :: foreign "host" "print" proc (value f32) ---
print_i64 :: foreign "host" "print" proc (value i64) ---
print_f64 :: foreign "host" "print" proc (value f64) ---

something_else :: proc (n i32) -> i32 {
    return 100 * n;
}

// symbol :: proc {}            Global function
// symbol :: struct { x i32, y i32 }
// symbol :: foreign "" "" proc Global foreign function
// symbol :: foreign "" "" i32  Global foreign mutable i32
// symbol :: 5                  Global constant value
// symbol := 5                  Global mutable variable
// symbol : i32                 Global mutable i32 (defaults to 0 initial value)

global_value := 5 + 6;

// This is the entry point
export main :: proc {
    i := 0;
    while i < 10 {
        res :: fib(i);
        print_i32(res);
        i = i + 1;
    }

    i = 0;
    while i < 10 {
        res :: factorial(i);
        print_i32(res);
        i = i + 1;
    }

    x : i32;
    y := 0;
    while y < 5 {

        x = 0;
        while x < 5 {
            if x == 3 {
                x = x + 1;
                continue;
            }

            print_i32((x + y * 5) % 10);
            x = x + 1;
        }

        if y > 2 { break; }

        y = y + 1;
    }
}

export main2 :: proc {
    big_num := fib(factorial(4));
    something :: other_value(3);

    condition := big_num < something;

    if condition {
        print_i32(big_num);
        print_i32(something);
    }
}
