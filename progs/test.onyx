use "progs/print_funcs"
use "progs/other"

something_else :: proc (n: i32) -> i32 {
    return 100 * n + global_value;
}

global_value := 100

export in_unit_circle :: proc (x: f32, y: f32) -> bool {
    return (x * x) + (y * y) < 1.0f;
}

memory_size  :: proc #intrinsic -> i32 ---
memory_grow  :: proc #intrinsic -> i32 ---

clz_i32      :: proc #intrinsic (val: i32) -> i32 ---
ctz_i32      :: proc #intrinsic (val: i32) -> i32 ---
popcnt_i32   :: proc #intrinsic (val: i32) -> i32 ---
and_i32      :: proc #intrinsic (val: i32) -> i32 ---
or_i32       :: proc #intrinsic (val: i32) -> i32 ---
xor_i32      :: proc #intrinsic (val: i32) -> i32 ---
shl_i32      :: proc #intrinsic (val: i32) -> i32 ---
slr_i32      :: proc #intrinsic (val: i32) -> i32 ---
sar_i32      :: proc #intrinsic (val: i32) -> i32 ---
rotl_i32     :: proc #intrinsic (val: i32) -> i32 ---
rotr_i32     :: proc #intrinsic (val: i32) -> i32 ---

clz_i64      :: proc #intrinsic (val: i64) -> i64 ---
ctz_i64      :: proc #intrinsic (val: i64) -> i64 ---
popcnt_i64   :: proc #intrinsic (val: i64) -> i64 ---
and_i64      :: proc #intrinsic (val: i64) -> i64 ---
or_i64       :: proc #intrinsic (val: i64) -> i64 ---
xor_i64      :: proc #intrinsic (val: i64) -> i64 ---
shl_i64      :: proc #intrinsic (val: i64) -> i64 ---
slr_i64      :: proc #intrinsic (val: i64) -> i64 ---
sar_i64      :: proc #intrinsic (val: i64) -> i64 ---
rotl_i64     :: proc #intrinsic (val: i64) -> i64 ---
rotr_i64     :: proc #intrinsic (val: i64) -> i64 ---

abs_f32      :: proc #intrinsic (val: f32) -> f32 ---
ceil_f32     :: proc #intrinsic (val: f32) -> f32 ---
floor_f32    :: proc #intrinsic (val: f32) -> f32 ---
trunc_f32    :: proc #intrinsic (val: f32) -> f32 ---
nearest_f32  :: proc #intrinsic (val: f32) -> f32 ---
sqrt_f32     :: proc #intrinsic (val: f32) -> f32 ---
min_f32      :: proc #intrinsic (val: f32) -> f32 ---
max_f32      :: proc #intrinsic (val: f32) -> f32 ---
copysign_f32 :: proc #intrinsic (val: f32) -> f32 ---

abs_f64      :: proc #intrinsic (val: f64) -> f64 ---
ceil_f64     :: proc #intrinsic (val: f64) -> f64 ---
floor_f64    :: proc #intrinsic (val: f64) -> f64 ---
trunc_f64    :: proc #intrinsic (val: f64) -> f64 ---
nearest_f64  :: proc #intrinsic (val: f64) -> f64 ---
sqrt_f64     :: proc #intrinsic (val: f64) -> f64 ---
min_f64      :: proc #intrinsic (val: f64) -> f64 ---
max_f64      :: proc #intrinsic (val: f64) -> f64 ---
copysign_f64 :: proc #intrinsic (val: f64) -> f64 ---


// This is the entry point
export main2 :: proc {
    i := 0;
    while i < 10 {
        res :: fib(i);
        print_i32(res);
        i += 1;
    }

    i = 0;
    while i < 10 {
        res :: factorial(i);
        print_i32(res);
        i += 1;
    }

    x : i32;
    y := 0;
    while y < 5 {

        x = 0;
        while x < 5 {
            if x == 3 {
                x += 1;
                continue;
            }

            print_i32((x + y * 5) % 10);
            x += 1;
        }

        if y > 2 { break; }

        y += 1;
    }
}

// Foo :: struct {
//     bar       : Bar;
//     something : i32;
//     other     : i64;
// }
//
// Bar :: struct {
//     x : f32;
//     y : f32;
//     z : f32;
// }

export main :: proc {
    print_f32(sqrt_f32(2.0f));

    print_i32(5 * 6 + 2 * 3);
    print_bool(in_unit_circle(0.5f, 0.5f));

    big_num := fib(factorial(4));
    something :: other_value(0);

    global_value = 1000;
    something_else :: other_value(0);

    condition := big_num < something;

    if condition {
        print_i32(big_num);
        print_i32(something);
        print_i32(something_else);
    }
}

