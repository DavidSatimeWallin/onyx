#load "core/std"
#load "core/intrinsics/atomics"

use package core
use package core.intrinsics.atomics

Shared_Data :: struct {
    arr: [] i32;
}

// This is a shared global
shared_mutex : sync.Mutex;

// This is a thread-local global
#thread_local partial_arr : [] i32

// This is shared, and exists to test that initializing new threads
// does not re-execute the intialization segments.
test := 5678;

print_from_other_thread :: (sd) => {
    // Creating high contention for the shared resource
    for i: 10000 {
        sync.scoped_mutex(^shared_mutex);
        for ^v: sd.arr {
            *v += 1;
        }
    }

    // Using the thread-local variable
    memory.alloc_slice(^partial_arr, 5);
    for i: 5 do partial_arr[i] = i * i;
    
    // Not printing on threads since the test case looks for EXACT string matches
    // printf("On a worker thread: {}\n", partial_arr);
}

main :: (args) => {
    sync.mutex_init(^shared_mutex);

    test = 1234;
    println(test);

    sd: Shared_Data;
    sd.arr = memory.make_slice(i32, 1000);
    memory.fill_slice(sd.arr, 0);

    threads : [4] thread.Thread;
    for ^t: threads {
        thread.spawn(t, ^sd, print_from_other_thread);
        printf("Spawned thread {}\n", t.id);
    }

    memory.alloc_slice(^partial_arr, 10);
    for i: 10 do partial_arr[i] = i;

    printf("Waiting...\n");
    for ^t: threads {
        thread.join(t);
        printf("Thread {} joined!\n", t.id);
    }
    printf("{}\n", sd.arr);
    printf("On the main thread: {}\n", partial_arr);
    println(test);
}


