
use core {*}

SimpleUnion :: union {
    a: i32;
    b: struct {
        c: str;
    };

    empty: void;
    large: i64;
}

call_test :: (u_: SimpleUnion) {
    u := u_;
    __byte_dump(&u, sizeof typeof u);

    switch cast(SimpleUnion.tag_enum) u {
        case .a do println("It was a!");
        case .b do println("It was B!");
        case .empty do println("It was EMPTY!");
        case .large do println("It was a large number!");
    }
}

simple_test :: () {
    u := SimpleUnion.{ b = .{ "asdf" } };
    u  = .{ a = 123 };
    u  = .{ empty = .{} };
    u  = .{ large = 0x0123456789abcdef };

    println(cast(SimpleUnion.tag_enum) u);

    call_test(u);
}

main :: () {simple_test();} //link_test();}

Link :: union {
    End: void;
    Next: struct {
        data: i32;
        next: &Link;
    }
}

/*
print_links :: (l: Link) {
    walker := l;
    while true {
        switch walker {
            case Link.End do break;
            case Link.Next => &next {
                printf("{} ", next.data);
                walker = next.next;
            }
        }
    }
}

link_test :: () {
    l := Link.{
        Next = .{
            data = 123,
            next = &Link.{
                End = .{}
            }
        }
    };
    
    print_links(l);
}
*/

// main :: () { link_test(); }

// Optional :: union (T: type_expr) {
//     None: void;
//     Some: T;
// }
// 
// #inject Optional {
//     with :: macro (o: Optional($T), code: Code) {
//         switch o {
//             case .Some => v {
//                 #unquote code(v);
//             }
//         }
//     }
// 
//     or_default :: macro (o: Optional($T), default: T) -> T {
//         switch o {
//             case .Some => v do return v;
//             case .None      do return default;
//         }
//     }
// }

// | tag type (Tag_Enum) | data... |


// Config :: struct {
//     name: Optional(str);
// }
// 
// main :: () {
//     x := Optional(i32).{ Some = 123 };
// 
//     c: Config;
//     c.name = .{ Some = "test" };
// 
//     printf("{}.{}", typeof c.name.Some, c.name.Some);   // "Optional.tag_enum.Some"
// 
//     x->with(#quote {
//         printf("x has the value: {}\n", it);
//     });
// 
//     y := x->or_default(0);
// 
//     switch x {
//         case .None {
//             printf("x has nothing....\n");
//         }
// 
//         case .Some => &value {
//             printf("x has the value: {}\n", value);
//         }
//     }
// }
// 
// 
// 
// 
