// To be added to make this complete:
//     - Fancy display



#load "core/std"

use package core
#local runtime :: package runtime

#if false {
    @Relocate
    divide_array :: (arr: [] $T, divisions: [] [] T) {
        if divisions.count == 0 do return;

        chunk_size := arr.count / divisions.count;

        i := 0;
        for ^ divisions {
            low := i*chunk_size;
            high := (i+1)*chunk_size;
            if i == divisions.count - 1 do high = divisions.count;
            *it = arr[low .. high];
            i += 1;
        }
    }
}

@Relocate
distributor :: (arr: [] $T) -> Iterator(T) {
    Context :: struct (T: type_expr) {
        mutex: sync.Mutex;
        arr: [] T;
        curr_pos: i32;
    }

    next :: (use c: ^Context($T)) -> (T, bool) {
        sync.scoped_mutex(^mutex);

        use package core.intrinsics.onyx {__zero_value}
        if curr_pos >= arr.count do return __zero_value(T), false;

        defer curr_pos += 1;
        return arr[curr_pos], true;
    }

    close :: (use c: ^Context($T)) {
        sync.mutex_destroy(^c.mutex);
        cfree(c);
    }

    c := new(Context(T));
    sync.mutex_init(^c.mutex);
    c.arr = arr;
    c.curr_pos = 0;

    return .{ c, #solidify next {T=T}, #solidify close {T=T}};
}

Color :: enum {
    White;
    Red;
    Green;
    Yellow;
    Blue;
}

print_color :: (color: Color, format: str, args: ..any) {
    buffer: [2048] u8;
    output := conv.str_format_va(buffer, format, args);

    if runtime.compiler_os == .Linux && !settings.no_color {
        color_code: str;
        switch color {
            case .Red do color_code = "\x1b[91m";
            case .Green do color_code ="\x1b[92m";
            case .Yellow do color_code = "\x1b[93m";
            case .Blue do color_code ="\x1b[94m";
            case .White do fallthrough;
            case #default do color_code = "\x1b[97m";
        }

        printf("{}{}\x1b[0m", color_code, output);
        __flush_stdio();

    } else {
        // No color output on Windows because most windows terminals suck.
        print(output);
    }
}

Test_Case :: struct {
    source_file   : str;
    expected_file : str;
}

find_onyx_files :: (root: str, cases: ^[..] Test_Case) {
    for os.list_directory(root) {
        path_buffer: [512] u8;
        if string.ends_with(it->name(), ".onyx") {
            test_case := string.concat(path_buffer, root, "/", it->name()) |> string.alloc_copy();
            expected_file := test_case[0 .. (test_case.count - 5)];

            if !os.file_exists(expected_file) {
                print_color(.Yellow, "Skipping test case {} because an expected output file was not found.\n", test_case);
                continue;
            }

            array.push(cases, .{ test_case, expected_file });
        }

        if it.type == .Directory {
            find_onyx_files(string.concat(path_buffer, root, "/", it->name()), cases);
        }
    }

    return;
}

at_least_one_test_failed := false;

test_cases :: (cases) => {
    for #no_close *cases {
        printf("[{}]  Running test {}...\n", context.thread_id, it.source_file);

        proc := os.process_spawn(onyx_cmd, .["run", it.source_file]);
        defer os.process_destroy(^proc);

        proc_reader := io.reader_make(^proc);
        output := io.read_all(^proc_reader);
        defer memory.free_slice(^output);

        if exit := os.process_wait(^proc); exit != .Success {
            // Error running the test case
            print_color(.Red, "[{}]  Error '{}' in test case {}.\n{}", context.thread_id, exit, it.source_file, output);
            at_least_one_test_failed = true;
            continue;
        }

        for expected_file: os.with_file(it.expected_file) {
            expected_reader := io.reader_make(expected_file);
            expected_output := io.read_all(^expected_reader);

            if output != expected_output {
                print_color(.Red, "[{}]  Output did not match for {}.\n", context.thread_id, it.source_file);
                printf("Expected:\n{}\n", expected_output);
                printf("Got:\n{}\n", output);
                at_least_one_test_failed = true;
            }
        }
    }
}

// The executable to use when compiling
onyx_cmd: str;
settings := Settings.{};

Settings :: struct {
    ["--debug", "-d"]
    debug := false;

    ["--threads"]
    threads := 3;

    ["--no-color"]
    no_color := false;

    ["--tests"]
    test_folder := "./tests";
}

args_parse :: (c_args: [] cstr, output: ^Settings) -> bool {
    arg_iter := iter.as_iterator(c_args)
             |> iter.map((x) => string.from_cstr(*x));

    use type_info;

    arg_type := cast(^Type_Info_Struct) get_type_info(typeof *output);
    if arg_type.kind != .Struct do return false;

    for #no_close arg: arg_iter {
        for ^member: arg_type.members {
            for ^tag: member.tags {
                if tag.type != str do continue;

                to_match := *cast(^str) tag.data;
                if arg != to_match do continue;

                switch member.type {
                    case bool {
                        // Should there be a way to specify a variable to be false?
                        *(cast(^bool) (cast(^u8) output + member.offset)) = true;
                    }

                    case i32 {
                        value_str, success := iter.take_one(arg_iter);
                        if !success do return false;

                        value := conv.str_to_i64(value_str);
                        *(cast(^i32) (cast(^u8) output + member.offset)) = ~~value;
                    }

                    case str {
                        value, success := iter.take_one(arg_iter);
                        if !success do return false;

                        *(cast(^str) (cast(^u8) output + member.offset)) = value;
                    }

                    case #default {
                        println("Unsupported argument type.");
                        return false;
                    }
                }
            }
        }
    }

    // This has to be done explicitly beacuse the iter.take_one function
    // can close the iterator if it runs out during the taking.
    arg_iter.close(arg_iter.data);
    return true;
}

main :: (args) => {
    args_parse(args, ^settings);
    printf("Using {p*}\n", ^settings);

    switch runtime.compiler_os {
        case .Linux {
            onyx_cmd = "./bin/onyx";
            if settings.debug do onyx_cmd = "./bin/onyx-debug";
        }
        case .Windows do onyx_cmd = "onyx.exe";
    }

    cases := array.make(Test_Case, capacity=256);
    find_onyx_files(settings.test_folder, ^cases);

    thread_count := settings.threads;
    case_iterator := distributor(cases);

    if thread_count > 0 {
        // Stack allocate this in the future?
        threads := memory.make_slice(thread.Thread, thread_count);

        for thread_count {
            thread.spawn(^threads[it], ^case_iterator, test_cases);
        }

        test_cases(^case_iterator);

        for ^ threads do thread.join(it);

    } else {
        test_cases(^case_iterator);
    }

    case_iterator->close();

    if at_least_one_test_failed {
        print_color(.Red, "FAILED\n");
        // (package wasi).proc_exit(1);

    } else {
        print_color(.Green, "SUCCESS\n");
    }
}