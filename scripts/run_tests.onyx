// To be added to make this complete:
//     - Fancy display



#load "core/std"

use package core
#local runtime :: package runtime

#if false {
    @Relocate
    divide_array :: (arr: [] $T, divisions: [] [] T) {
        if divisions.count == 0 do return;

        chunk_size := arr.count / divisions.count;

        i := 0;
        for ^ divisions {
            low := i*chunk_size;
            high := (i+1)*chunk_size;
            if i == divisions.count - 1 do high = divisions.count;
            *it = arr[low .. high];
            i += 1;
        }
    }
}

@Relocate
distributor :: (arr: [] $T) -> Iterator(T) {
    Context :: struct (T: type_expr) {
        mutex: sync.Mutex;
        arr: [] T;
        curr_pos: i32;
    }

    next :: (use c: ^Context($T)) -> (T, bool) {
        sync.scoped_mutex(^mutex);

        use package core.intrinsics.onyx {__zero_value}
        if curr_pos >= arr.count do return __zero_value(T), false;

        defer curr_pos += 1;
        return arr[curr_pos], true;
    }

    close :: (use c: ^Context($T)) {
        sync.mutex_destroy(^c.mutex);
        cfree(c);
    }

    c := new(Context(T));
    sync.mutex_init(^c.mutex);
    c.arr = arr;
    c.curr_pos = 0;

    return .{ c, #solidify next {T=T}, #solidify close {T=T}};
}

Color :: enum {
    White;
    Red;
    Green;
    Yellow;
    Blue;
}

print_color :: (color: Color, format: str, args: ..any) {
    buffer: [2048] u8;
    output := conv.str_format_va(buffer, format, args);

    #if runtime.OS == runtime.OS_Linux {
        color_code: str;
        switch color {
            case .Red do color_code = "\x1b[91m";
            case .Green do color_code ="\x1b[92m";
            case .Yellow do color_code = "\x1b[93m";
            case .Blue do color_code ="\x1b[94m";
            case .White do fallthrough;
            case #default do color_code = "\x1b[97m";
        }

        printf("{}{}\x1b[0m", color_code, output);
        __flush_stdio();

    } else {
        // No color output on Windows because most windows terminals suck.
        print(output);
    }
}

Test_Case :: struct {
    source_file   : str;
    expected_file : str;
}

find_onyx_files :: (root: str, cases: ^[..] Test_Case) {
    for os.list_directory(root) {
        path_buffer: [512] u8;
        if string.ends_with(it.name, ".onyx") {
            test_case := string.concat(path_buffer, root, "/", it.name) |> string.alloc_copy();
            expected_file := test_case[0 .. (test_case.count - 5)];

            if !io.file_exists(expected_file) {
                print_color(.Yellow, "Skipping test case {} because an expected output file was not found.\n", test_case);
                continue;
            }

            array.push(cases, .{ test_case, expected_file });
        }

        if it.dirent.d_type == .Directory {
            find_onyx_files(string.concat(path_buffer, root, "/", it.name), cases);
        }
    }

    return;
}

at_least_one_test_failed := false;

test_cases :: (cases) => {
    for #no_close *cases {
        printf("[{}]  Running test {}...\n", context.thread_id, it.source_file);

        proc := io.process_spawn(onyx_cmd, .["run", it.source_file]);
        defer io.process_destroy(^proc);

        proc_reader := io.reader_make(^proc);
        output := io.read_all(^proc_reader);
        defer memory.free_slice(^output);

        if exit := io.process_wait(^proc); exit != .Success {
            // Error running the test case
            print_color(.Red, "[{}]  Error compiling test case {}.\n{}", context.thread_id, it.source_file, output);
            at_least_one_test_failed = true;
            continue;
        }

        for expected_file: io.with_file(it.expected_file) {
            expected_reader := io.reader_make(expected_file);
            expected_output := io.read_all(^expected_reader);

            if output != expected_output {
                print_color(.Red, "[{}]  Output did not match for {}.\n", context.thread_id, it.source_file);
                at_least_one_test_failed = true;
            }
        }
    }
}

// The executable to use when compiling
onyx_cmd: str;

main :: (args) => {
    test_folder := "./tests";

    switch runtime.OS {
        case runtime.OS_Linux {
            onyx_cmd = "./bin/onyx";
            if args.count > 1 {
                if string.from_cstr(args[1]) == "debug" do onyx_cmd = "./bin/onyx-debug";
            }
        }
        case runtime.OS_Windows do onyx_cmd = "onyx.exe";
    }

    cases := array.make(Test_Case);
    find_onyx_files(test_folder, ^cases);

    thread_count := 3;
    for args {
        arg := string.from_cstr(it);
        if string.starts_with(arg, "--threads=") {
            string.read_until(^arg, #char "=");

            thread_count = ~~ conv.str_to_i64(arg[1 .. arg.count]);
        }
    }

    case_iterator := distributor(cases);

    if thread_count > 0 {
        // Stack allocate this in the future?
        threads := memory.make_slice(thread.Thread, thread_count);

        for thread_count {
            thread.spawn(^threads[it], ^case_iterator, test_cases);
        }

        test_cases(^case_iterator);

        for ^ threads do thread.join(it);

    } else {
        test_cases(^case_iterator);
    }

    case_iterator->close();

    if at_least_one_test_failed {
        print_color(.Red, "FAILED\n");
        (package wasi).proc_exit(1);

    } else {
        print_color(.Green, "SUCCESS\n");
    }
}