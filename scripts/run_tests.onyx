#load "core/std"

use package core
#local wasi :: package wasi
#local runtime :: package runtime

Directory_Entry :: struct {
    dirent : wasi.DirEnt;
    name   : str;
}

list_directory :: (path: str) -> Iterator(Directory_Entry) {
    Context :: struct {
        dir_fd: wasi.FileDescriptor;
        opened := false;
        reached_end := false;

        entry_walker: ^u8;

        buffer_used: u32 = 0;
        buffer: [1024] u8;

        last_cookie: wasi.DirCookie = 0;
    }

    next :: (use c: ^Context) -> (Directory_Entry, bool) {
        use package core.intrinsics.onyx {__zero_value}
        if !opened do return __zero_value(Directory_Entry), false;

        read_more :: macro () {
            if !reached_end {
                err := wasi.fd_readdir(dir_fd, ~~buffer, sizeof typeof buffer, last_cookie, ^buffer_used);
                reached_end = buffer_used != sizeof typeof buffer;

                entry_walker = ~~buffer;
            } else {
                return __zero_value(Directory_Entry), false;
            }
        }

        if buffer_used < sizeof(wasi.DirEnt) do read_more();

        dirent := cast(^wasi.DirEnt) entry_walker;
        if buffer_used < sizeof(wasi.DirEnt) + dirent.d_namlen {
            read_more();
            dirent = ~~entry_walker;
        }

        name := str.{~~(dirent + 1), dirent.d_namlen};

        entry_size := sizeof(wasi.DirEnt) + dirent.d_namlen;
        entry_walker += entry_size;
        buffer_used -= entry_size;
        last_cookie = dirent.d_next;

        return .{*dirent, name}, true;
    }

    close :: (use c: ^Context) {
        wasi.fd_close(dir_fd);
        cfree(c);
    }

    c := new(Context);
    if err := wasi.path_open(4, 0, path, .Directory, ~~0xffffffff, ~~0xffffffff, .Sync, ^c.dir_fd); err == .Success {
        c.opened = true;
    }

    return .{ c, next, close };
}

find_onyx_files :: (root: str, cases: ^[..] str) {
    for list_directory(root) {
        path_buffer: [512] u8;
        if string.ends_with(it.name, ".onyx") {
            test_case := string.concat(path_buffer, root, "/", it.name) |> string.alloc_copy();
            array.push(cases, test_case);
        }

        if it.dirent.d_type == .Directory {
            find_onyx_files(string.concat(path_buffer, root, "/", it.name), cases);
        }
    }

    return;
}

#if false {
    divide_array :: (arr: [] $T, divisions: [] [] T) {
        if divisions.count == 0 do return;

        chunk_size := arr.count / divisions.count;

        i := 0;
        for ^ divisions {
            low := i*chunk_size;
            high := (i+1)*chunk_size;
            if i == divisions.count - 1 do high = divisions.count;
            *it = arr[low .. high];
            i += 1;
        }
    }
}

distributor :: (arr: [] $T) -> Iterator(T) {
    Context :: struct (T: type_expr) {
        mutex: sync.Mutex;
        arr: [] T;
        curr_pos: i32;
    }

    next :: (use c: ^Context($T)) -> (T, bool) {
        sync.scoped_mutex(^mutex);

        use package core.intrinsics.onyx {__zero_value}
        if curr_pos >= arr.count do return __zero_value(T), false;

        defer curr_pos += 1;
        return arr[curr_pos], true;
    }

    close :: (use c: ^Context($T)) {
        // This will leak because it shouldn't be freed.
    }

    c := new(Context(T));
    sync.mutex_init(^c.mutex);
    c.arr = arr;
    c.curr_pos = 0;

    return .{ c, #solidify next {T=T}, #solidify close {T=T}};
}

main :: (args) => {
    test_folder := "./tests";

    #persist onyx_cmd: str;
    switch runtime.OS {
        case runtime.OS_Linux  {
            onyx_cmd = "./bin/onyx";
            if args.count > 1 {
                if string.from_cstr(args[1]) == "debug" do onyx_cmd = "./bin/onyx-debug";
            }
        }
        case runtime.OS_Windows do onyx_cmd = "onyx.exe";
    }

    test_cases :: (cases) => {
        for *cases {
            printf("[{}]  Running test {}...\n", context.thread_id, it);

            proc := io.process_spawn(onyx_cmd, .["run", it]);
            defer io.process_destroy(^proc);

            proc_reader := io.reader_make(^proc);
            output := io.read_all(^proc_reader);
            defer memory.free_slice(^output);

            if exit := io.process_wait(^proc); exit != .Success {
                // Error running the test case
                println(exit);
                println(output);
            }
        }
    }

    cases := array.make(str);
    find_onyx_files(test_folder, ^cases);

    Thread_Count :: 3
    #persist threads: [Thread_Count] thread.Thread;

    case_iterator := distributor(cases);

    for Thread_Count {
        thread.spawn(^threads[it], ^case_iterator, test_cases);
    }

    test_cases(^case_iterator);
    for ^ threads do thread.join(it);
    println("Done");
}