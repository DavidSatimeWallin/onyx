// To be added to make this complete:
//     - Fancy display



#load "core/std"

use package core
use package core.intrinsics.onyx { init }
#local runtime :: package runtime

Color :: enum {
    White;
    Red;
    Green;
    Yellow;
    Blue;
}

print_color :: (color: Color, format: str, args: ..any) {
    buffer: [2048] u8;
    output := conv.str_format_va(buffer, format, args);

    if runtime.compiler_os == .Linux && !settings.no_color {
        color_code: str;
        switch color {
            case .Red do color_code = "\x1b[91m";
            case .Green do color_code ="\x1b[92m";
            case .Yellow do color_code = "\x1b[93m";
            case .Blue do color_code ="\x1b[94m";
            case .White do fallthrough;
            case #default do color_code = "\x1b[97m";
        }

        printf("{}{}\x1b[0m", color_code, output);
        __flush_stdio();

    } else {
        // No color output on Windows because most windows terminals suck.
        print(output);
    }
}

Test_Case :: struct {
    source_file   : str;
    expected_file : str;
}

find_onyx_files :: (root: str, cases: ^[..] Test_Case) {
    for os.list_directory(root) {
        path_buffer: [512] u8;
        if string.ends_with(it->name(), ".onyx") {
            test_case := string.concat(path_buffer, root, "/", it->name()) |> string.alloc_copy();
            expected_file := test_case[0 .. (test_case.count - 5)];

            if !os.file_exists(expected_file) {
                print_color(.Yellow, "Skipping test case {} because an expected output file was not found.\n", test_case);
                continue;
            }

            array.push(cases, .{ test_case, expected_file });
        }

        if it.type == .Directory {
            find_onyx_files(string.concat(path_buffer, root, "/", it->name()), cases);
        }
    }

    return;
}

settings := Settings.{};

Settings :: struct {
    ["--debug", "-d"]
    debug := false;

    ["--threads"]
    threads := 4;

    ["--no-color"]
    no_color := false;

    ["--tests"]
    test_folder := "./tests";
}

args_parse :: (c_args: [] cstr, output: ^Settings) -> bool {
    arg_iter := iter.as_iterator(c_args)
             |> iter.map((x) => string.from_cstr(*x));

    use type_info;

    arg_type := cast(^Type_Info_Struct) get_type_info(typeof *output);
    if arg_type.kind != .Struct do return false;

    for #no_close arg: arg_iter {
        for ^member: arg_type.members {
            for ^tag: member.tags {
                if tag.type != str do continue;

                to_match := *cast(^str) tag.data;
                if arg != to_match do continue;

                switch member.type {
                    case bool {
                        // Should there be a way to specify a variable to be false?
                        *(cast(^bool) (cast(^u8) output + member.offset)) = true;
                    }

                    case i32 {
                        value_str, success := iter.take_one(arg_iter);
                        if !success do return false;

                        value := conv.str_to_i64(value_str);
                        *(cast(^i32) (cast(^u8) output + member.offset)) = ~~value;
                    }

                    case str {
                        value, success := iter.take_one(arg_iter);
                        if !success do return false;

                        *(cast(^str) (cast(^u8) output + member.offset)) = value;
                    }

                    case #default {
                        println("Unsupported argument type.");
                        return false;
                    }
                }
            }
        }
    }

    // This has to be done explicitly beacuse the iter.take_one function
    // can close the iterator if it runs out during the taking.
    arg_iter.close(arg_iter.data);
    return true;
}

main :: (args) => {
    args_parse(args, ^settings);
    printf("Using {p*}\n", ^settings);

    Execution_Context :: struct {
        // The executable to use when compiling
        onyx_cmd: str;
        at_least_one_test_failed := false;
    }
    exec_context := init(Execution_Context);

    switch runtime.compiler_os {
        case .Linux {
            exec_context.onyx_cmd = "./bin/onyx";
            if settings.debug do exec_context.onyx_cmd = "./bin/onyx-debug";
        }
        case .Windows do exec_context.onyx_cmd = "onyx.exe";
    }

    cases := array.make(Test_Case, capacity=256);
    find_onyx_files(settings.test_folder, ^cases);

    thread_count := settings.threads;

    iter.parallel_for(cases, settings.threads, ^exec_context) {
        // Weird macros mean I have to forward external names
        use package core
        print_color :: print_color

        printf("[{}]  Running test {}...\n", context.thread_id, it.source_file);

        proc := os.process_spawn(thread_data.onyx_cmd, .["run", it.source_file]);
        defer os.process_destroy(^proc);

        proc_reader := io.reader_make(^proc);
        output := io.read_all(^proc_reader);
        defer memory.free_slice(^output);

        if exit := os.process_wait(^proc); exit != .Success {
            // Error running the test case
            print_color(.Red, "[{}]  Error '{}' in test case {}.\n{}", context.thread_id, exit, it.source_file, output);
            thread_data.at_least_one_test_failed = true;
            continue;
        }

        for expected_file: os.with_file(it.expected_file) {
            expected_reader := io.reader_make(expected_file);
            expected_output := io.read_all(^expected_reader);

            if output != expected_output {
                print_color(.Red, "[{}]  Output did not match for {}.\n", context.thread_id, it.source_file);
                printf("Expected:\n{}\n", expected_output);
                printf("Got:\n{}\n", output);
                thread_data.at_least_one_test_failed = true;
            }
        }
    }

    if exec_context.at_least_one_test_failed {
        print_color(.Red, "FAILED\n");
        os.exit(-1);

    } else {
        print_color(.Green, "SUCCESS\n");
    }
}