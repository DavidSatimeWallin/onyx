package c_binding

use package core
use package simd

#if !#defined((package runtime).Generated_Foreign_Info) {
    #error "Please run this script with the '--generate-foreign-info' flag."
}

Cast_Mapping :: struct {
    type: type_expr;
    name: str;
}

Impl_Mapping :: struct {
    name: str;
    impl: str;
}

Binding_Config :: struct {
    foreign_block: type_info.foreign_block;
    preamble: [] str;
    output_file: str;
    cast_map: [] Cast_Mapping;
    custom_implementations: [] Impl_Mapping;
}

build_c_binding :: (use binding_config: Binding_Config) -> bool {
    for file: os.with_file(output_file, .Write) {
        writer := io.writer_make(file);
        fb := type_info.get_foreign_block(foreign_block);

        write_file_introduction(^writer, preamble, fb.module_name);

        for fb.funcs {
            for impl: custom_implementations {
                if impl.name == it.name {
                    io.write(^writer, impl.impl);
                    io.write(^writer, "\n");
                    continue continue;
                }
            }

            write_function_body(^writer, it, cast_map);
        }

        write_library_block(^writer, fb.funcs);
    }

    return true;
}

write_file_introduction :: (writer: ^io.Writer, preamble: [] str, name: str) {
    io.write_format(writer, "//\n");
    io.write_format(writer, "// THIS FILE WAS AUTOMATICALLY GENERATED.\n");
    io.write_format(writer, "//\n");

    for text: preamble {
        io.write_format(writer, "{}\n", text);
    }

    io.write_format(writer, """
#define ONYX_LIBRARY_NAME {}
#include "onyx_library.h"

#define P(i, k) (params->data[i].of.k)

""", name);
}

write_function_body :: (writer, ff, cast_map) => {
    use type_info;

    method_type := ff.type;
    method_info := cast (^Type_Info_Function) get_type_info(method_type);
    assert(method_info.kind == .Function, "Expected function type.");

    io.write_format(writer, "ONYX_DEF({}, (", ff.name);
    i := 0;
    for method_info.parameter_types {
        io.write(writer, type_encoding(it));

        if i != method_info.parameter_types.count - 1 {
            io.write(writer, ", ");
        }
        i += 1;
    }

    io.write(writer, "), (");
    io.write(writer, type_encoding(method_info.return_type));
    io.write(writer, ")) {\n");
    print_body(writer, ff.name, method_info, cast_map);
    io.write(writer, "}\n\n");
}

write_library_block :: (writer, funcs) => {
    io.write(writer, "\n\n");
    io.write(writer, "ONYX_LIBRARY {\n");
    for funcs {
        io.write_format(writer, "    ONYX_FUNC({})\n", it.name);
    }
    io.write(writer, "    NULL\n");
    io.write(writer, "};");
}

print_body :: (writer, method_name, method_info, cast_map) => {
    use type_info;
    call := io.dynamic_string_stream_make();
    defer io.dynamic_string_stream_free(^call);
    callw := io.writer_make(^call);

    param_num := 0;
    for method_info.parameter_types {
        if get_type_info(it).kind == .Slice {
            io.write_format(^callw, "ONYX_PTR(P({}, i32)), P({}, i32)", param_num, param_num + 1);
            param_num += 1;

        } elseif is_pointer(it) {
            io.write_format(^callw, "ONYX_PTR(P({}, i32))", param_num);

        } else {
            matched := false;
            for^ m: cast_map {
                if m.type == it {
                    io.write_format(^callw, "({}) P({}, {})", m.name, param_num, type_to_wasm_type(it));
                    matched = true;
                    break;
                }
            }
            
            if !matched do io.write_format(^callw, "P({}, {})", param_num, type_to_wasm_type(it));
        }

        io.write_format(^callw, ", ");
        param_num += 1;
    }

    call_str := call->to_str();
    wasm_return_type := type_to_wasm_type(method_info.return_type);
    switch wasm_return_type {
        case ""    do io.write_format(writer, "    {}({});\n", method_name, call_str[0..call_str.count-2]);
        case "i32" do io.write_format(writer, "    results->data[0] = WASM_I32_VAL({}({}));\n", method_name, call_str[0..call_str.count-2]);
        case "i64" do io.write_format(writer, "    results->data[0] = WASM_I64_VAL({}({}));\n", method_name, call_str[0..call_str.count-2]);
        case "f32" do io.write_format(writer, "    results->data[0] = WASM_F32_VAL({}({}));\n", method_name, call_str[0..call_str.count-2]);
        case "f64" do io.write_format(writer, "    results->data[0] = WASM_F64_VAL({}({}));\n", method_name, call_str[0..call_str.count-2]);
    }

    io.write_format(writer, "    return NULL;\n");
}

type_to_wasm_type :: (t: type_expr) -> str {
    use type_info;

    param_info := get_type_info(t);
    switch param_info.kind {
        case .Basic do switch t {
            case bool do return "i32";
            case i8   do return "i32";
            case u8   do return "i32";
            case i16  do return "i32";
            case u16  do return "i32";
            case i32  do return "i32";
            case u32  do return "i32";
            case i64  do return "i64";
            case u64  do return "i64";

            case f32  do return "f32";
            case f64  do return "f64";

            case rawptr do return "i32"; // This will have to depend on the pointer size...
            
            case i8x16, i16x8, i32x4, i64x2, f32x4, f64x2, v128 do return "v128";

            case type_expr do return "i32";
        }

        case .Pointer do return "i32"; // This will also have to depend on the pointer size...
        case .Function do assert(false, "Passing functions between wasm and c is not yet supported.");
        case .Array do return "i32";
        case .Slice do assert(false, "ASDFASDF");
        case .Enum do return type_to_wasm_type((cast(^Type_Info_Enum) param_info).backing_type);
        case .Distinct do return type_to_wasm_type((cast(^Type_Info_Distinct) param_info).base_type);

        case .Struct {
            s_info := cast(^Type_Info_Struct) param_info;
            if s_info.members.count == 1 {
                return type_to_wasm_type(s_info.members[0].type);
            }

            assert(false, "Passing structures between wasm and c is not yet supported.");
        }
    }

    return "";
}

type_encoding :: (t: type_expr) -> str {
    use type_info;

    param_info := get_type_info(t);
    switch param_info.kind {
        case .Basic do switch t {
            case bool do return "WASM_I32";
            case i8   do return "WASM_I32";
            case u8   do return "WASM_I32";
            case i16  do return "WASM_I32";
            case u16  do return "WASM_I32";
            case i32  do return "WASM_I32";
            case u32  do return "WASM_I32";
            case i64  do return "WASM_I64";
            case u64  do return "WASM_I64";

            case f32  do return "WASM_F32";
            case f64  do return "WASM_F64";

            case rawptr do return "WASM_I32"; // This will have to depend on the pointer size...
            
            case i8x16, i16x8, i32x4, i64x2, f32x4, f64x2, v128 do return "WASM_V128";

            case type_expr do return "WASM_I32";
        }

        case .Pointer do return "WASM_I32"; // This will also have to depend on the pointer size...
        case .Function do assert(false, "Passing functions between wasm and c is not yet supported.");
        case .Array do return "WASM_I32";
        case .Slice do return "WASM_I32,WASM_I32";
        case .Enum do return type_encoding((cast(^Type_Info_Enum) param_info).backing_type);
        case .Distinct do return type_encoding((cast(^Type_Info_Distinct) param_info).base_type);

        case .Struct {
            s_info := cast(^Type_Info_Struct) param_info;
            if s_info.members.count == 1 {
                return type_encoding(s_info.members[0].type);
                return;
            }

            assert(false, "Passing structures between wasm and c is not yet supported.");
        }
    }

    return "";
}
