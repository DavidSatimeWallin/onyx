#load "core/std"

use package core
use package simd

CBindings :: (package ncurses).CBindings

#if !#defined(CBindings) {
    #error "Expected to find CBindings structure";
}



main :: (args: [] cstr) {
    println(CBindings.file_prefix);

    printf("""
#define ONYX_LIBRARY_NAME {}
#include "onyx_library.h"

#define P(i, k) (params->data[i].of.k)

""", CBindings.name);

    use type_info;
    bind_info := cast(^Type_Info_Struct) get_type_info(CBindings);
    for bind_info.methods {
        method_type := it.func.type;
        method_info := cast (^Type_Info_Function) get_type_info(method_type);
        assert(method_info.kind == .Function, "Expected function type.");

        printf("ONYX_DEF({}, (", it.name);
        i := 0;
        for method_info.parameter_types {
            print_type_encoding(it);

            if i != method_info.parameter_types.count - 1 {
                print(", ");
            }
            i += 1;
        }

        print("), (");
        print_type_encoding(method_info.return_type);
        print(")) {\n");
        print_body(it.name, method_info);
        print("}\n\n");
    }

    print("\n\n");
    print("ONYX_LIBRARY {\n");
    for bind_info.methods {
        printf("    ONYX_FUNC({})\n", it.name);
    }
    print("    NULL\n");
    print("};");
}

print_body :: (method_name, method_info) => {
    use type_info;
    call := io.dynamic_string_stream_make();
    defer io.dynamic_string_stream_free(^call);
    callw := io.writer_make(^call);

    param_num := 0;
    for method_info.parameter_types {
        if get_type_info(it).kind == .Slice {
            io.write_format(^callw, "ONYX_PTR(P({}, i32)), P({}, i32)", param_num, param_num + 1);
            param_num += 1;

        } elseif is_pointer(it) {
            io.write_format(^callw, "ONYX_PTR(P({}, i32))", param_num);

        } else {
            matched := false;
            for^ m: CBindings.cast_map {
                if m.type == it {
                    io.write_format(^callw, "({}) P({}, {})", m.name, param_num, type_to_wasm_type(it));
                    matched = true;
                    break;
                }
            }
            
            if !matched do io.write_format(^callw, "P({}, {})", param_num, type_to_wasm_type(it));
        }

        io.write_format(^callw, ", ");
        param_num += 1;
    }

    call_str := call->to_str();
    wasm_return_type := type_to_wasm_type(method_info.return_type);
    switch wasm_return_type {
        case ""    do printf("    {}({});\n", method_name, call_str[0..call_str.count-2]);
        case "i32" do printf("    results->data[0] = WASM_I32_VAL({}({}));\n", method_name, call_str[0..call_str.count-2]);
        case "i64" do printf("    results->data[0] = WASM_I64_VAL({}({}));\n", method_name, call_str[0..call_str.count-2]);
        case "f32" do printf("    results->data[0] = WASM_F32_VAL({}({}));\n", method_name, call_str[0..call_str.count-2]);
        case "f64" do printf("    results->data[0] = WASM_F64_VAL({}({}));\n", method_name, call_str[0..call_str.count-2]);
    }

    printf("    return NULL;\n");
}

type_to_wasm_type :: (t: type_expr) -> str {
    use type_info;

    param_info := get_type_info(t);
    switch param_info.kind {
        case .Basic do switch t {
            case bool do return "i32";
            case i8   do return "i32";
            case u8   do return "i32";
            case i16  do return "i32";
            case u16  do return "i32";
            case i32  do return "i32";
            case u32  do return "i32";
            case i64  do return "i64";
            case u64  do return "i64";

            case f32  do return "f32";
            case f64  do return "f64";

            case rawptr do return "i32"; // This will have to depend on the pointer size...
            
            case i8x16, i16x8, i32x4, i64x2, f32x4, f64x2, v128 do return "v128";

            case type_expr do return "i32";
        }

        case .Pointer do return "i32"; // This will also have to depend on the pointer size...
        case .Function do assert(false, "Passing functions between wasm and c is not yet supported.");
        case .Array do return "i32";
        case .Slice do assert(false, "ASDFASDF");
        case .Enum do return type_to_wasm_type((cast(^Type_Info_Enum) param_info).backing_type);
        case .Distinct do return type_to_wasm_type((cast(^Type_Info_Distinct) param_info).base_type);

        case .Struct {
            s_info := cast(^Type_Info_Struct) param_info;
            if s_info.members.count == 1 {
                return type_to_wasm_type(s_info.members[0].type);
            }

            assert(false, "Passing structures between wasm and c is not yet supported.");
        }
    }

    return "";
}

print_type_encoding :: (t: type_expr) {
    use type_info;

    param_info := get_type_info(t);
    switch param_info.kind {
        case .Basic do switch t {
            case bool do print("WASM_I32");
            case i8   do print("WASM_I32");
            case u8   do print("WASM_I32");
            case i16  do print("WASM_I32");
            case u16  do print("WASM_I32");
            case i32  do print("WASM_I32");
            case u32  do print("WASM_I32");
            case i64  do print("WASM_I64");
            case u64  do print("WASM_I64");

            case f32  do print("WASM_F32");
            case f64  do print("WASM_F64");

            case rawptr do print("WASM_I32"); // This will have to depend on the pointer size...
            
            case i8x16, i16x8, i32x4, i64x2, f32x4, f64x2, v128 do print("WASM_V128");

            case type_expr do print("WASM_I32");
        }

        case .Pointer do print("WASM_I32"); // This will also have to depend on the pointer size...
        case .Function do assert(false, "Passing functions between wasm and c is not yet supported.");
        case .Array do print("WASM_I32");
        case .Slice do print("WASM_I32, WASM_I32");
        case .Enum do print_type_encoding((cast(^Type_Info_Enum) param_info).backing_type);
        case .Distinct do print_type_encoding((cast(^Type_Info_Distinct) param_info).base_type);

        case .Struct {
            s_info := cast(^Type_Info_Struct) param_info;
            if s_info.members.count == 1 {
                print_type_encoding(s_info.members[0].type);
                return;
            }

            assert(false, "Passing structures between wasm and c is not yet supported.");
        }
    }
}
