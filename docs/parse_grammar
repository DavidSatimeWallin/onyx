Note: ~ is empty
Goal: Design the language to have no ambiguity (so a greedy algorithm can work)


SOURCE_FILE = TOP_LEVEL_STATEMENT ; SOURCE_FILE | ~

TOP_LEVEL_STATEMENT
	= COMMENT -- Should comments not be passed to the parser? Depends if I need to look at them. Probably not
	| USE_DECLARATION
	| EXPORT_DECLARATION
	| FOREIGN_DECLARATION
	| TOP_LEVEL_DECLARATION

COMMENT = TOKEN_TYPE_COMMENT

USE_DECLARATION = use TOKEN_TYPE_LITERAL_STRING

EXPORT_DECLARATION = export TOP_LEVEL_DECLARATION

FOREIGN_DECLARATION = foreign TOKEN_TYPE_LITERAL_STRING TOKEN_TYPE_LITERAL_STRING :: TOP_LEVEL_VALUE

TOP_LEVEL_DECLARATION = TOKEN_TYPE_SYMBOL :: TOP_LEVEL_VALUE

TOP_LEVEL_VALUE
	= FUNCTION_DECLARATION
	| STRUCT_DECLARATION

FUNCTION_DECLARATION = proc FUNCTION_TYPE BLOCK

FUNCTION_TYPE = ( FUNCTION_PARAMS ) -> TOKEN_TYPE_SYMBOL

-- This may be too weird...
BLOCK = { STATEMENTS | ---
STATEMENTS = STATEMENT ; STATEMENTS | }

STATEMENT
	= ASSIGNMENT_STATEMENT
	| IF_STATEMENT
	| FOR_STATEMENT
	| RETURN_STATEMENT
	| EXPRESSION

ASSIGNMENT_STATEMENT = TOKEN_TYPE_SYMBOL = EXPRESSION

IF_STATEMENT
	= if EXPRESSION BLOCK ELSE_IF_STATEMENT ELSE_STATEMENT

ELSEIF_STATEMENT = elseif EXPRESSION BLOCK ELSEIF_STATEMENT | ~

ELSE_STATEMENT = else BLOCK | ~

-- This needs to be better
FOR_STATEMENT = for STATEMENT ; EXPRESSION ; STATEMENT BLOCK

RETURN_STATEMENT = return EXPRESSION

-- Remove abiguity in implementation
EXPRESSION
	= EXPRESSION + EXPRESSION
	| EXPRESSION - EXPRESSION
	| EXPRESSION * EXPRESSION
	| EXPRESSION / EXPRESSION
	| EXPRESSION % EXPRESSION
	| do BLOCK
	| FUNCTION_CALL -- This could have some abiguity with just the symbol
	| ( EXPRESSION )
	| TOKEN_TYPE_SYMBOL

FUNCTION_CALL = TOKEN_TYPE_SYMBOL ( EXPRESSION_LIST )

-- Implement just using a loop
COMMA_LIST(T) = T | T , COMMA_LIST(T)

FUNCTION_PARAMS = COMMA_LIST(TOKEN_TYPE_SYMBOL :: TOKEN_TYPE_SYMBOL)
EXPRESSION_LIST = COMMA_LIST(EXPRESSION)

STRUCT_DECLARATION = struct { STRUCT_MEMBERS }
STRUCT_MEMBERS = COMMA_LIST(TOKEN_TYPE_SYMBOL :: TOKEN_TYPE_SYMBOL)