Note: ~ is empty
Goal: Design the language to have no ambiguity


SOURCE_FILE = TOP_LEVEL_STATEMENT TOKEN_TYPE_SYM_SEMICOLON SOURCE_FILE | ~

TOP_LEVEL_STATEMENT
	= USE_DECLARATION
	| EXPORT_DECLARATION
	| FOREIGN_DECLARATION
	| TOP_LEVEL_DECLARATION
	| COMMENT

COMMENT = TOKEN_TYPE_COMMENT

USE_DECLARATION = use TOKEN_TYPE_LITERAL_STRING

EXPORT_DECLARATION = export TOP_LEVEL_DECLARATION

TOP_LEVEL_DECLARATION
	= FUNCTION_DECLARATION
	| STRUCT_DECLARATION
	| GLOBAL_DECLARATION

FUNCTION_DECLARATION = proc TOKEN_TYPE_SYMBOL FUNCTION_TYPE BLOCK

FUNCTION_TYPE = :: ( FUNCTION_PARAMS ) -> TOKEN_TYPE_SYMBOL

BLOCK = { STATEMENTS }

STATEMENTS = STATEMENT ; STATEMENTS | ~

STATEMENT
	= ASSIGNMENT_STATEMENT
	| IF_STATEMENT
	| FOR_STATEMENT
	| RETURN_STATEMENT
	| EXPRESSION

ASSIGNMENT_STATEMENT = TOKEN_TYPE_SYMBOL = EXPRESSION

IF_STATEMENT
	= if EXPRESSION BLOCK ELSE_IF_STATEMENT ELSE_STATEMENT

ELSEIF_STATEMENT = TOKEN_TYPE_KEYWORD_ELSEIF EXPRESSION BLOCK ELSEIF_STATEMENT | ~

ELSE_STATEMENT = TOKEN_TYPE_KEYWORD_ELSE BLOCK | ~

-- This needs to be better
FOR_STATEMENT = for STATEMENT ; EXPRESSION ; STATEMENT BLOCK

RETURN_STATEMENT = return EXPRESSION

-- Remove abiguity in implementation
EXPRESSION
	= EXPRESSION + EXPRESSION
	| EXPRESSION - EXPRESSION
	| EXPRESSION * EXPRESSION
	| EXPRESSION / EXPRESSION
	| EXPRESSION % EXPRESSION
	| do BLOCK
	| FUNCTION_CALL -- This could have some abiguity with just the symbol
	| ( EXPRESSION )
	| TOKEN_TYPE_SYMBOL

FUNCTION_CALL = TOKEN_TYPE_SYMBOL ( EXPRESSION_LIST )

-- Implement just using a loop
COMMA_LIST(T) = T | T , COMMA_LIST(T)

FUNCTION_PARAMS = COMMA_LIST(TOKEN_TYPE_SYMBOL :: TOKEN_TYPE_SYMBOL)
EXPRESSION_LIST = COMMA_LIST(EXPRESSION)
