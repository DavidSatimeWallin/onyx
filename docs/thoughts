Memory design:
    - Pointers will work very similar to how they do in C
        - A pointer is a u32
        - Pointers will be notated:
            ^u32  <- Pointer to u32

        - Pointer operations will be:
            * will take the address of a value
                - This operation will not be defined well for a while
                - You can't take the address of a local since it doesn't exist in memory

            << will take the value out of a pointer

            Example use:
            {{{
                ptr: ^i32 = 0; // Address starting at 0
                ptr_ptr := *ptr;
            }}}





Treating top level declarations differently:
    Currently, top level declarations are treated special, as they would correspond to
    the structure of the WASM that would be generated. For example,

        inc :: proc (a: i32) -> i32 { return a + 1; }

    would be turned into an AstFunction node with a token of 'inc', and,

        global :: 5

    would be turned into a AstGlobal node with a token of 'global'.

    The problem I have with this approach is it creates an inconsistency when thinking
    about what is going on in the various stages in the compiler.

    A better approach would be to have a AstBinding node, that represents a binding
    from a symbol, stored on the token member, to another Ast Node. The node definition
    would be:

        struct AstBinding { AstTyped base; AstNode* node; }

    For a function definition such as 'inc' above, the node structure would look like:

        AstBinding (inc)
            .node -> AstFunction
                        .params -> AstLocal (a) -> NULL
                        .body -> ...

    This way, in symbol resolution, the top level bindings are added to the table and
    there are no special cases.

    Other nuances:

        global :: 5     - This would replace all instances of 'global' with the integer constant
                            5. This would not make a global in WASM.

        global :: i32   - This would work as a type alias. 'global' would have the type node as it's 'node'

        print :: proc #foriegn "host" "print" (...) ---


Explicit overriden functions:
    Considered syntax:

        foo_i32 :: proc (val: i32) -> i32 ---
        foo_i64 :: proc (val: i64) -> i64 ---
        foo_f32 :: proc (val: f32) -> f32 ---
        foo_f64 :: proc (val: f64) -> f64 ---

        foo :: proc #overload {
            foo_i32, foo_i64, foo_f32, foo_f64
        }

        foo(10);        // calls foo_i32
        foo(2.0f);      // calls foo_f32


        min_f32 :: proc #intrinsic (a: f32, b:f32) -> f32 ---
        min_f64 :: proc #intrinsic (a: f64, b:f64) -> f64 ---

        min_i32 :: proc (a: i32, b: i32) -> i32 {
            least := a;
            if b < a { least = b; }

            return least;
        }

        min_i64 :: proc (a: i64, b: i64) -> i64 {
            least := a;
            if b < a { least = b; }

            return least;
        }

        min :: proc #overload { min_i32, min_i64, min_f32, min_f64 }

        min(2, 5);
        min(4.5, 10.4);


