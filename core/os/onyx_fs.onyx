package runtime.fs

use package core

FileData :: struct {
    Handle :: #distinct i64

    handle: Handle = -1;
}

__file_open :: (path: str, mode := os.OpenMode.Read) -> (FileData, os.FileError) {
    handle: FileData.Handle;
    error := __file_open_impl(path, mode, ^handle);

    fd := FileData.{ handle };
    return fd, error;
}

#foreign "onyx_runtime" {
    __file_open_impl :: (path: str, mode: os.OpenMode, out_handle: ^FileData.Handle) -> os.FileError ---

    __file_close :: (fd: FileData) -> os.FileError ---
    __file_exists :: (path: str) -> bool ---

    __file_seek  :: (handle: FileData.Handle, to: i32, whence: io.SeekFrom) -> i32 ---
    __file_tell  :: (handle: FileData.Handle) -> u32 ---
    __file_read  :: (handle: FileData.Handle, output_buffer: [] u8, bytes_read: ^u64) -> io.Error ---
    __file_write :: (handle: FileData.Handle, input_buffer: [] u8, bytes_wrote: ^u64) -> io.Error ---
    __file_flush :: (handle: FileData.Handle) -> io.Error ---
}

__file_stream_vtable := io.Stream_Vtable.{
    seek = (use fs: ^os.File, to: i32, whence: io.SeekFrom) -> io.Error {
        now := __file_seek(data.handle, to, whence);
        return (.None) if now >= 0 else .BadFile;
    },

    tell = (use fs: ^os.File) -> (io.Error, u32) {
        return .None, __file_tell(data.handle);
    },

    read = (use fs: ^os.File, buffer: [] u8) -> (io.Error, u32) {
        bytes_read: u64;
        error := __file_read(data.handle, buffer, ^bytes_read);
        return error, ~~bytes_read;
    },

    read_at = (use fs: ^os.File, at: u32, buffer: [] u8) -> (io.Error, u32) {
        __file_seek(data.handle, at, .Start);
        bytes_read: u64;
        error := __file_read(data.handle, buffer, ^bytes_read);
        return error, ~~bytes_read;
    },

    read_byte = (use fs: ^os.File) -> (io.Error, u8) {
        byte: u8;
        error := __file_read(data.handle, ~~ cast([1] u8) ^byte, null);
        return error, byte;
    },

    write = (use fs: ^os.File, buffer: [] u8) -> (io.Error, u32) {
        bytes_wrote: u64;
        error := __file_write(data.handle, buffer, ^bytes_wrote);
        return error, ~~bytes_wrote;
    },

    write_at = (use fs: ^os.File, at: u32, buffer: [] u8) -> (io.Error, u32) {
        __file_seek(data.handle, at, .Start);
        bytes_wrote: u64;
        error := __file_write(data.handle, buffer, ^bytes_wrote);
        return error, ~~bytes_wrote;
    },

    write_byte = (use fs: ^os.File, byte: u8) -> io.Error {
        b := byte;
        error := __file_write(data.handle, .{ ^b, 1 }, null);
        return error;
    },

    close = (use fs: ^os.File) -> io.Error {
        __file_close(data);
        return .None;
    },

    flush = (use fs: ^os.File) -> io.Error {
        return __file_flush(data.handle);
    },

    size = (use fs: ^os.File) -> i32 {
    },
};

