package core.os

#if runtime.Runtime != runtime.Runtime_Onyx {
    #error "This file can only be included in the 'onyx' runtime, because Wasi has not defined how to spawn and manage processes.";
}

#local {
    runtime :: package runtime
    io      :: package core.io
}

Process :: struct {
    Handle :: #distinct i64;

    use stream: io.Stream;
    process_handle: Handle;
}

process_spawn :: (path: str, args: [] str, non_blocking_io := false) -> Process {
    handle := __process_spawn(path, args, non_blocking_io);

    return .{
        .{ ^process_stream_vtable },
        handle,
    };
}

process_kill :: (use p: ^Process) -> bool {
    return __process_kill(process_handle);
}

process_wait :: (use p: ^Process) => {
    return __process_wait(process_handle);
}

process_destroy :: (use p: ^Process) => {
    __process_destroy(process_handle);
}

#local process_stream_vtable := io.Stream_Vtable.{
    read = (use p: ^Process, buffer: [] u8) -> (io.Error, u32) {
        // Read from the process stdout
        if cast(i64) process_handle == 0 do return .BadFile, 0;

        bytes_read := __process_read(process_handle, buffer);
        return .None, bytes_read;
    },

    write = (use p: ^Process, buffer: [] u8) -> (io.Error, u32) {
        // Write to the process stdin
        if cast(i64) process_handle == 0 do return .BadFile, 0;

        bytes_written := __process_write(process_handle, buffer);
        return .None, bytes_written;
    },

    close = (use p: ^Process) -> io.Error {
        process_kill(p);
        return .None;
    }
}

#local ProcessResult :: enum {
    Success     :: 0x00;
    FailedToRun :: 0x01;
    Error       :: 0x02;
    InternalErr :: 0x03;
}

#foreign "onyx_runtime" {
    __process_spawn   :: (path: str, args: [] str, non_blocking_io: bool) -> Process.Handle ---
    __process_read    :: (handle: Process.Handle, buffer: [] u8) -> i32 ---
    __process_write   :: (handle: Process.Handle, buffer: [] u8) -> i32 ---
    __process_kill    :: (handle: Process.Handle) -> bool ---
    __process_wait    :: (handle: Process.Handle) -> ProcessResult ---
    __process_destroy :: (handle: Process.Handle) -> void ---
}

