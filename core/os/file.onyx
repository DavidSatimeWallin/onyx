package core.os

use core
use runtime {fs}

FileError :: enum {
    None       :: 0x00;
    NotFound   :: 0x01;
    Exists     :: 0x02;
    Permission :: 0x03;
    BadFile    :: 0x04;
    BadMode    :: 0x05;
}

OpenMode :: enum {
    Invalid :: 0x00;
    Read    :: 0x01;
    Write   :: 0x02;
    Append  :: 0x03;
}

File :: struct {
    use stream : io.Stream;
    data   : fs.FileData;
}

// Most of these types were stollen directly from
// man readdir(3), and the most reasonable types
// were used for Windows.
FileType :: enum {
    Unknown     :: 0x00;
    Block       :: 0x01;
    Char        :: 0x02;
    Directory   :: 0x03;
    RegularFile :: 0x04;
    SymLink     :: 0x05;
    Other       :: 0x06;
}

//
// This is fairly minimal for right now.
FileStat :: struct {
    size: i64;
    type: FileType;
}

file_exists :: fs.__file_exists
file_stat   :: fs.__file_stat
remove_file :: fs.__file_remove
rename_file :: fs.__file_rename

get_contents_from_file :: (file: ^File) -> str {
    size := cast(u32) io.stream_size(file);

    data := cast(^u8) raw_alloc(context.allocator, size);

    _, prev_loc := io.stream_tell(file);
    io.stream_seek(file, 0, .Start);

    io.stream_read(file, .{ data, size });

    io.stream_seek(file, prev_loc, .Start);

    return data[0 .. size];
}

open :: (path: str, mode := OpenMode.Read) -> (os.FileError, File) {
    file := File.{
        stream = .{ vtable = null },
        data   = .{},
    };

    file_data, error := fs.__file_open(path, mode);
    if error != .None do return error, file;

    file.data = file_data;
    file.vtable = ^fs.__file_stream_vtable;
    return .None, file;
}

close :: (file: ^File) {
    fs.__file_close(file.data);
    file.stream.vtable = null;
}

get_contents :: #match {
    get_contents_from_file,

    (path: str) -> str {
        error, file := open(path, .Read);
        if error != .None do return .{ null, 0 };
        defer close(^file);

        return get_contents(^file);
    }
}

with_file :: (path: str, mode := OpenMode.Read) -> Iterator(^File) {
    Context :: struct {
        valid_file_stream := false;

        file_stream: File;
    }

    c := new(Context);
    if err, file_stream := open(path, mode); err == .None {
        c.file_stream = file_stream;
        c.valid_file_stream = true;
    }

    next :: (use c: ^Context) -> (^File, bool) {
        if !valid_file_stream do return null, false;

        defer valid_file_stream = false;
        return ^file_stream, true;
    }

    close_context :: (use c: ^Context) {
        close(^file_stream);
        cfree(c);
    }

    return .{ c, next, close_context };
}

is_file :: (path: str) -> bool {
    s: FileStat;
    if !file_stat(path, ^s) do return false;
    return s.type == .RegularFile;
}

is_directory :: (path: str) -> bool {
    s: FileStat;
    if !file_stat(path, ^s) do return false;
    return s.type == .Directory;
}


file_logger_open :: (filename: str, allocator := context.allocator) -> Logger {
    file := new(File, allocator);

    error := os.FileError.None;
    error, *file = open(filename, mode=.Append);
    assert(error != .None, "Unable to open file for logging.");

    return .{ file_logger_proc, file };
}

file_logger_close :: (logger := context.logger) {
    close(cast(^File) logger.data);

    // @Robustness: this could be the wrong allocator if the context allocator wasn't used.    
    cfree(logger.data);
}

#local
file_logger_proc :: (data: ^File, level: Log_Level, msg: str, module: str) {
    writer := io.writer_make(data, 0);
    io.write(^writer, msg);
    io.write(^writer, "\n");
}
