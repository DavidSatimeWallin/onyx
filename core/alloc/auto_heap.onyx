package core.alloc.heap

AutoHeapState :: struct {
    backing_allocator: Allocator;
    set := Set(rawptr).{};
}

#local auto_heap_alloc_proc :: (data: ^AutoHeapState, aa: AllocationAction, size: u32, align: u32, oldptr: rawptr) -> rawptr {
    newptr := data.backing_allocator.func(data.backing_allocator.data, aa, size, align, oldptr);

    switch aa {
        case .Alloc {
            if newptr != null {
                data.set->insert(newptr);
            }
        }

        case .Resize {
            data.set->remove(oldptr);

            if newptr != null {
                data.set->insert(newptr);
            }
        }

        case .Free {
            data.set->remove(oldptr);
        }
    }

    return newptr;
}

auto_heap_make :: (backing := context.allocator) -> AutoHeapState {
    hs: AutoHeapState;
    hs.backing_allocator = backing;
    hs.set->init(allocator = backing);
    return hs;
}

auto_heap_clear :: (hs: ^AutoHeapState) {
    for^ hs.set.entries {
        raw_free(hs.backing_allocator, it.value);
    }

    hs.set->clear();
}

auto_heap_free :: (hs: ^AutoHeapState) {
    auto_heap_clear(hs);
    hs.set->free();
}

#match core.alloc.as_allocator auto_heap_make_allocator
auto_heap_make_allocator :: (hs: ^AutoHeapState) -> Allocator {
    return Allocator.{
        func = auto_heap_alloc_proc,
        data = hs
    };
}

auto :: #match {
    macro () {
        use core.alloc {heap}
        
        auto_heap := heap.auto_heap_make();
        old_allocator := context.allocator;
        context.allocator = heap.auto_heap_make_allocator(^auto_heap);
        defer {
            heap.auto_heap_free(^auto_heap);
            context.allocator = old_allocator;
        }
    },

    macro (body: Code) -> i32 {
        auto :: auto

        #context_scope {
            auto(); 
            #unquote body;
        }

        return 0;
    }
}
