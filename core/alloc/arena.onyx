package core.alloc.arena

// This allocator is great for when you need to do bunch of
// allocations is a small amount of time. Much like the Ring
// allocator, it simply bumps up a pointer as you allocate
// memory. Unlike the Ring allocator, it does not wrap around,
// meaning you can run of out of memory, so make sure the buffer
// provided has enough space for what you are going to do.

ArenaState :: struct {
    base_ptr : rawptr;
    size     : u32;
    curr_ptr : rawptr;
}

#private_file
arena_alloc_proc :: proc (data: rawptr, aa: AllocationAction, size: u32, align: u32, oldptr: rawptr) -> rawptr {
    ss := cast(^ArenaState) data;

    if aa == AllocationAction.Alloc {
        retval := null;
        rem := ss.size - cast(u32) ss.curr_ptr + cast(u32) ss.base_ptr;

        if size <= rem {
            retval = ss.curr_ptr;
            ss.curr_ptr = cast(rawptr) (cast(u32) ss.curr_ptr + size);
        } else {
        	// Not enough space for the allocation
        	retval = null;
        }

        return retval;
    }

    return null;
}

make :: proc (buffer: rawptr, length: u32) -> ArenaState {
	return ArenaState.{
	    base_ptr = buffer,
	    curr_ptr = buffer,
	    size     = length,
	};
}

make_allocator :: proc (rs: ^ArenaState) -> Allocator {
	return Allocator.{
		func = ring_alloc_proc,
		data = rs,
	};
}

reset :: proc (arena: ^ArenaState) {
	arena.curr_ptr = arena.base_ptr;
}