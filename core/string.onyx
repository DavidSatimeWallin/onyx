package core.string

make :: proc (s: cstr) -> str {
    len :: length(s);

    return str.{ count = len, data = s };
}

length :: proc {
    proc (s: cstr) -> u32 {
        len := 0;
        c := s;
        while *c != #char "\0" {
            len += 1;
            c += 1;
        }

        return len;
    },

    proc (s: str) -> u32 {
        return s.count;
    },
}

alloc_copy :: proc (orig: str) -> str {
    new_str : str;
    new_str.data = calloc(sizeof u8 * orig.count);
    new_str.count = orig.count;
    copy(orig, new_str);
    return new_str;
}

copy :: proc (orig: str, dest: str) {
    len := orig.count;
    if dest.count < len do len = dest.count;

    for i: 0 .. len do dest.data[i] = orig.data[i];
}

concat :: proc (s1: str, s2: str) -> str {
    len1 :: length(s1);
    len2 :: length(s2);

    data := cast(^u8) calloc(len1 + len2);
    for i: 0 .. len1 do data[i]        = s1[i];
    for i: 0 .. len2 do data[i + len1] = s2[i];

    return str.{ data, len1 + len2 };
}

free :: proc (s: str) do cfree(s.data);

// This is an example doc str
// You can have as many comments as you want
// It documents the split function
split :: proc (s: str, delim: u8) -> []str {
    delim_count := 0;
    for i: 0 .. s.count do if s[i] == delim do delim_count += 1;

    strarr := cast(^str) calloc(sizeof str * (delim_count + 1));

    curr_str := 0;
    begin := 0;

    for i: 0 .. s.count {
        if s[i] == delim {
            strarr[curr_str] = s.data[begin .. i];
            begin = i + 1;
            curr_str += 1;
        }
    }

    strarr[curr_str] = s.data[begin .. s.count];

    return strarr[0 .. delim_count + 1];
}

// substr :: proc (s: str, sub: str) -> str {
//     for i: 0 .. str.count {
//         while j := 0; j < sub.count && str[i + j] == sub[j] {
//             j += 1;
// 
//             if j == sub.count do return str.data[i .. i + j];
//         }
//     }
// 
//     return str.data[0 .. 0];
// }

contains :: proc (s: str, c: u8) -> bool {
    for ch: s do if ch == c do return true;
    return false;
}

// compare :: proc (str1: str, str2: str) -> i32 {
//     if str1.count != str2.count do return str1.count - str2.count;
//
//     i := 0;
//     while i < str1.count && str1[i] == str2[i] do i += 1;
//
//     if i == str1.count do return 0;
//     return ~~(str1[i] - str2[i]);
// }

equal :: proc (str1: str, str2: str) -> bool {
    if str1.count != str2.count do return false;
    while i := 0; i < str1.count {
        if str1[i] != str2[i] do return false;
        i += 1;
    }
    return true;
}

starts_with :: proc (str1: str, str2: str) -> bool {
    if str1.count < str2.count do return false;
    while i := 0; i < str2.count {
        if str1[i] != str2[i] do return false;
        i += 1;
    }
    return true;
}

strip_leading_whitespace :: proc (s: ^str) {
    while true do switch s.data[0] {
        case #char " ", #char "\t", #char "\n", #char "\r" {
            s.data += 1;
            s.count -= 1;
        }

        case #default do return;
    }
}

strip_trailing_whitespace :: proc (s: ^str) {
    while true do switch s.data[s.count - 1] {
        case #char " ", #char "\t", #char "\n", #char "\r" {
            s.count -= 1;
        }

        case #default do return;
    }
}




//
// String Builder
//
StringBuilder :: struct {
    alloc : Allocator;

    data  : ^u8 = null;
    len   : u32 = 0;
    cap   : u32 = 0;
}

builder_make :: proc (initial_cap: u32) -> StringBuilder {
    data: ^u8 = null;

    if initial_cap > 0 {
        data = cast(^u8) calloc(initial_cap);
    }

    return StringBuilder.{
        alloc = context.allocator,
        data  = data,
        cap   = initial_cap,
    };
}

builder_add_str :: proc (use sb: ^StringBuilder, s: str) -> ^StringBuilder {
    len_total :: len + s.count;

    if cap >= len_total {
        for i: 0 .. s.count do data[len + i] = s[i];
        len += s.count;
        return sb;
    }

    new_cap := cap;
    while new_cap < len_total do new_cap <<= 1;

    new_data := cast(^u8) resize(alloc, data, new_cap);
    if new_data == null do return sb;

    data = new_data;
    cap = new_cap;

    for i: 0 .. s.count do data[len + i] = s[i];
    len += s.count;
    return sb;
}

builder_add_cstr :: proc (use sb: ^StringBuilder, cstring: cstr) -> ^StringBuilder {
    s := make(cstring);
    return builder_add_str(sb, s);
}

i64_to_str :: proc (n_: i64, base: u64, buf: Buffer) -> str {
    n := cast(u64) n_;

    is_neg := false;
    if n_ < 0 && base == 10 {
        is_neg = true;
        n = cast(u64) -n_;
    }

    c := ^(cast(^u8) buf.data)[buf.count - 1];
    len := 0;

    s :: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/";

    while n > 0 {
        m :: n % base;

        *c = s[cast(u32) m];
        len += 1;
        c -= 1;

        n /= base;

    } else {
        *c = #char "0";
        len += 1;
        c -= 1;
    }

    if base == 16 {
        *c = #char "x";
        len += 1;
        c -= 1;
        *c = #char "0";
        len += 1;
        c -= 1;
    }

    if base == 2 {
        *c = #char "b";
        len += 1;
        c -= 1;
        *c = #char "0";
        len += 1;
        c -= 1;
    }

    if is_neg {
        *c = #char "-";
        len += 1;
        c -= 1;
    }

    return str.{ data = c + 1, count = len };
}

// NOTE: This is a big hack but it will work for now
f64_to_str :: proc (f: f64, buf: [] u8) -> str {
    a := f;
    a *= 10000.0;
    v := cast(i64) a;

    b := Buffer.{ cast(^void) buf.data, buf.count };
    len := 0;

    s1 := i64_to_str(v / 10000, 10, b);
    for i: 0 .. s1.count do buf.data[i] = s1.data[i];
    buf.data[s1.count] = #char ".";
    len = s1.count + 1;

    if v < ~~0 do v = -v;
    s2 := i64_to_str(v % 10000, 10, b);
    for i: 0 .. s2.count do buf.data[s1.count + 1 + i] = s2.data[i];
    len += s2.count;

    return str.{ buf.data, len };
}

builder_add_i64 :: proc (use sb: ^StringBuilder, n: i64, base: u64 = 10) -> ^StringBuilder {
    buf : [256] u8;
    s := i64_to_str(n, base, Buffer.{ cast(^void) buf, 256 });
    return builder_add_str(sb, s);
}

builder_add_f64 :: proc (use sb: ^StringBuilder, f: f64) -> ^StringBuilder {
    buf : [256] u8;
    s := f64_to_str(f, buf[0 .. 256]);
    return builder_add_str(sb, s);
}

builder_add_bool :: proc (use sb: ^StringBuilder, b: bool) -> ^StringBuilder {
    if b {
        return builder_add_str(sb, "true");
    } else {
        return builder_add_str(sb, "false");
    }

    return null;
}

builder_append :: proc {
    builder_add_str,
    builder_add_cstr,
    builder_add_i64,
    builder_add_f64,
    builder_add_bool,
}

builder_to_str :: proc (use sb: ^StringBuilder) -> str {
    return str.{ data, len };
}

builder_clear :: proc (use sb: ^StringBuilder) -> ^StringBuilder {
    len = 0;
    return sb;
}

read_u32 :: proc (s: ^str, out: ^u32) {
    n := 0;

    strip_leading_whitespace(s);
    while s.data[0] >= #char "0" && s.data[0] <= #char "9" {
        n *= 10;
        n += cast(u32) (s.data[0] - #char "0");

        s.data += 1;
        s.count -= 1;
    }

    *out = n;
}

read_char :: proc (s: ^str, out: ^u8) {
    *out = s.data[0];
    s.data += 1;
    s.count -= 1;
}

read_chars :: proc (s: ^str, out: ^str, char_count := 1) {
    out.data = s.data;
    out.count = char_count;
    s.data += char_count;
    s.count -= char_count;
}

discard_chars :: proc (s: ^str, char_count := 1) {
    s.data += char_count;
    s.count -= char_count;
}

// Goes up to but not including the closest newline or EOF
read_line :: proc (s: ^str, out: ^str) {
    out.data = s.data;
    out.count = 0;

    for ch: *s {
        if ch == #char "\n" do break;
        out.count += 1;
    }

    s.data += out.count;
    s.count -= out.count;

    if s.count > 0 {
        s.data += 1;
        s.count -= 1;
    }
}

read_until :: proc (s: ^str, upto: u8, skip := 0) -> str {
    if s.count == 0 do return "";

    out : str;
    out.data = s.data;
    out.count = 0;

    rem := skip;
    for ch: *s {
        if ch == upto {
            if rem <= 0 do break;
            else do rem -= 1;
        }

        out.count += 1;
    }

    s.data += out.count;
    s.count -= out.count;

    return out;
}

read_until_either :: proc (s: ^str, skip: u32, uptos: ..u8) -> str {
    if s.count == 0 do return "";

    out : str;
    out.data = s.data;
    out.count = 0;

    rem := skip;
    for ch: *s {
        for upto: uptos {
            if ch == upto {
                if rem <= 0 do break break;
                else do rem -= 1;
            }
        }

        out.count += 1;
    }

    s.data += out.count;
    s.count -= out.count;

    return out;
}

advance_line :: proc (s: ^str) {
    if s.count == 0 do return;

    adv := 0;
    while s.data[adv] != #char "\n" do adv += 1;

    s.data += adv + 1;
    s.count -= adv + 1;
}

read :: proc {
    read_u32, read_char
}
