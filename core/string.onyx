package core

string_make :: proc #overloaded { string_make_from_cstring }

#private
string_make_from_cstring :: proc (s: cstring) -> string {
    len :: string_length(s);

    return string.{ count = len, data = s };
}

string_length :: proc #overloaded {
    proc (s: ^u8) -> u32 {
        len := 0;
        c := s;
        while *c != #char "\0" {
            len += 1;
            c += 1;
        }

        return len;
    },

    proc (s: string) -> u32 {
        return s.count;
    },
}

string_concat :: proc (s1: string, s2: string) -> string {
    len1 :: string_length(s1);
    len2 :: string_length(s2);

    data := cast(^u8) calloc(len1 + len2);
    for i: 0 .. len1 do data[i]        = s1[i];
    for i: 0 .. len2 do data[i + len1] = s2[i];

    return string.{ data, len1 + len2 };
}

string_free :: proc (s: string) do cfree(s.data);

// This is an example doc string
// You can have as many comments as you want
// It documents the string_split function
string_split :: proc (str: string, delim: u8) -> []string {
    delim_count := 0;
    for i: 0 .. str.count do if str[i] == delim do delim_count += 1;

    strarr := cast(^string) calloc(sizeof string * (delim_count + 1));

    curr_str := 0;
    begin := 0;

    for i: 0 .. str.count {
        if str[i] == delim {
            strarr[curr_str] = str.data[begin .. i];
            begin = i + 1;
            curr_str += 1;
        }
    }

    strarr[curr_str] = str.data[begin .. str.count];

    return strarr[0 .. delim_count + 1];
}

string_substr :: proc (str: string, sub: string) -> string {
    for i: 0 .. str.count {
        while j := 0; j < sub.count && str[i + j] == sub[j] {
            j += 1;

            if j == sub.count do return str.data[i .. i + j];
        }
    }

    return str.data[0 .. 0];
}

string_contains :: proc (str: string, c: u8) -> bool {
    for i: 0 .. str.count do if str[i] == c do return true;
    return false;
}

string_strip_leading_whitespace :: proc (str: ^string) {
    while true do switch str.data[0] {
        case #char " ", #char "\t", #char "\n", #char "\r" {
            str.data += 1;
            str.count -= 1;
        }

        case #default do return;
    }
}

string_strip_trailing_whitespace :: proc (str: ^string) {
    while true do switch str.data[str.count - 1] {
        case #char " ", #char "\t", #char "\n", #char "\r" {
            str.count -= 1;
        }

        case #default do return;
    }
}




//
// String Builder
//
StringBuilder :: struct {
    alloc : Allocator;

    data  : ^u8 = null;
    len   : u32 = 0;
    cap   : u32 = 0;
}

string_builder_make :: proc (initial_cap: u32) -> StringBuilder {
    data: ^u8 = null;

    if initial_cap > 0 {
        data = cast(^u8) calloc(initial_cap);
    }

    return StringBuilder.{
        alloc = context.allocator,
        data  = data,
        cap   = initial_cap,
    };
}

string_builder_add_string :: proc (use sb: ^StringBuilder, str: string) -> ^StringBuilder {
    len_total :: len + str.count;

    if cap >= len_total {
        for i: 0 .. str.count do data[len + i] = str[i];
        len += str.count;
        return sb;
    }

    new_cap := cap;
    while new_cap < len_total do new_cap <<= 1;

    new_data := cast(^u8) resize(alloc, data, new_cap);
    if new_data == null do return sb;

    data = new_data;
    cap = new_cap;

    for i: 0 .. str.count do data[len + i] = str[i];
    len += str.count;
    return sb;
}

string_builder_add_cstring :: proc (use sb: ^StringBuilder, cstr: cstring) -> ^StringBuilder {
    s := string_make(cstr);
    return string_builder_add_string(sb, s);
}

i64_to_string :: proc (n_: i64, base: u64, buf: Buffer) -> string {
    n := cast(u64) n_;

    is_neg := false;
    if n_ < 0l && base == 10l {
        is_neg = true;
        n = cast(u64) -n_;
    }

    str :: cast(^u8) buf.data;
    for i: 0 .. buf.count do str[i] = #char "\0";

    c := cast(^u8) ^str[buf.count - 1];
    len := 0;

    s :: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/";

    while n > 0l {
        m :: n % base;

        *c = s[cast(u32) m];
        len += 1;
        c -= 1;

        n /= base;

    } else {
        *c = #char "0";
        len += 1;
        c -= 1;
    }

    if base == 16l {
        *c = #char "x";
        len += 1;
        c -= 1;
        *c = #char "0";
        len += 1;
        c -= 1;
    }

    if base == 2l {
        *c = #char "b";
        len += 1;
        c -= 1;
        *c = #char "0";
        len += 1;
        c -= 1;
    }

    if is_neg {
        *c = #char "-";
        len += 1;
        c -= 1;
    }

    return string.{ data = c + 1, count = len };
}

string_builder_add_i64 :: proc (use sb: ^StringBuilder, n: i64, base := 10l) -> ^StringBuilder {
    buf : [256] u8;
    s := i64_to_string(n, base, Buffer.{ cast(^void) buf, 256 });
    return string_builder_add_string(sb, s);
}

string_builder_add_bool :: proc (use sb: ^StringBuilder, b: bool) -> ^StringBuilder {
    if b {
        return string_builder_add_string(sb, "true");
    } else {
        return string_builder_add_string(sb, "false");
    }

    return null;
}

string_builder_append :: proc #overloaded {
    string_builder_add_string,
    string_builder_add_cstring,
    string_builder_add_i64,
    string_builder_add_bool,
}

string_builder_to_string :: proc (use sb: ^StringBuilder) -> string {
    return string.{ data, len };
}

string_builder_clear :: proc (use sb: ^StringBuilder) -> ^StringBuilder {
    len = 0;
    return sb;
}

string_read_u32 :: proc (str: ^string, out: ^u32) {
    n := 0;

    string_strip_leading_whitespace(str);
    while str.data[0] >= #char "0" && str.data[0] <= #char "9" {
        n *= 10;
        n += cast(u32) (str.data[0] - #char "0");

        str.data += 1;
        str.count -= 1;
    }

    *out = n;
}

string_read_char :: proc (str: ^string, out: ^u8) {
    *out = str.data[0];
    str.data += 1;
    str.count -= 1;
}

// Goes up to but not including the closest newline or EOF
string_read_line :: proc (str: ^string, out: ^string) {
    out.data = str.data;
    out.count = 0;

    for i: 0 .. str.count {
        if str.data[i] == #char "\n" do break;
        out.count += 1;
    }

    str.data += out.count;
    str.count -= out.count;
}

string_advance_line :: proc (str: ^string) {
    adv := 0;
    while str.data[adv] != #char "\n" do adv += 1;

    str.data += adv;
    str.count -= adv;
}

string_read :: proc #overloaded {
    string_read_u32, string_read_char
}
