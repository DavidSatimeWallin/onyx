package core
// Currently, these symbols are dumped in the 'core' namespace, which means
// most programs that just 'use package core' can access all of them, which
// is convenient; However, it doesn't hurt to wonder if they should be the
// 'core.io' package so these would become like 'io.printf(...)'. Of course,
// you could always still do 'use package core.io', which would bring these
// in anyway.


#private_file runtime :: package runtime
#if runtime.Runtime == runtime.Runtime_Custom {
    #error "'stdio' can only be included in the 'wasi' or 'js' runtime."
}

auto_flush_stdio := true

print :: proc {
    (x: str) {
        io.write(^print_writer, x);
        if x[x.count - 1] == #char "\n" && auto_flush_stdio do __flush_stdio();
    },

    (x: $T)        { io.write(^print_writer, x); },
    (x: $T, y: $R) { io.write(^print_writer, x, y); },
}

println :: (x: $T) {
    print(x);
    print("\n");
}

printf :: (format: str, va: ...) {
    buffer: [2048] u8;
    print(conv.str_format_va(format, buffer[0 .. 2048], va));
}

// This works on both slices and arrays
print_array :: proc {
    (arr: [$N] $T, sep := " ") {
        for i: 0 .. N {
            print(arr[i]);
            if i != N - 1 do print(sep);
        }

        print("\n");
    },

    (arr: $T, sep := " ") {
        for i: 0 .. arr.count {
            print(arr.data[i]);
            if i != arr.count - 1 do print(sep);
        }

        print("\n");
    }
}


//
// Private and internal things
//

#private_file print_stream : io.DynamicStringStream;
#private_file print_writer : io.Writer;

__stdio_init :: () {
    print_stream = io.dynamic_string_stream_make(2048, context.allocator);
    print_writer = io.writer_make(^print_stream);
}


__flush_stdio :: () {
    if print_stream.data.count == 0 do return;

    ^print_stream
        |> io.dynamic_string_stream_to_str()
        |> runtime.__output_string();

    ^print_stream |> io.stream_flush();
}

