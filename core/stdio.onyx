package core
// Currently, these symbols are dumped in the 'core' namespace, which means
// most programs that just 'use package core' can access all of them, which
// is convenient; However, it doesn't hurt to wonder if they should be the
// 'core.io' package so these would become like 'io.printf(...)'. Of course,
// you could always still do 'use package core.io', which would bring these
// in anyway.


// It is expected that a file will be included that will be part
// of the system package
use package system as system

#private_file print_buffer : string.builder.Builder;

stdio_init :: proc () {
    print_buffer = string.builder.make(2048);
}

print_str  :: proc (s: str) {
    string.builder.append(^print_buffer, s);
    if s.data[s.count - 1] == #char "\n" do print_buffer_flush();
}

print_cstr :: proc (s: cstr)                do string.builder.append(^print_buffer, s);
print_i64  :: proc (n: i64, base: u64 = 10) do string.builder.append(^print_buffer, n, base);
print_i32  :: proc (n: i32, base: u32 = 10) do string.builder.append(^print_buffer, cast(i64) n, cast(u64) base);
print_f64  :: proc (n: f64)                 do string.builder.append(^print_buffer, n);
print_f32  :: proc (n: f32)                 do string.builder.append(^print_buffer, cast(f64) n);
print_bool :: proc (b: bool)                do string.builder.append(^print_buffer, b);
print_ptr  :: proc (p: ^void)               do string.builder.append(^print_buffer, cast(i64) p, cast(u64) 16);

print_range :: proc (r: range, sep := " ") {
    for i: r {
        print(i);
        if i + r.step < r.high do print(sep);
    }
    print("\n");
}

print :: proc {
    print_str,    print_cstr,
    print_i64,    print_i32,
    print_f64,    print_f32,
    print_bool,   print_ptr,
    print_range,
}

println :: proc (x: $T) {
    print(x);
    print("\n");
}

printf :: proc (format: str, va: ...) {
    buffer: [2048] u8;
    print(conv.str_format_va(format, buffer[0 .. 2048], va));
}

// This works on both slices and arrays
print_array :: proc (arr: $T, sep := " ") {
    for i: 0 .. arr.count {
        print(arr.data[i]);
        if i != arr.count - 1 do print(sep);
    }

    print("\n");
}

print_buffer_flush :: proc () {
    if print_buffer.data.count == 0 do return;

    ^print_buffer
        |> string.builder.to_str()
        |> system.output_str();

    ^print_buffer |> string.builder.clear();
}

