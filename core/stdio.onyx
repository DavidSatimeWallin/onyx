package core

// It is expected that a file will be included that will be part
// of the system package
use package system as system

#private_file print_buffer : str.StringBuilder;

stdio_init :: proc () {
    print_buffer = str.builder_make(2048);
}

print_string  :: proc (s: string) {
    str.builder_append(^print_buffer, s);
    if s.data[s.count - 1] == #char "\n" do print_buffer_flush();
}

print_cstring :: proc (s: cstring)          do str.builder_append(^print_buffer, s);
print_i64     :: proc (n: i64, base := 10l) do str.builder_append(^print_buffer, n, base);
print_i32     :: proc (n: i32, base := 10)  do str.builder_append(^print_buffer, cast(i64) n, cast(u64) base);
print_f64     :: proc (n: f64)              do str.builder_append(^print_buffer, n);
print_f32     :: proc (n: f32)              do str.builder_append(^print_buffer, cast(f64) n);
print_bool    :: proc (b: bool)             do str.builder_append(^print_buffer, b);
print_ptr     :: proc (p: ^void)            do str.builder_append(^print_buffer, cast(i64) p, 16l);

print_range :: proc (r: range, sep := " ") {
    for i: r {
        print(i);
        if i + r.step < r.high do print(sep);
    }
    print("\n");
}

print :: proc {
    print_string, print_cstring,
    print_i64,    print_i32,
    print_f64,    print_f32,
    print_bool,   print_ptr,
    print_range,
}

println :: proc (x: $T) {
    print(x);
    print("\n");
}

printf :: proc (format: string, va: ...) {
    buffer: [2048] u8;
    len := 0;

    state := 0;
    for ch: format do switch (state) {
        case 0 {
            if ch == #char "%" do state = 1;
            else {
                buffer[len] = ch;
                len += 1;
            }
        }

        case #default {
            switch (ch) {
                case #char "%" { buffer[len] = ch; len += 1; }

                case #char "i" {
                    n : i32;
                    if !vararg_get(va, ^n) do return;

                    ibuf : [128] u8;
                    istr := str.i64_to_string(~~n, 10l, Buffer.{ ~~ibuf, 128 });

                    for a: istr {
                        buffer[len] = a;
                        len += 1;
                    }
                }

                case #char "l" {
                    n : i64;
                    if !vararg_get(va, ^n) do return;

                    ibuf : [128] u8;
                    istr := str.i64_to_string(n, 10l, Buffer.{ ~~ibuf, 128 });

                    for a: istr {
                        buffer[len] = a;
                        len += 1;
                    }
                }

                case #char "f" {
                    n : f32;
                    if !vararg_get(va, ^n) do return;

                    fbuf : [128] u8;
                    fstr := str.f64_to_string(~~n, fbuf[0 .. 128]);

                    for a: fstr {
                        buffer[len] = a;
                        len += 1;
                    }
                }

                case #char "d" {
                    n : f64;
                    if !vararg_get(va, ^n) do return;

                    fbuf : [128] u8;
                    fstr := str.f64_to_string(n, fbuf[0 .. 128]);

                    for a: fstr {
                        buffer[len] = a;
                        len += 1;
                    }
                }

                case #char "s" {
                    str : string;
                    if !vararg_get(va, ^str) do return;

                    for a: str {
                        buffer[len] = a;
                        len += 1;
                    }
                }

                case #char "p" {
                    n : rawptr;
                    if !vararg_get(va, ^n) do return;

                    ibuf : [128] u8;
                    istr := str.i64_to_string(~~n, 16l, Buffer.{ ~~ibuf, 128 });

                    for a: istr {
                        buffer[len] = a;
                        len += 1;
                    }
                }
            }

            state = 0;
        }
    }

    print(string.{ ~~buffer, len });
}

// This works on both slices and arrays
print_array :: proc (arr: $T, sep := " ") {
    for i: 0 .. arr.count {
        print(arr.data[i]);
        if i != arr.count - 1 do print(sep);
    }

    print("\n");
}

print_buffer_flush :: proc () {
    if print_buffer.len == 0 do return;

    ^print_buffer
        |> str.builder_to_string()
        |> system.output_string();

    ^print_buffer |> str.builder_clear();
}

