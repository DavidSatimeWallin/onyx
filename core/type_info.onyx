// A lot of these names have been copied from JAI's introspection system. This is just because
// I don't want to mentally bike-shed about the names; I just want to get something working.

package core.type_info

Type_Index :: #type u32
type_table : [] ^Type_Info;

Type_Info :: struct {
    // This must match the order of the elements in onyxtypes.h
    Kind :: enum {
        Invalid           :: 0x00; // Unused
        Basic             :: 0x01;
        Pointer           :: 0x02;
        Function          :: 0x03;
        Struct            :: 0x04;
        Compound          :: 0x05;
        Array             :: 0x06;
        Slice             :: 0x07;
        Dynamic_Array     :: 0x08;
        Variadic_Argument :: 0x09;
        Enum              :: 0x0a;
    }

    kind := Kind.Invalid;
    size: u32;

    // Does this need to know alignment? Probably?
    alignment: u32;
}

Type_Info_Basic :: struct {
    use base : Type_Info;

    // This must match the order of the elements in BasicKind in onyxtypes.h
    Kind :: enum {
        Void  :: 0x00;
        Bool  :: 0x01;
        I8    :: 0x03;
        U8    :: 0x04;
        I16   :: 0x05;
        U16   :: 0x06;
        I32   :: 0x07;
        U32   :: 0x08;
        I64   :: 0x09;
        U64   :: 0x0a;

        F32   :: 0x0c;
        F64   :: 0x0d;

        Rawptr :: 0x0e;

        I8X16 :: 0x0f;
        I16X8 :: 0x10;
        I32X4 :: 0x11;
        I64X2 :: 0x12;
        F32X4 :: 0x13;
        F64X2 :: 0x14;
        V128  :: 0x15;
    }

    basic_kind: Kind;
}

Type_Info_Pointer :: struct {
    use base : Type_Info;

    @Rename
    to: Type_Index;
}

Type_Info_Function :: struct {
    use base : Type_Info;

    return_type:        Type_Index;
    parameter_types: [] Type_Index;

    is_variadic: bool;
}

Type_Info_Array :: struct {
    use base : Type_Info;

    @Rename
    of: Type_Index;
    count: u32;
}

Type_Info_Slice :: struct {
    use base : Type_Info;

    @Rename
    of: Type_Index;
}

Type_Info_Dynamic_Array :: struct {
    use base : Type_Info;

    @Rename
    of: Type_Index;
}

Type_Info_Variadic_Argument :: struct {
    use base : Type_Info;

    @Rename
    of: Type_Index;
}

Type_Info_Enum :: struct {
    use base : Type_Info;

    Member :: struct {
        name: str;
        value: u64; // This assumes enums are always represented as ints.
    }

    name: str;
    backing_type: Type_Index;
    members: [] Member;

    is_flags: bool;
}

Type_Info_Struct :: struct {
    use base : Type_Info;

    Member :: struct {
        name: str;
        offset: u32;
        type_index: Type_Index;

        used: bool;
        has_default: bool;
    }

    name: str;
    members: [] Member;
}

Type_Info_Compound :: struct {
    use base : Type_Info;

    components : [] Type_Index;
}