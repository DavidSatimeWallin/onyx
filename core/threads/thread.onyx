package core.thread

use core
use core.intrinsics.atomics

#package {
    thread_mutex   : sync.Mutex;
    next_thread_id := 1;
    thread_map     : Map(Thread_ID, ^Thread);
}

Thread_ID :: #type i32

Thread :: struct {
    id    : Thread_ID;
    alive : bool;
}

spawn :: (t: ^Thread, data: ^$T, func: (^T) -> void) {
    sync.scoped_mutex(^thread_mutex);

    t.id    = next_thread_id;
    t.alive = true;
    next_thread_id += 1;

    thread_map->put(t.id, t);

    tls_base := raw_alloc(alloc.heap_allocator, __tls_size);
    memory.set(tls_base, 0, __tls_size);

    stack_base := raw_alloc(alloc.heap_allocator, 1 << 20);

    runtime.__spawn_thread(t.id, tls_base, stack_base, func, data);
}

join :: (t: ^Thread) {
    while t.alive {
        #if runtime.Wait_Notify_Available {
            __atomic_wait(^t.id, t.id);
        } else {
            // To not completely kill the CPU.
            runtime.__sleep(1);
        }
    }
}

kill :: (t: ^Thread) -> i32 {
    if !t.alive do return -1;

    ret := runtime.__kill_thread(t.id);
    if ret > 0 do __exited(t.id);

    return 1;
}

__initialize :: () {
    thread_map->init();
}

__exited :: (id: i32) {
    sync.scoped_mutex(^thread_mutex);

    thread := thread_map->get(id);
    if thread != null {
        thread.alive = false;
        #if runtime.Wait_Notify_Available {
            __atomic_notify(^thread.id);
        }

        thread_map->delete(id);
    }
}


