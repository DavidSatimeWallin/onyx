package core.memory

use package core.intrinsics.wasm { memory_copy, memory_fill }

copy :: (dest: rawptr, src: rawptr, count: i32) do memory_copy(dest, src, count);
set  :: (dest: rawptr, byte: u8, count: i32)    do memory_fill(dest, byte, count);

// Old and slow copy and set
copy_ :: (dst_: rawptr, src_: rawptr, len: u32) {
    dst := cast(^u8) dst_;
    src := cast(^u8) src_;
    for i: 0 .. len do dst[i] = src[i];
}

set_ :: (start: rawptr, value: u8, length: u32) {
    s := cast(^u8) start;
    for i: 0 .. length do s[i] = value;
}

alloc_slice :: (sl: ^[] $T, count: i32, allocator := context.allocator) {
    sl.data  = raw_alloc(allocator, sizeof T * count);
    sl.count = count;
}

make_slice :: ($T: type_expr, count: i32, allocator := context.allocator) -> [] T {
    return .{
        data = raw_alloc(allocator, sizeof T * count),
        count = count
    };
}

#match __make_overload macro (_: ^[] $T, count: u32, allocator := context.allocator) -> [] T {
    return (package core.memory).make_slice(T, count, allocator);
}

free_slice :: (sl: ^[] $T, allocator := context.allocator) {
    if sl.data == null do return;

    raw_free(allocator, sl.data);
    sl.data = null;
    sl.count = 0;
}

copy_slice :: (sl: [] $T, allocator := context.allocator) -> [] T {
    data := raw_alloc(allocator, sl.count * sizeof T);
    copy(data, sl.data, sl.count * sizeof T);

    return .{ data = data, count = sl.count };
}

resize_slice :: (sl: [] $T, new_size: i32, allocator := context.allocator) -> [] T {
    new_slice: [] T;
    new_slice.data = raw_alloc(allocator, sizeof T * new_size);
    new_slice.count = new_size;

    copy(new_slice.data, sl.data, sl.count * sizeof T);

    return new_slice;
}

fill_slice :: macro (sl: [] $T, v: T) {
    for ^it: sl do *it = v;
}

align :: #match {
    (size: ^u64, align: u64) {
        if *size % align != 0 {
            *size += align - (*size % align);
        }
    },

    (size: u64, align: u64) -> u64 {
        if size % align != 0 {
            size += align - (size % align);
        }
        return size;
    }        
}
