package core

#tag conv.Custom_Format.{ #solidify cptr.format {T=T} }
cptr :: struct (T: type_expr) {
    data: u64;

    make :: macro (ptr: ^$T) -> cptr(T) {
        __cptr_make :: __cptr_make
        return .{ __cptr_make(ptr) };
    }

    read :: (this: cptr($T)) -> T {
        buf: [sizeof T] u8;
        __cptr_read(this.data, ~~buf, sizeof T);
        return *cast(^T) buf;
    }

    read_u8  :: (this: cptr(u8))  => __cptr_read_u8(this.data);
    read_u16 :: (this: cptr(u16)) => __cptr_read_u16(this.data);
    read_u32 :: (this: cptr(u32)) => __cptr_read_u32(this.data);
    read_u64 :: (this: cptr(u64)) => __cptr_read_u64(this.data);
    read_i8  :: (this: cptr(i8))  => cast(i8)  __cptr_read_u8(this.data);
    read_i16 :: (this: cptr(i16)) => cast(i16) __cptr_read_u16(this.data);
    read_i32 :: (this: cptr(i32)) => cast(i32) __cptr_read_u32(this.data);
    read_i64 :: (this: cptr(i64)) => cast(i64) __cptr_read_u64(this.data);

    // When given a non-zero-sized dest, this procedure
    // fills the dest buffer with the contents of the string
    // up to the number bytes in the dest buffer. This
    // procedure returns the length of the string as given
    // by strlen(). This exists because iterating byte by byte
    // using __cptr_read_u8 would be slow compared to strlen().
    extract_str :: (this: cptr(u8), dest: [] u8) => __cptr_extract_str(this.data, dest);

    to_rawptr :: (this: cptr($T)) -> ^T {
        // I'm treating NULL as more of a concept, than as an actual value here,
        // because if something returns a NULL pointer, it should logically map
        // to the same idea as 'null' in Onyx.
        if this.data == 0 do return null;

        wasm :: package core.intrinsics.wasm
        // Using 1 instead of 0 because a null pointer (0) converts
        // to the memory address 0, not the base address for the WASM
        // memory.
        mem_base_ptr := __cptr_make(cast(rawptr) 1);
        assert(mem_base_ptr <= this.data + 1 && this.data + 1 <= mem_base_ptr + ~~(wasm.memory_size() << 16), "Invalid conversion from cptr to rawptr: pointer value out of Onyx memory range.");
        return ~~(this.data - mem_base_ptr + 1);
    }

    format :: (output: ^conv.Format_Output, format: ^conv.Format, p: ^cptr($T)) {
        conv.format(output, "cptr({})[0x{b16}]", T, p.data);
    }
}

#operator + macro (p: cptr($T), v: i32) -> cptr(T) {
    return .{ p.data + ~~(v * sizeof T) };
}

#local {
    #foreign "onyx_runtime" {
        __cptr_make        :: (x: rawptr) -> u64 ---
        __cptr_read        :: (x: u64, dest: rawptr, size: u32) -> void ---
        __cptr_read_u8     :: (x: u64) -> u8 ---
        __cptr_read_u16    :: (x: u64) -> u16 ---
        __cptr_read_u32    :: (x: u64) -> u32 ---
        __cptr_read_u64    :: (x: u64) -> u64 ---
        __cptr_extract_str :: (x: u64, dest: [] u8) -> u32 ---

        //
        // The equivalent write instructions are pusposefully left out.
        // Until a VERY CONVINCING REASON as to why they must be included
        // arises, including them is more of a security vulnerability than
        // I am willing to have.
        //
    }
}
