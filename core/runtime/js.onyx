package runtime

#load "core/runtime/common"

use package core

__output_string :: (s: str) -> u32 #foreign "host" "print_str" ---
__exit          :: (status: i32) -> void #foreign "host" "exit" ---

// The builtin _start proc.
// Sets up everything needed for execution.
#export "_start" () {
    __runtime_initialize();

    __tls_base = raw_alloc(context.allocator, __tls_size);
    __stdio_init();

    args: [] cstr = .{ null, 0 };
    (package main).main(args);

    __flush_stdio();
}

#if Multi_Threading_Enabled {
    __spawn_thread :: (id: i32, func: (data: rawptr) -> void, data: rawptr) -> bool #foreign "host" "spawn_thread" ---

    #export "_thread_start" (func: (data: rawptr) -> void, data: rawptr) {
        __stack_top = raw_alloc(context.allocator, 1 << 20);

        __tls_base  = raw_alloc(context.allocator, __tls_size);
        __stdio_init();

        func(data);

        __flush_stdio();
    }

    #export "_thread_exit" (id: i32) {
        // raw_free(context.allocator, __stack_top);
        raw_free(context.allocator, __tls_base);

        thread.__exited(id);
    }
}