package runtime.platform

use core {package, *}
use runtime {
    package,
    __runtime_initialize,
    Multi_Threading_Enabled,
    _thread_start,
    _thread_exit
}

#load "./fs"
#load "./env"
#load "./net"

#load "core/onyx/cptr"
#load "core/onyx/cbindgen"
// #load "core/onyx/fault_handling"

// Platform supports
Supports_Files :: true
Supports_Directories :: true
Supports_Os :: true
Supports_Processes :: true
Supports_Time :: true
Supports_Networking :: true
Supports_Type_Info :: true
Supports_Threads :: true
Supports_Env_Vars :: true
Supports_Futexes :: true
Supports_TTY :: true


#library "onyx_runtime"

#local {
    __stdout: os.File;
    __stderr: os.File;
    __stdin:  os.File;
}

__output_string :: (s: str) -> u32 {
    err, wrote := io.stream_write(&__stdout, s);
    return wrote;
}

__output_error :: (s: str) -> u32 {
    err, wrote := io.stream_write(&__stderr, s);
    return wrote;
}

__read_from_input :: (buffer: [] u8) -> i32 {
    err, read := io.stream_read(&__stdin, buffer);
    if err == .ReadPending do return 0;
    if err != .None do return -1;
    return read;
}

__wait_for_input :: (timeout: i32) -> bool {
    err, ready := io.stream_poll(&__stdin, .Read, timeout);
    if err != .None do return false;
    return ready;
}


ProcessData :: #distinct u64

#foreign "onyx_runtime" {
    // Arguments
    __args_get       :: (argv: & &u8, arg_buf: &u8) -> void ---
    __args_sizes_get :: (argc: &i32, arg_buf_size: &i32) -> void ---

    // OS
    __exit :: (status: i32) -> void ---
    __sleep :: (milliseconds: i32) -> void ---
    __futex_wait :: (addr: rawptr, expected: i32, timeout: i32) -> i32 ---
    __futex_wake :: (addr: rawptr, maximum: i32) -> i32 ---

    // TTY
    __tty_get :: (state: &os.TTY_State) -> void ---
    __tty_set :: (state: &os.TTY_State) -> bool ---

    // Time and sleep
    __time :: () -> u64 ---

    // Processes
    __process_spawn   :: (path: str, args: [] str, non_blocking_io: bool, starting_directory: str) -> ProcessData ---
    __process_read    :: (handle: ProcessData, buffer: [] u8) -> i32 ---
    __process_write   :: (handle: ProcessData, buffer: [] u8) -> i32 ---
    __process_kill    :: (handle: ProcessData) -> bool ---
    __process_wait    :: (handle: ProcessData) -> os.ProcessResult ---
    __process_destroy :: (handle: ProcessData) -> void ---

    // Misc
    __file_get_standard :: (fd: i32, out: &FileData) -> bool ---
    __random_get        :: (buf: [] u8) -> void ---
}

#if !#defined(runtime.vars.no_entrypoint) {
    use main
    #local MAIN_FUNCTION :: main.main

} else {
    MAIN_FUNCTION :: () {}
}

__start :: () {
    fd: FileData;
    __file_get_standard(1, &fd);
    __stdout = .{
        .{ &__file_stream_vtable },
        fd
    };
    
    __file_get_standard(2, &fd);
    __stderr = .{
        .{ &__file_stream_vtable },
        fd
    };

    __file_get_standard(0, &fd);
    __stdin = .{
        .{ &__file_stream_vtable, .Block_On_Read },
        fd
    };

    __runtime_initialize();
    context.thread_id = 0;


    #if (typeof MAIN_FUNCTION) == #type () -> void { // An error on this line means no 'main.main' was found in your program.
        MAIN_FUNCTION();

    } else {
        args : [] cstr;
        argv_buf_size : i32;
        __args_sizes_get(&args.count, &argv_buf_size);

        args = memory.make_slice(cstr, args.count);
        argv_buf := cast(cstr) calloc(argv_buf_size);
        __args_get(args.data, argv_buf);

        MAIN_FUNCTION(args);
    }

    __flush_stdio();
}

#if Multi_Threading_Enabled {
    __spawn_thread :: (id: i32, tls_base: rawptr, stack_base: rawptr, func: (data: rawptr) -> void, data: rawptr) -> bool #foreign "onyx_runtime" "__spawn_thread" ---
    __kill_thread  :: (id: i32) -> i32 #foreign "onyx_runtime" "__kill_thread" ---

    #export "_thread_start" _thread_start
    #export "_thread_exit"  _thread_exit
}
