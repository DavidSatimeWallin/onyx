package runtime.platform

#load "./wasi_defs"
#load "./wasi_fs"
#load "./wasi_env"

use core
use wasi
use runtime
use main { MAIN_PKG :: package }

use wasi {
    IOVec, SubscriptionTagged, Subscription, Event, Size,
    poll_oneoff, fd_write, fd_datasync, fd_read,
    args_get, args_sizes_get,
    proc_exit,
    clock_time_get, Timestamp,
    random_get,
}
use runtime {
    __runtime_initialize,
    Multi_Threading_Enabled,
}
use core { 
    __flush_stdio
}


// Platform supports
Supports_Files :: true
Supports_Directories :: true
Supports_Os :: true
Supports_Processes :: false
Supports_Time :: true
Supports_Networking :: false
Supports_Type_Info :: true
Supports_Threads :: true
Supports_Env_Vars :: true


__output_string :: (s: str) -> u32 {
    STDOUT_FILENO :: 1

    vec := IOVec.{ buf = cast(u32) s.data, len = s.count };
    tmp : Size;
    fd_write(STDOUT_FILENO, &vec, 1, &tmp);
    fd_datasync(STDOUT_FILENO);
    return tmp;
}

__exit :: (status: i32) do proc_exit(status);

__read_from_input :: (buffer: [] u8) -> i32 {
    STDIN_FILENO :: 0

    vec := IOVec.{ buf = cast(i32) buffer.data, len = buffer.count };
    read: Size;
    error := fd_read(STDIN_FILENO, &vec, 1, &read);
    if error != .Success do return -1;

    return read;
}

__sleep :: (milliseconds: u32) {
    tagged: SubscriptionTagged;
    tagged.tag = .Clock;
    tagged.clock = .{
        id = .Realtime,
        timeout = cast(u64) milliseconds * 1000000,
        precision = 1,
        flags = ~~0,
    };

    subscription := Subscription.{
        userdata = 0,
        u = tagged,
    };

    event: Event;
    number_of_events: u32;

    error_code := poll_oneoff(&subscription, &event, 1, &number_of_events);
}

__time :: () -> i64 {
    time: Timestamp;
    if clock_time_get(.Realtime, 1, &time) != .Success {
        return 0;
    }

    // Need to return in milliseconds, not nanoseconds.
    return time / 1000000;
}

__random_get :: (buf: [] u8) {
    random_get(buf.data, buf.length);
}


// Sets up everything needed for execution.
__start :: () {
    __runtime_initialize();
    context.thread_id = 0;

    #if (typeof MAIN_PKG.main) == #type () -> void {
        MAIN_PKG.main();

    } else {
        args : [] cstr;
        argv_buf_size : Size;
        args_sizes_get(&args.count, &argv_buf_size);

        args = core.memory.make_slice(cstr, args.count);
        argv_buf := cast(cstr) calloc(argv_buf_size);
        args_get(args.data, argv_buf);


        // This post processing of the argv array needs to happen if the target is using
        // 32-bit pointers, instead of 64-bits. Right now, Onyx pointers take up 64-bits,
        // but in most circumstances, only the lower 32-bits are used. When webassembly
        // standardizes the 64-bit address space, it will be an easy conversion over.
        // But for right now, WASI will give the argv array 32-bit pointers, instead of
        // 64-bit pointers. This loops expands the 32-bit pointers into 64-bit pointers
        // while not clobbering any of them.
        while i := cast(i32) (args.count - 1); i >= 0 {
            defer i -= 1;

            args[i] = cast(cstr) (cast([&] u32) args.data)[i];
        }

        MAIN_PKG.main(args);
    }

    __flush_stdio();
}


#if runtime.Multi_Threading_Enabled {
    #local ThreadData :: struct {
        id: i32;
        tls_base, stack_base: rawptr;
        func: (data: rawptr) -> void;
        data: rawptr;
    }

    __spawn_thread :: (
        id: i32,
        tls_base, stack_base: rawptr,
        func: (data: rawptr) -> void, data: rawptr) -> void
    {
        thread_data := core.alloc.on_heap(ThreadData.{
            id, tls_base, stack_base, func, data
        });

        wasi.thread_spawn(thread_data);
    }

    // Currently, WASI does not provide a way to kill a thread preemptively.
    __kill_thread :: (id: i32) => 0

    #export "wasi_thread_start"
    (wasi_tid: u32, use td: &ThreadData) {
        runtime._thread_start(id, tls_base, stack_base, func, data);
        runtime._thread_exit(id);
    }
}


