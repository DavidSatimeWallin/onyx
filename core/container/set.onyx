package core.set

#local {
    array :: package core.array
    hash  :: package core.hash
    memory :: package core.memory
    math :: package core.math
}

#local SetValue :: interface (t: $T) {
    { hash.to_u32(t) } -> u32;
    { t == t } -> bool;
}

Set :: struct (Elem_Type: type_expr) where SetValue(Elem_Type) {
    allocator : Allocator;

    hashes  : [] i32;
    entries : [..] Entry(Elem_Type);

    default_value: Elem_Type;

    Entry :: struct (T: type_expr) {
        next  : i32;
        hash  : u32;
        value : T;
    }

    init     :: init
    free     :: free
    has      :: has
    get      :: get
    get_ptr  :: get_ptr
    insert   :: insert
    remove   :: remove
    clear    :: clear
    empty    :: empty
    iterator :: iterator
}

make :: ($T: type_expr, default := T.{}, allocator := context.allocator) -> Set(T) {
    set : Set(T);
    init(^set, default=default, allocator=allocator);
    return set;
}

#match (package builtin).__make_overload macro (x: ^Set, allocator: Allocator) => (package core.set).make(x.Elem_Type, allocator = allocator);

init :: (set: ^Set($T), default := T.{}, allocator := context.allocator) {
    set.allocator = allocator;
    set.default_value = default;

    memory.alloc_slice(^set.hashes, 8, allocator=allocator);
    array.fill(set.hashes, -1);

    array.init(^set.entries, 4, allocator=allocator); 
}

free :: (use set: ^Set) {
    memory.free_slice(^hashes, allocator=allocator);
    array.free(^entries);
}

#match (package builtin).delete (package core.set).free

insert :: (use set: ^Set, value: set.Elem_Type) {
    if hashes.data == null do init(set);
    lr := lookup(set, value);

    if lr.entry_index >= 0 do return;

    entries << .{ hashes[lr.hash_index], lr.hash, value };
    hashes[lr.hash_index] = entries.count - 1;

    if full(set) do grow(set);
}

#operator << macro (set: Set($T), value: T) do (package core.set).insert(^set, value);

has :: (use set: ^Set, value: set.Elem_Type) -> bool {
    lr := lookup(set, value);
    return lr.entry_index >= 0;
}

get :: (use set: ^Set, value: set.Elem_Type) -> set.Elem_Type {
    lr := lookup(set, value);
    return entries[lr.entry_index].value if lr.entry_index >= 0 else set.Elem_Type.{};
}

get_ptr :: (use set: ^Set, value: set.Elem_Type) -> ^set.Elem_Type {
    lr := lookup(set, value);
    return (^entries[lr.entry_index].value) if lr.entry_index >= 0 else null;
}

remove :: (use set: ^Set, value: set.Elem_Type) {
    lr := lookup(set, value);
    if lr.entry_index < 0 do return;

    if lr.entry_prev < 0   do hashes[lr.hash_index]       = entries[lr.entry_index].next;
    else                   do entries[lr.entry_prev].next = entries[lr.entry_index].next;

    if lr.entry_index == entries.count - 1 {
        array.pop(^entries);
        return;
    }

    array.fast_delete(^entries, lr.entry_index);
    last := lookup(set, entries[lr.entry_index].value);
    if last.entry_prev >= 0    do entries[last.entry_prev].next = lr.entry_index;
    else                       do hashes[last.hash_index] = lr.entry_index;
}

clear :: (use set: ^Set) {
    array.fill(hashes, -1);
    array.clear(^entries);
}

empty :: (use set: ^Set) -> bool {
    return entries.count == 0;
}

#match (package core.iter).as_iterator iterator
iterator :: (set: ^Set($T)) -> Iterator(T) {
    Context :: struct (T: type_expr) {
        set: ^Set(T);
        position: i32;
    }

    context := new(Context(T));
    context.set = set;
    context.position = 0;

    next :: (use context: ^Context($T)) -> (T, bool) {
        if position < set.entries.count {
            defer position += 1;
            return set.entries[position].value, true;

        } else {
            return .{}, false;
        }
    }

    return .{
        data = context,
        next = #solidify next { T = T },
        close = cfree,
    };
}

//
// Private symbols
//

#local {
    SetLookupResult :: struct {
        hash_index  : i32 = -1;
        entry_index : i32 = -1;
        entry_prev  : i32 = -1;
        hash        : u32 = 0;
    }

    lookup :: (use set: ^Set, value: set.Elem_Type) -> SetLookupResult {
        lr := SetLookupResult.{};

        hash_value: u32 = hash.to_u32(value); // You cannot have a set of this type without defining a to_u32 hash.
        lr.hash = hash_value;

        lr.hash_index = hash_value % hashes.count;
        lr.entry_index = hashes[lr.hash_index];

        while lr.entry_index >= 0 {
            if entries[lr.entry_index].hash == hash_value {
                if entries[lr.entry_index].value == value do return lr;
            }

            lr.entry_prev = lr.entry_index;
            lr.entry_index = entries[lr.entry_index].next;
        }

        return lr;
    }

    full :: (use set: ^Set) => entries.count >= ~~(0.75f * ~~hashes.count);

    grow :: (use set: ^Set) {
        new_size := math.max(hashes.count << 1, 8);
        rehash(set, new_size);
    }

    rehash :: (use set: ^Set, new_size: i32) {
        memory.free_slice(^hashes, allocator);
        hashes = make([] u32, new_size, allocator=allocator);
        array.fill(hashes, -1);

        for ^entry: entries do entry.next = -1;

        index := 0;
        for ^entry: entries {
            defer index += 1;

            lr := lookup(set, entry.value); 
            entries[index].next = hashes[lr.hash_index];
            hashes[lr.hash_index] = index;
        }
    }
}
