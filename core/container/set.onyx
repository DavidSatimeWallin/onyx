package core.set

#local {
    array :: package core.array
    hash  :: package core.hash
    memory :: package core.memory
    math :: package core.math
}
use package core.intrinsics.onyx { __zero_value }

#local SetValue :: interface (T: type_expr) {
    hash.to_u32(T);
    T == T;
}

Set :: struct (T: type_expr) where SetValue(T) {
    allocator : Allocator;

    hashes  : [] i32;
    entries : [..] Entry(T);

    default_value: T;

    Entry :: struct (T: type_expr) {
        next  : i32;
        value : T;
    }

    has      :: has
    get      :: get
    insert   :: insert
    remove   :: remove
    clear    :: clear
    empty    :: empty
    iterator :: iterator
}

make :: ($T: type_expr, default := __zero_value(T)) -> Set(T) {
    set : Set(T);
    init(^set, default=default);
    return set;
}

init :: (use set: ^Set($T), default := __zero_value(T)) {
    allocator = context.allocator;
    default_value = default;

    memory.alloc_slice(^hashes, 8, allocator=allocator);
    memory.fill_slice(hashes, -1);

    array.init(^entries, 4, allocator=allocator); 
}

free :: (use set: ^Set($T)) {
    memory.free_slice(^hashes, allocator=allocator);
    array.free(^entries);
}

insert :: (use set: ^Set($T), value: T) {
    if hashes.data == null do init(set);
    lr := lookup(set, value);

    if lr.entry_index >= 0 do return;

    entries << .{ hashes[lr.hash_index], value };
    hashes[lr.hash_index] = entries.count - 1;

    if full(set) do grow(set);
}

#operator << macro (set: Set($T), value: T) do (package core.set).insert(^set, value);

has :: (use set: ^Set($T), value: T) -> bool {
    lr := lookup(set, value);
    return lr.entry_index >= 0;
}

get :: (use set: ^Set($T), value: T) -> T {
    lr := lookup(set, value);
    return entries[lr.entry_index].value if lr.entry_index >= 0 else __zero_value(T);
}

remove :: (use set: ^Set($T), value: T) {
    lr := lookup(set, value);
    if lr.entry_index < 0 do return;

    if lr.entry_prev < 0   do hashes[lr.hash_index]       = entries[lr.entry_index].next;
    else                   do entries[lr.entry_prev].next = entries[lr.entry_index].next;

    if lr.entry_index == entries.count - 1 {
        array.pop(^entries);
        return;
    }

    array.fast_delete(^entries, lr.entry_index);
    last := lookup(set, entries[lr.entry_index].value);
    if last.entry_prev >= 0    do entries[last.entry_prev].next = lr.entry_index;
    else                       do hashes[last.hash_index] = lr.entry_index;
}

clear :: (use set: ^Set($T)) {
    array.fill(hashes, -1);
    array.clear(^entries);
}

empty :: (use set: ^Set($T)) -> bool {
    return entries.count == 0;
}

#match (package core.iter).as_iterator iterator
iterator :: (set: ^Set($T)) -> Iterator(T) {
    Context :: struct (T: type_expr) {
        set: ^Set(T);
        position: i32;
    }

    context := new(Context(T));
    context.set = set;
    context.position = 0;

    next :: ($T: type_expr, use context: ^Context(T)) -> (T, bool) {
        if position < set.entries.count {
            defer position += 1;
            return set.entries[position].value, true;

        } else {
            return __zero_value(T), false;
        }
    }

    close :: (context: rawptr) {
        cfree(context);
    }

    return .{
        data = context,
        next = #solidify next { T = T },
        close = close,
    };
}

//
// Private symbols
//

#local {
    SetLookupResult :: struct {
        hash_index  : i32 = -1;
        entry_index : i32 = -1;
        entry_prev  : i32 = -1;
    }

    lookup :: (use set: ^Set($T), value: T) -> SetLookupResult {
        lr := SetLookupResult.{};

        hash_value: u32 = hash.to_u32(value); // You cannot have a set of this type without defining a to_u32 hash.

        lr.hash_index = hash_value % hashes.count;
        lr.entry_index = hashes[lr.hash_index];

        while lr.entry_index >= 0 {
            if entries[lr.entry_index].value == value do return lr;

            lr.entry_prev = lr.entry_index;
            lr.entry_index = entries[lr.entry_index].next;
        }

        return lr;
    }

    full :: (use set: ^Set($T)) => entries.count >= ~~(0.75f * ~~hashes.count);

    grow :: (use set: ^Set($T)) {
        new_size := math.max(hashes.count << 1, 8);
        rehash(set, new_size);
    }

    rehash :: (use set: ^Set($T), new_size: i32) {
        memory.free_slice(^hashes, allocator);
        memory.alloc_slice(^hashes, new_size, allocator);
        memory.fill_slice(hashes, -1);

        for ^entry: entries do entry.next = -1;

        index := 0;
        for ^entry: entries {
            defer index += 1;

            lr := lookup(set, entry.value); 
            entries[index].next = hashes[lr.hash_index];
            hashes[lr.hash_index] = index;
        }
    }
}
