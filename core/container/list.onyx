package core.list

use package core.intrinsics.onyx { __zero_value }

ListElem :: struct (T: type_expr) {
    next: ^ListElem(T) = null;
    prev: ^ListElem(T) = null;
    data: T;
}

List :: struct (T: type_expr) {
    allocator: Allocator;

    first: ^ListElem(T) = null;
    last:  ^ListElem(T) = null;

    // "Method" like things
    free         :: free
    push_end     :: push_end
    push_begin   :: push_begin
    pop_end      :: pop_end
    pop_begin    :: pop_begin
    count        :: count
    at           :: at
    contains     :: contains
    fold         :: fold
    map          :: map
    get_iterator :: get_iterator
}

make :: ($T: type_expr, allocator := context.allocator) -> List(T) {
    return .{ allocator = allocator };
}

free :: (list: ^List($T)) {
    elem := list.first;
    while elem != null {
        to_delete := elem;
        elem = elem.next;
        raw_free(list.allocator, elem);
    }
}

push_end :: (list: ^List($T), x: T) { 
    new_elem := allocate_elem(list);
    new_elem.data = x;

    new_elem.prev = list.last;
    list.last.next = new_elem;
    list.last = new_elem;

    if list.first == null do list.first = new_elem;
}

push_begin :: (list: ^List($T), x: T) {
    new_elem := allocate_elem(list);
    new_elem.data = x;

    new_elem.next = list.first;
    list.first.prev = new_elem;
    list.first = new_elem;

    if list.last == null do list.last = new_elem;
}

pop_end :: (list: ^List($T), default: T = __zero_value(T)) -> T {
    if list.last == null do return default;

    end := list.last;
    list.last = list.last.prev;
    list.last.next = null;

    defer raw_free(list.allocator, end);
    return end.data;
}

pop_begin :: (list: ^List($T), default: T = __zero_value(T)) -> T {
    if list.last == null do return default;

    begin := list.first;
    list.first = list.first.next;
    list.first.prev = null;

    defer raw_free(list.allocator, begin);
    return begin.data;
}

count :: (list: ^List($T)) -> i32 {
    c := 0;
    elem := list.first;
    while elem != null {
        c += 1;
        elem = elem.next;
    }

    return c;
}

at :: (list: ^List($T), index: i32) -> ^T {
    elem := list.first;
    while elem != null {
        if index == 0 do return ^elem.data;
        index -= 1;
        elem = elem.next;
    }

    return null;
}

contains :: (list: ^List($T), x: T) -> bool {
    elem := list.first;
    while elem != null {
        if elem.data == x do return true;
        elem = elem.next;
    }

    return false;
}

fold :: (list: ^List($T), init: $R, f: (T, R) -> R) -> R {
    val := init;

    link := list.first;
    while link != null {
        val = f(link.data, val);
        link = link.next;
    }

    return val;
}

map :: #match {}
#match map (list: ^List($T), f: (^T) -> void) {
    elem := list.first;
    while elem != null {
        f(^elem.data);
        elem = elem.next;
    }
}

#match map (list: ^List($T), f: (T) -> $R) -> List(R) {
    new_list := make(R, allocator=list.allocator);
    elem := list.first;
    while elem != null {
        push_end(new_list, f(elem.data));
        elem = elem.next;
    }
}

#local iter :: package core.iter
#match iter.as_iterator get_iterator
get_iterator :: (list: ^List($T)) -> Iterator(T) {
    iterator_next :: (list_iter: ^ListIterator($T)) -> (T, bool) {
        use package core.intrinsics.onyx { __zero_value }
        if list_iter.current == null do return __zero_value(T), false;

        defer list_iter.current = list_iter.current.next;
        return list_iter.current.data, true;
    }

    ListIterator :: struct (T: type_expr) {
        current: ^ListElem(T);
    }

    list_iterator := new(ListIterator(T));
    list_iterator.current = list.first;

    return .{
        data = list_iterator,
        next = #solidify iterator_next { T = T },
        close = cfree,
    };
}

#local allocate_elem :: macro (list: ^List($T)) => new(ListElem(T), allocator=list.allocator);
