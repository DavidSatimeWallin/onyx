package core

// Optional is helper type that encapsulates the idea of an empty
// value, without resorting to null pointers. Optionals are usually
// provided as a return value from procedures that could fail. There
// are several helper methods that you can use to make it easier to
// work with optionals.

// Because Optional is a newer addition to the standard library of Onyx,
// much of the standard library does not use it. Currently it is only
// used by Map and Set in their `get_opt` function. In theory, it should
// be used in many more places, instead of returning `.{}`.

#inject Optional {
    #doc """
        Helper procedure for creating an Optional with a value.
        Pass a type as the first argument to force the type, otherwise
        the type will be inferred from the parameter type.
    """
    make :: #match #locked {
        ((x: $T) => (?T).{ has_value = true, value = x }),
        ($T: type_expr, x: T) => ((?T).{ has_value = true, value = x })
    }

    #doc """
        Create an empty Optional of a certain type. This procedure
        is mostly useless, because you can use `.{}` in type inferred
        places to avoid having to specify the type.
    """
    empty :: macro (T: type_expr) => (?T).{}; 

    #doc """
        Extracts the value from the Optional, or uses a default if
        no value is present.
    """
    value_or :: (o: ?$T, default: T) -> T {
        if !o.has_value do return default;
        return o.value;
    }

    #doc "Clears the value in the Optional, zeroing the memory of the value."
    reset :: (o: &?$T) {
        o.has_value = false;
        core.memory.set(&o.value, 0, sizeof T);
    }

    #doc "Sets the value in the Optional."
    set :: (o: &?$T, value: T) {
        o.has_value = true;
        o.value = value;
    }

    #doc "Monadic chaining operation."
    and_then :: (o: ?$T, transform: (T) -> ?$R) -> ?R {
        if !o.has_value do return .{};
        return transform(o.value);
    }

    #doc "Changes the value inside the optional, if present."
    transform :: (o: ?$T, transform: (T) -> $R) -> ?R {
        if !o.has_value do return .{};
        return Optional.make(transform(o.value));
    }

    #doc """
        Like `value_or`, but instead of providing a value, you
        provide a function to generate a value.
    """
    or_else :: (o: ?$T, generate: () -> ?T) -> ?T {
        if o.has_value do return o;
        return generate();
    }

    #doc """
        Returns the value inside the optional, if there is one.
        If not, an assertion is thrown and the context's assert
        handler must take care of it.
    """
    unwrap :: (o: ?$T) -> T {
        if o.has_value do return o.value;
        assert(false, "Unwrapping empty Optional.");
    }

    or_return :: macro (o: ?$T) -> T {
        value := o;
        if value.has_value do return value.value;

        return return .{};
    }

    catch :: macro (o: ?$T, body: Code) -> T {
        value := o;
        if value.has_value do return value.value;

        #unquote body;
    }

    hash :: (o: ?$T/core.hash.Hashable) -> u32 {
        if !o.has_value do return 0;
        return core.hash.hash(o.value);
    }
}

#operator == (o1, o2: ?$T) -> bool {
    if o1.has_value != o2.has_value do return false;
    if !o1.has_value do return true;
    return o1.value == o2.value;
}

#operator ?? macro (opt: ?$T, default: T) -> T {
    value := opt;
    if value do return value.value;

    return default;
}

#operator ?? macro (opt: ?$T, catch: Code) -> T {
    value := opt;
    if value do return value.value;

    #unquote catch;
}

#operator ? macro (opt: ?$T) -> T {
    value := opt;
    if value do return value.value;

    return return .{};
}


#overload
__implicit_bool_cast :: macro (o: ?$T) => o.has_value;

