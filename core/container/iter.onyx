package core.iter

use core {memory, alloc, array, Pair}

as_iterator :: #match {}

Iterable :: interface (t: $T) {
    { as_iterator(t) } -> Iterator;
}

close :: (it: Iterator($T)) {
    if it.close != null_proc {
        it.close(it.data);
    }
}

// Implicit iterator

#local
ImplicitIterator :: interface (t: $T) {
    { t->iter_open() } -> void;
    t->iter_next();
    { t->iter_close() } -> void;

    {
        do {
            value, success := t->iter_next();
            return success;
        }
    } -> bool;
}

#overload #precedence 10000
as_iterator :: (x: ^$T/ImplicitIterator) => {
    x->iter_open();
    return generator_no_copy(x, T.iter_next, T.iter_close);
}


// Iterator Modifiers

filter :: #match #local {}
#overload
filter :: (it: Iterator($T), predicate: (T) -> bool, allocator := context.temp_allocator) -> Iterator(T) {
    FilterIterator :: struct (T: type_expr) {
        iterator:  Iterator(T);
        predicate: (T) -> bool;
        allocator: Allocator;
    }

    filter_iterator := new(FilterIterator(T), allocator=allocator);
    filter_iterator.iterator = it;
    filter_iterator.predicate = predicate;
    filter_iterator.allocator = allocator;

    next :: (fi: ^FilterIterator($T)) -> (T, bool) {
        value, cont := fi.iterator.next(fi.iterator.data);
        if cont {
            while !fi.predicate(value) {
                value, cont = fi.iterator.next(fi.iterator.data);
                if !cont do return value, false;
            }

            return value, true;
        } else {
            return value, false;
        }
    }

    close :: (fi: ^FilterIterator($T)) {
        if fi.iterator.close != null_proc do fi.iterator.close(fi.iterator.data);
        raw_free(fi.allocator, fi);
    }

    return .{
        data  = filter_iterator,
        next  = #solidify next  { T=T },
        close = #solidify close { T=T },
    };
}

#overload
filter :: (it: Iterator($T), ctx: $Ctx, predicate: (T, Ctx) -> bool, allocator := context.temp_allocator) -> Iterator(T) {
    FilterIterator :: struct (T: type_expr, Ctx: type_expr) {
        iterator:  Iterator(T);
        predicate: (T, Ctx) -> bool;
        ctx: Ctx;
        allocator: Allocator;
    }

    filter_iterator := new(FilterIterator(T, Ctx), allocator=allocator);
    filter_iterator.iterator = it;
    filter_iterator.predicate = predicate;
    filter_iterator.ctx = ctx;
    filter_iterator.allocator = allocator;

    next :: (fi: ^FilterIterator($T, $_)) -> (T, bool) {
        value, cont := fi.iterator.next(fi.iterator.data);
        if cont {
            while !fi.predicate(value, fi.ctx) {
                value, cont = fi.iterator.next(fi.iterator.data);
                if !cont do return value, false;
            }

            return value, true;
        } else {
            return value, false;
        }
    }

    close :: (fi: ^FilterIterator($T, $_)) {
        if fi.iterator.close != null_proc do fi.iterator.close(fi.iterator.data);
        raw_free(fi.allocator, fi);
    }

    return .{
        data  = filter_iterator,
        next  = #solidify next  { T=T, _=Ctx },
        close = #solidify close { T=T, _=Ctx },
    };
}

map :: #match #local {}

#overload
map :: (it: Iterator($T), transform: (T) -> $R, allocator := context.temp_allocator) -> Iterator(R) {
    MapIterator :: struct (T: type_expr, R: type_expr) {
        iterator:  Iterator(T);
        transform: (T) -> R;
        allocator: Allocator;
    }

    map_iterator := new(MapIterator(T, R), allocator=allocator);
    map_iterator.iterator = it;
    map_iterator.transform = transform;
    map_iterator.allocator = allocator;

    next :: (mi: ^MapIterator($T, $R)) -> (R, bool) {
        value, cont := mi.iterator.next(mi.iterator.data);
        if !cont do return .{}, false;

        return mi.transform(value), true;
    }

    close :: (mi: ^MapIterator($T, $R)) {
        if mi.iterator.close != null_proc do mi.iterator.close(mi.iterator.data);
        raw_free(mi.allocator, mi);
    }

    return .{
        data  = map_iterator,
        next  = #solidify next  { T=T, R=R },
        close = #solidify close { T=T, R=R },
    };
}

#overload
map :: (it: Iterator($T), ctx: $Ctx, transform: (T, Ctx) -> $R, allocator := context.temp_allocator) -> Iterator(R) {
    MapIterator :: struct (T: type_expr, R: type_expr, Ctx: type_expr) {
        iterator:  Iterator(T);
        transform: (T, Ctx) -> R;
        ctx: Ctx;
        allocator: Allocator;
    }

    map_iterator := new(MapIterator(T, R, Ctx), allocator=allocator);
    map_iterator.iterator = it;
    map_iterator.transform = transform;
    map_iterator.ctx = ctx;
    map_iterator.allocator = allocator;

    next :: (mi: ^MapIterator($T, $R, $Ctx)) -> (R, bool) {
        value, cont := mi.iterator.next(mi.iterator.data);
        if !cont do return .{}, false;

        return mi.transform(value, mi.ctx), true;
    }

    close :: (mi: ^MapIterator($T, $R, $Ctx)) {
        if mi.iterator.close != null_proc do mi.iterator.close(mi.iterator.data);
        raw_free(mi.allocator, mi);
    }

    return .{
        data  = map_iterator,
        next  = #solidify next  { T=T, R=R, Ctx=Ctx },
        close = #solidify close { T=T, R=R, Ctx=Ctx },
    };
}

take_one :: (it: Iterator($T), no_close := false) -> (T, bool) {
    ret, cont := it.next(it.data);
    if !cont && !no_close {
        if it.close != null_proc do it.close(it.data);
    }
    return ret, cont;
}

// Macro that allows you to extract elements from an iterator in a simple way:
//
// value: i32;
// iterator: Iterator(i32) = ...;
//
// if #(value) << iterator {
//     ...iterater closed...
// }
#operator << macro (dest: Code, it: Iterator($T)) -> bool {
    take_one :: take_one

    cont: bool;
    (#unquote dest), cont = take_one(it);
    return !cont;
}

take :: (it: Iterator($T), count: u32, allocator := context.temp_allocator) -> Iterator(T) {
    TakeIterator :: struct (T: type_expr) {
        iterator:  Iterator(T);
        remaining: u32;
        allocator: Allocator;
    }

    take_iterator := new(TakeIterator(T), allocator=allocator);
    take_iterator.iterator = it;
    take_iterator.remaining = count;
    take_iterator.allocator = allocator;

    next :: ($T: type_expr, ti: ^TakeIterator(T)) -> (T, bool) {
        if ti.remaining == 0 do return .{}, false;

        ti.remaining -= 1;
        return ti.iterator.next(ti.iterator.data);
    }

    close :: ($T: type_expr, ti: ^TakeIterator(T)) {
        if ti.iterator.close != null_proc do ti.iterator.close(ti.iterator.data);
        raw_free(ti.allocator, ti);
    }

    return .{
        data  = take_iterator,
        next  = #solidify next  { T=T },
        close = #solidify close { T=T },
    };
}

take_while :: (it: Iterator($T), predicate: (T) -> bool, allocator := context.temp_allocator) -> Iterator(T) {
    TakeIterator :: struct (T: type_expr) {
        iterator:  Iterator(T);
        predicate: (T) -> bool;
        allocator: Allocator;
    }

    take_iterator := new(TakeIterator(T), allocator=allocator);
    take_iterator.iterator = it;
    take_iterator.predicate = predicate;
    take_iterator.allocator = allocator;

    next :: ($T: type_expr, ti: ^TakeIterator(T)) -> (T, bool) {
        value, cont := ti.iterator.next(ti.iterator.data);
        if !cont do return value, false;

        return value, ti.predicate(value);
    }

    close :: ($T: type_expr, ti: ^TakeIterator(T)) {
        if ti.iterator.close != null_proc do ti.iterator.close(ti.iterator.data);
        raw_free(ti.allocator, ti);
    }

    return .{
        data  = take_iterator,
        next  = #solidify next  { T=T },
        close = #solidify close { T=T },
    };
}

skip :: (it: Iterator($T), count: u32, allocator := context.temp_allocator) -> Iterator(T) {
    SkipIterator :: struct (T: type_expr) {
        iterator: Iterator(T);
        to_skip:  i32;
        skipped:  bool = false;
        allocator: Allocator;
    }

    skip_iterator := new(SkipIterator(T), allocator=allocator);
    skip_iterator.iterator = it;
    skip_iterator.to_skip = count;
    skip_iterator.allocator = allocator;

    next :: (si: ^SkipIterator($T)) -> (T, bool) {
        while !si.skipped && si.to_skip > 0 {
            si.to_skip -= 1;
            value, cont := si.iterator.next(si.iterator.data);

            if !cont {
                si.skipped = true;
                return value, false;
            }
        }

        return si.iterator.next(si.iterator.data);
    }

    close :: (si: ^SkipIterator($T)) {
        if si.iterator.close != null_proc do si.iterator.close(si.iterator.data);
        raw_free(si.allocator, si);
    }

    return .{
        data  = skip_iterator,
        next  = #solidify next  { T=T },
        close = #solidify close { T=T },
    };
}

skip_while :: #match #local {}

#overload
skip_while :: (it: Iterator($T), predicate: (T) -> bool, allocator := context.temp_allocator) -> Iterator(T) {
    SkipIterator :: struct (T: type_expr) {
        iterator: Iterator(T);
        allocator: Allocator;
        predicate: (T) -> bool;
        skipped := false;
    }

    skip_iterator := new(SkipIterator(T), allocator=allocator);
    skip_iterator.iterator = it;
    skip_iterator.allocator = allocator;
    skip_iterator.predicate = predicate;

    next :: (si: ^SkipIterator($T)) -> (T, bool) {
        while !si.skipped {
            value, cont := si.iterator.next(si.iterator.data);

            if !cont {
                si.skipped = true;
                return value, false;
            }

            if !si.predicate(value) {
                si.skipped = true;
                return value, true;
            }
        }

        return si.iterator.next(si.iterator.data);
    }

    close :: (si: ^SkipIterator($T)) {
        if si.iterator.close != null_proc do si.iterator.close(si.iterator.data);
        raw_free(si.allocator, si);
    }

    return .{
        data  = skip_iterator,
        next  = #solidify next  { T=T },
        close = #solidify close { T=T },
    };
}

#overload
skip_while :: (it: Iterator($T), ctx: $Ctx, predicate: (T, Ctx) -> bool, allocator := context.temp_allocator) -> Iterator(T) {
    SkipIterator :: struct (T: type_expr, Ctx: type_expr) {
        iterator: Iterator(T);
        allocator: Allocator;
        predicate: (T, Ctx) -> bool;
        ctx: Ctx;
        skipped := false;
    }

    skip_iterator := new(SkipIterator(T, Ctx), allocator=allocator);
    skip_iterator.iterator = it;
    skip_iterator.allocator = allocator;
    skip_iterator.predicate = predicate;
    skip_iterator.ctx = ctx;

    next :: (si: ^SkipIterator($T, $Ctx)) -> (T, bool) {
        while !si.skipped {
            value, cont := si.iterator.next(si.iterator.data);

            if !cont {
                si.skipped = true;
                return value, false;
            }

            if !si.predicate(value, si.ctx) {
                si.skipped = true;
                return value, true;
            }
        }

        return si.iterator.next(si.iterator.data);
    }

    close :: (si: ^SkipIterator($T, $Ctx)) {
        if si.iterator.close != null_proc do si.iterator.close(si.iterator.data);
        raw_free(si.allocator, si);
    }

    return .{
        data  = skip_iterator,
        next  = #solidify next  { T=T, Ctx=Ctx },
        close = #solidify close { T=T, Ctx=Ctx },
    };
}

zip :: (left_iterator: Iterator($T), right_iterator: Iterator($R), allocator := context.temp_allocator) -> Iterator(Pair(T, R)) {
    ZippedIterator :: struct (T: type_expr, R: type_expr) {
        iterator1: Iterator(T);
        iterator2: Iterator(R);
        allocator: Allocator;
    }

    zipped_iterator := new(ZippedIterator(T, R), allocator=allocator);
    zipped_iterator.iterator1 = left_iterator;
    zipped_iterator.iterator2 = right_iterator;
    zipped_iterator.allocator = allocator;

    next :: (zi: ^ZippedIterator($T, $R)) -> (Pair(T, R), bool) {
        v1, cont1 := zi.iterator1.next(zi.iterator1.data);
        v2, cont2 := zi.iterator2.next(zi.iterator2.data);

        return .{ v1, v2 }, cont1 && cont2;
    }

    close :: (zi: ^ZippedIterator($T, $R)) {
        if zi.iterator1.close != null_proc do zi.iterator1.close(zi.iterator1.data);
        if zi.iterator2.close != null_proc do zi.iterator2.close(zi.iterator2.data);
        raw_free(zi.allocator, zi);
    }

    return .{
        data  = zipped_iterator,
        next  = #solidify next  { T=T, R=R },
        close = #solidify close { T=T, R=R },
    };
}

concat :: (iters: ..Iterator($T)) -> Iterator(T) {
    Context :: struct (T: type_expr) {
        iters: [] Iterator(T);
        idx:   u32;
    }

    c := new(Context(T), allocator=context.temp_allocator);
    c.iters = memory.copy_slice(iters, allocator=context.temp_allocator);
    c.idx = 0;

    next :: (use c: ^Context($T)) -> (T, bool) {
        while true {
            if idx >= iters.count do return .{}, false;        

            curr_iter := ^iters[idx];
            value, valid := curr_iter.next(curr_iter.data);
            if valid {
                return value, true;
            }

            idx += 1;
        }
    }

    close :: (use c: ^Context($T)) {
        // I don't feel like this should always close ALL the iterators...
        // But I don't know what the semantics should be for specifying which
        // if any iterators to close.
        for^ iters {
            it.close(it.data);
        }

        // memory.free_slice(^iters);
        // cfree(c);
    }

    return .{
        c,
        #solidify next {T=T},
        #solidify close {T=T}
    };
}

const :: (value: $T) -> Iterator(T) {
    next :: (data: ^$T) -> (T, bool) {
        return *(cast(^T) data), true;
    }

    allocated := cast(^T) raw_alloc(context.temp_allocator, sizeof T);
    *allocated = value;

    return .{
        data = allocated,
        next = #solidify next { T=T },
    };
}

#local Enumeration_Value :: struct (T: type_expr) {
    index: i32;
    value: T;
}

enumerate :: #match #local {}

#overload
enumerate :: macro (it: $T/Iterable, start_index: i32 = 0) => {
    as_iterator :: as_iterator
    enumerate :: enumerate
    return enumerate(as_iterator(it), start_index);
}

#overload
enumerate :: (it: Iterator($T), start_index: i32 = 0) -> Iterator(Enumeration_Value(T)) {
    Enumeration_Context :: struct (T: type_expr) {
        iterator:      Iterator(T);
        current_index: i32;
    }

    ec := make(Enumeration_Context(T), allocator=context.temp_allocator);
    ec.iterator = it;
    ec.current_index = start_index;

    next :: (use data: ^Enumeration_Context($T)) -> (Enumeration_Value(T), bool) {
        value, cont := iterator.next(iterator.data);

        if !cont do return .{ current_index, .{} }, false;

        defer current_index += 1;
        return .{ current_index, value }, true;
    }

    close :: (use data: ^Enumeration_Context($T)) {
        if iterator.close != null_proc do iterator.close(iterator.data);
        // cfree(data);
    }

    return .{
        data  = ec,
        next  = #solidify next  { T = T },
        close = #solidify close { T = T },
    };
}

use core.intrinsics.types {type_is_struct}

//
// `from_array` has two almost identical implementations,
// but the details are important here. Normally, `from_array`
// returns an iterator by value, unless the array is of
// structures, then it returns an iterator by pointer.
// This seems weird, but in practice it is closer to what
// you want, as you don't want to have to copy every structure
// out of the array. While for primitives, you don't want to
// dereference it everywhere.
from_array :: #match #local {}

#overload
from_array :: (arr: [] $T/type_is_struct) => generator(
    ^.{ data = arr.data, count = arr.count, current = 0 },

    ctx => {
        if ctx.current < ctx.count {
            defer ctx.current += 1;
            return ^ctx.data[ctx.current], true;
        }

        return null, false;
    }
);

#overload
from_array :: (arr: [] $T) => generator(
    ^.{ data = arr.data, count = arr.count, current = 0 },

    ctx => {
        if ctx.current < ctx.count {
            defer ctx.current += 1;
            return ctx.data[ctx.current], true;
        }

        return .{}, false;
    }
);


#overload
as_iterator :: from_array

#overload
as_iterator :: (x: ^[..] $T) -> Iterator(T) {
    Context :: struct (T: type_expr) {
        arr: ^[..] T;
        current: u32;
    }

    c := make(Context(T), allocator=context.temp_allocator);
    c.arr = x;
    c.current = 0;

    next :: (use _: ^Context($T)) -> (T, bool) {
        if current < arr.count {
            defer current += 1;
            return arr.data[current], true;

        } else {
            return .{}, false;
        }
    }

    remove :: (use _: ^Context($T)) {
        //
        // This is current - 1 because current will have already
        // been incremented by the time this element calls #remove.
        array.delete(arr, current - 1);
        current -= 1;
    }

    return .{
        data  = c,
        next  = #solidify next { T = T },
        remove = #solidify remove { T = T },
    };
}

#overload
as_iterator :: (x: ^[..] $T, by_pointer: bool) -> Iterator(^T) {
    Context :: struct (T: type_expr) {
        arr: ^[..] T;
        current: u32;
    }

    c := make(Context(T), allocator=context.temp_allocator);
    c.arr = x;
    c.current = 0;

    next :: (use _: ^Context($T)) -> (^T, bool) {
        if current < arr.count {
            defer current += 1;
            return ^arr.data[current], true;

        } else {
            return null, false;
        }
    }

    remove :: (use _: ^Context($T)) {
        //
        // This is current - 1 because current will have already
        // been incremented by the time this element calls #remove.
        array.delete(arr, current - 1);
        current -= 1;
    }

    return .{
        data  = c,
        next  = #solidify next { T = T },
        remove = #solidify remove { T = T },
    };
}

#overload
as_iterator :: (r: range) -> Iterator(i32) {
    Context :: struct {
        r: range;
        v: i32;
    }

    next :: (use c: ^Context) -> (i32, bool) {
        if r.step > 0 {
            if v >= r.high {
                return 0, false;
            } else {
                defer v += r.step;
                return v, true;
            }

        } else {
            if v < r.high {
                return 0, false;
            } else {
                defer v += r.step;
                return v, true;
            }
        }
    }

    c := new(Context, allocator=context.temp_allocator);
    c.r = r;
    c.v = r.low;

    return .{
        data  = c,
        next  = next,
    };
}

fold :: #match #local {}

// @Cleanup // some way to shorten this would be nice
#overload
fold :: macro (it: $T/Iterable, init: $R, combine: $S) => {
    fold :: fold
    return fold(as_iterator(it), init, combine);
}

#overload
fold :: (it: Iterator($T), initial_value: $R, combine: (T, R) -> R) -> R {
    for value: it {
        initial_value = combine(value, initial_value);
    }

    return initial_value;
}

count :: #match #local {}

#overload
count :: macro (it: $T/Iterable, cond: $F) => {
    count :: count
    return count(as_iterator(it), cond);
}

#overload
count :: (it: Iterator($T), cond: (T) -> bool) -> i32 {
    c := 0;
    for value: it do if cond(value) do c += 1;
    return c;
}

some :: #match #local {}

#overload
some :: macro (it: $T/Iterable, cond: $F) => {
    some :: some
    as_iterator :: as_iterator
    return some(as_iterator(it), cond);
}

#overload
some :: (it: Iterator($T), cond: (T) -> bool) -> bool {
    for value: it do if cond(value) do return true;
    return false;
}

every :: #match #local {}

#overload
every :: macro (it: $T/Iterable, cond: $F) => {
    every :: every
    as_iterator :: as_iterator
    return every(as_iterator(it), cond);
}

#overload
every :: (it: Iterator($T), cond: (T) -> bool) -> bool {
    for value: it do if !cond(value) do return false;
    return true;
}

prod :: (x: $I1/Iterable, y: $I2/Iterable) => {
    y_iter   := as_iterator(y);
    y_val, _ := take_one(y_iter);

    return generator(
        ^.{
            x = x,
            x_iter = as_iterator(x),

            y_iter = y_iter,
            y_val  = y_val
        },

        ctx => {
            x_val, cont := take_one(ctx.x_iter);
            if cont {
                return Pair.make(x_val, ctx.y_val), true;
            }

            ctx.y_val, cont = take_one(ctx.y_iter);
            if !cont do return .{}, false;

            ctx.x_iter = as_iterator(ctx.x);
            x_val, cont = take_one(ctx.x_iter);
            if !cont do return .{}, false;

            return Pair.make(x_val, ctx.y_val), true;
        }
    );
}


to_array :: (it: Iterator($T), allocator := context.allocator) -> [..] T {
    arr := array.make(T, allocator=allocator);
    for v: it do array.push(^arr, v);

    return arr;
}

//
// Simple iterator comprehensions, in the same vein
// as Pythons comprehension syntax.
// 
// Python:
//     results = [it * 2 for it in [1, 2, 3, 4, 5]]
// Onyx:
//     results := iter.comp(u32.[1, 2, 3, 4, 5], #(it * 2));
comp :: #match #local {}

#overload
comp :: macro (i: Iterator(^$V), value: Code) => {
    it: V;
    a := make([..] typeof #unquote value);

    for __it: i {
        it := *__it;
        a << (#unquote value);
    }
    return a;
}

#overload
comp :: macro (i: Iterator($V), value: Code) => {
    it: V;
    a := make([..] typeof #unquote value);

    for i do a << (#unquote value);
    return a;
}

#overload
comp :: macro (i: $I/Iterable, value: Code) => {
    as_iterator :: as_iterator
    comp        :: comp
    return comp(as_iterator(i), value);
}


//
// Maybe at some point an alternate allocator would be good
// for this? For now, I think the temporary allocator is sufficient.
generator :: #match #local {}

#overload
generator :: (ctx: ^$Ctx, gen: (^Ctx) -> ($T, bool)) -> Iterator(T) {
    v := raw_alloc(context.temp_allocator, sizeof Ctx);
    core.memory.copy(v, ctx, sizeof Ctx);

    return .{
        data = v,
        next = gen
    };
}

#overload
generator :: (ctx: ^$Ctx, gen: (^Ctx) -> ($T, bool), close: (^Ctx) -> void) -> Iterator(T) {
    v := raw_alloc(context.temp_allocator, sizeof Ctx);
    core.memory.copy(v, ctx, sizeof Ctx);

    return .{
        data = v,
        next = gen,
        close = close
    };
}

generator_no_copy :: #match #local {}

#overload
generator_no_copy :: (ctx: ^$Ctx, gen: (^Ctx) -> ($T, bool)) =>
    Iterator(T).{ ctx, gen }

#overload
generator_no_copy :: (ctx: ^$Ctx, gen: (^Ctx) -> ($T, bool), close: (^Ctx) -> void) =>
    Iterator(T).{ ctx, gen, close }



#if runtime.Multi_Threading_Enabled {
    #local sync :: core.sync

    distributor :: #match #local {}

    #overload
    distributor :: macro (it: $T/Iterable) => {
        distributor :: distributor;
        as_iterator :: as_iterator;
        return distributor(as_iterator(it));
    }

    #overload
    distributor :: (it: Iterator) -> Iterator(it.Iter_Type) {
        Context :: struct (T: type_expr) {
            mutex: sync.Mutex;
            iterator: Iterator(T);
            ended := false;
        }

        next :: (use c: ^Context($T)) -> (T, bool) {
            if ended do return .{}, false;
            sync.scoped_mutex(^mutex);

            if v, success := take_one(iterator); !success {
                ended = true;
                return v, false;
            } else {
                return v, true;
            }
        }

        close :: (use c: ^Context($T)) {
            sync.mutex_destroy(^c.mutex);
            delete(c);
        }

        // This iterator's context is allocated from the heap because
        // generally, a distributor iterator will be used across theads
        // in parallel programs. Programs such as those *might* make
        // a lot of iterators in their theads and I don't want to cause
        // the distributor's context be overwritten.
        c := new(Context(it.Iter_Type));
        sync.mutex_init(^c.mutex);
        c.iterator = it;

        return .{c, #solidify next {T=it.Iter_Type}, #solidify close {T=it.Iter_Type}};
    }

    parallel_for :: #match #local {}

    #overload
    parallel_for :: macro (iterable: $I/Iterable, thread_count: u32, thread_data: ^$Ctx, body: Code) {
        parallel_for :: parallel_for;
        as_iterator  :: as_iterator;

        parallel_for(as_iterator(iterable), thread_count, thread_data, body);
    }

    #overload
    parallel_for :: macro (iter: Iterator($T), thread_count: u32, thread_data: ^$Ctx, body: Code) {
        use core {thread, alloc}
        distributor :: distributor;
        as_iterator :: as_iterator;

        if thread_count != 0 {
            dist := distributor(iter);
            t_data := Thread_Data(iter.Iter_Type, Ctx).{
                iter = ^dist,
                data = thread_data,
            };

            threads := alloc.array_from_stack(thread.Thread, thread_count - 1);
            for^ threads do thread.spawn(it, ^t_data, #solidify thread_function {body=body});

            thread_function(^t_data, body);

            for^ threads do thread.join(it);
            dist.close(dist.data);
        }

        Thread_Data :: struct (T: type_expr, Ctx: type_expr) {
            iter: ^Iterator(T);
            data: ^Ctx;
        }

        thread_function :: (__data: ^Thread_Data, $body: Code) {
            thread_data := __data.data;
            for #no_close *__data.iter {
                #unquote body;
            }
        }
    }
}
