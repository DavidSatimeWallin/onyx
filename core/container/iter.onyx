package core.iter

use package core.intrinsics.onyx { __zero_value }

close :: (it: Iterator($T)) {
    it.close(it.data);
}

filter :: (it: Iterator($T), predicate: (T) -> bool) -> Iterator(T) {
    FilterIterator :: struct (T: type_expr) {
        iterator:  Iterator(T);
        predicate: (T) -> bool;
    }

    filter_iterator := new(#type FilterIterator(T));
    filter_iterator.iterator = it;
    filter_iterator.predicate = predicate;

    next :: ($T: type_expr, fi: ^FilterIterator(T)) -> (T, bool) {
        value, cont := fi.iterator.next(fi.iterator.data);
        if cont {
            while !fi.predicate(value) {
                value, cont = fi.iterator.next(fi.iterator.data);
                if !cont do return value, false;
            }

            return value, true;
        } else {
            return value, false;
        }
    }

    close :: ($T: type_expr, fi: ^FilterIterator(T)) {
        if fi.iterator.close != null_proc do fi.iterator.close(fi.iterator.data);
        cfree(fi);
    }

    return .{
        data  = filter_iterator,
        next  = #solidify next  { T=T },
        close = #solidify close { T=T },
    };
}

map :: (it: Iterator($T), transform: (T) -> $R) -> Iterator(R) {
    MapIterator :: struct (T: type_expr, R: type_expr) {
        iterator:  Iterator(T);
        transform: (T) -> R;
    }

    map_iterator := new(#type MapIterator(T, R));
    map_iterator.iterator = it;
    map_iterator.transform = transform;

    next :: ($T: type_expr, $R: type_expr, mi: ^MapIterator(T, R)) -> (R, bool) {
        value, cont := mi.iterator.next(mi.iterator.data);
        if !cont do return __zero_value(R), false;

        return mi.transform(value), true;
    }

    close :: ($T: type_expr, $R: type_expr, mi: ^MapIterator(T, R)) {
        if mi.iterator.close != null_proc do mi.iterator.close(mi.iterator.data);
        cfree(mi);
    }

    return .{
        data  = map_iterator,
        next  = #solidify next  { T=T, R=R },
        close = #solidify close { T=T, R=R },
    };
}

take_one :: (it: Iterator($T)) -> (T, bool) {
    ret, cont := it.next(it.data);
    if !cont do it.close(it.data);
    return ret, cont;
}

// Macro that allows you to extract elements from an iterator in a simple way:
//
// value: i32;
// iterator: Iterator(i32) = ...;
//
// if #(value) << iterator {
//     ...iterater closed...
// }
#operator << macro (dest: Code, it: Iterator($T)) -> bool {
    cont: bool;
    (#insert dest), cont = (package core.iter).take_one(it);
    return !cont;
}

take :: (it: Iterator($T), count: u32) -> Iterator(T) {
    TakeIterator :: struct (T: type_expr) {
        iterator:  Iterator(T);
        remaining: u32;
    }

    take_iterator := new(#type TakeIterator(T));
    take_iterator.iterator = it;
    take_iterator.remaining = count;

    next :: ($T: type_expr, ti: ^TakeIterator(T)) -> (T, bool) {
        if ti.remaining == 0 do return __zero_value(T), false;

        ti.remaining -= 1;
        return ti.iterator.next(ti.iterator.data);
    }

    close :: ($T: type_expr, ti: ^TakeIterator(T)) {
        ti.iterator.close(ti.iterator.data);
        cfree(ti);
    }

    return .{
        data  = take_iterator,
        next  = #solidify next  { T=T },
        close = #solidify close { T=T },
    };
}

take_while :: (it: Iterator($T), predicate: (T) -> bool) -> Iterator(T) {
    TakeIterator :: struct (T: type_expr) {
        iterator:  Iterator(T);
        predicate: (T) -> bool;
    }

    take_iterator := new(#type TakeIterator(T));
    take_iterator.iterator = it;
    take_iterator.predicate = predicate;

    next :: ($T: type_expr, ti: ^TakeIterator(T)) -> (T, bool) {
        value, cont := ti.iterator.next(ti.iterator.data);
        if !cont do return value, false;

        return value, ti.predicate(value);
    }

    close :: ($T: type_expr, ti: ^TakeIterator(T)) {
        if ti.iterator.close != null_proc do ti.iterator.close(ti.iterator.data);
        cfree(ti);
    }

    return .{
        data  = take_iterator,
        next  = #solidify next  { T=T },
        close = #solidify close { T=T },
    };
}

skip :: (it: Iterator($T), count: u32) -> Iterator(T) {
    SkipIterator :: struct (T: type_expr) {
        iterator: Iterator(T);
        to_skip:  i32;
        skipped:  bool = false;
    }

    skip_iterator := new(#type SkipIterator(T));
    skip_iterator.iterator = it;
    skip_iterator.to_skip = count;

    next :: ($T: type_expr, si: ^SkipIterator(T)) -> (T, bool) {
        while !si.skipped && si.to_skip > 0 {
            si.to_skip -= 1;
            value, cont := si.iterator.next(si.iterator.data);

            if !cont {
                si.skipped = true;
                return value, false;
            }
        }

        return si.iterator.next(si.iterator.data);
    }

    close :: ($T: type_expr, si: ^SkipIterator(T)) {
        if si.iterator.close != null_proc do si.iterator.close(si.iterator.data);
        cfree(si);
    }

    return .{
        data  = skip_iterator,
        next  = #solidify next  { T=T },
        close = #solidify close { T=T },
    };
}

#private_file Zipped :: struct (T: type_expr, R: type_expr) {
    first: T;
    second: R;
}

zip :: (left_iterator: Iterator($T), right_iterator: Iterator($R)) -> Iterator(Zipped(T, R)) {
    ZippedIterator :: struct (T: type_expr, R: type_expr) {
        iterator1: Iterator(T);
        iterator2: Iterator(R);
    }

    zipped_iterator := new(#type ZippedIterator(T, R));
    zipped_iterator.iterator1 = left_iterator;
    zipped_iterator.iterator2 = right_iterator;

    next :: ($T: type_expr, $R: type_expr, zi: ^ZippedIterator(T, R)) -> (Zipped(T, R), bool) {
        v1, cont1 := zi.iterator1.next(zi.iterator1.data);
        v2, cont2 := zi.iterator2.next(zi.iterator2.data);

        return .{ v1, v2 }, cont1 && cont2;
    }

    close :: ($T: type_expr, $R: type_expr, zi: ^ZippedIterator(T, R)) {
        if zi.iterator1.close != null_proc do zi.iterator1.close(zi.iterator1.data);
        if zi.iterator2.close != null_proc do zi.iterator2.close(zi.iterator2.data);
        cfree(zi);
    }

    return .{
        data  = zipped_iterator,
        next  = #solidify next  { T=T, R=R },
        close = #solidify close { T=T, R=R },
    };
}

const :: (value: $T) -> Iterator(T) {
    next :: ($T: type_expr, data: rawptr) -> (T, bool) {
        return *(cast(^T) data), true;
    }

    allocated := cast(^T) calloc(sizeof T);
    *allocated = value;

    return .{
        data = allocated,
        next = #solidify next { T=T },
        close = cfree,
    };
}

#private_file Enumeration_Value :: struct (T: type_expr) {
    index: i32;
    value: T;
}

enumerate :: (it: Iterator($T), start_index: i32 = 0) -> Iterator(Enumeration_Value(T)) {
    Enumeration_Context :: struct (T: type_expr) {
        iterator:      Iterator(T);
        current_index: i32;
    }

    ec := make(#type Enumeration_Context(T));
    ec.iterator = it;
    ec.current_index = start_index;

    next :: ($T: type_expr, use data: ^Enumeration_Context(T)) -> (Enumeration_Value(T), bool) {
        value, cont := iterator.next(iterator.data);

        if !cont do return .{ current_index, __zero_value(T) }, false;

        defer current_index += 1;
        return .{ current_index, value }, true;
    }

    close :: ($T: type_expr, use data: ^Enumeration_Context(T)) {
        if iterator.close != null_proc do iterator.close(iterator.data);
        cfree(data);
    }

    return .{
        data  = ec,
        next  = #solidify next  { T = T },
        close = #solidify close { T = T },
    };
}

from_array :: #match {
    (arr: [..] $T) -> Iterator(^T) {
        return from_array((#type [] T).{ arr.data, arr.count });
    },

    (arr: [] $T) -> Iterator(^T) {
        Context :: struct (T: type_expr) {
            data: ^T;
            count: u32;
            current: u32;
        }

        c := make(#type Context(T));
        c.data = arr.data;
        c.count = arr.count;
        c.current = 0;

        next :: ($T: type_expr, use _: ^Context(T)) -> (^T, bool) {
            if current < count {
                defer current += 1;
                return ^data[current], true;

            } else {
                return null, false;
            }
        }

        close :: (data: rawptr) {
            cfree(data);
        }

        return .{
            data  = c,
            next  = #solidify next { T = T },
            close = close,
        };
    }
}

fold :: (it: Iterator($T), initial_value: R, combine: (T, $R) -> R) -> R {
    for value: it {
        initial_value = combine(value, initial_value);
    }
    
    return initial_value;
}

to_array :: (it: Iterator($T), allocator := context.allocator) -> [..] T {
    array :: package core.array

    arr := array.make(T, allocator=allocator);
    for v: it do array.push(^arr, v);

    return arr;
}
