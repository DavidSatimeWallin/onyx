package core.map

#local {
    array  :: package core.array
    hash   :: package core.hash
    memory :: package core.memory
    math   :: package core.math
    conv   :: package core.conv

    use package core.intrinsics.onyx { __zero_value, __initialize }
}

#local {
    ValidKey :: interface (t: $T) {
        // In order to use a certain type as a key in a Map, you must
        // provide an implementation of core.hash.to_u32() for that type,
        // and you must provide an operator overload for ==.

        { hash.to_u32(t) } -> u32;
        { t == t         } -> bool;
    }
}

Map :: struct (Key_Type: type_expr, Value_Type: type_expr) where ValidKey(Key_Type) {
    #struct_tag conv.Custom_Format.{ #solidify format_map {K=Key_Type, V=Value_Type} };

    allocator : Allocator;

    hashes  : [] i32;
    entries : [..] Entry(Key_Type, Value_Type);

    // The value provided by `map.get`, if nothing was found.
    default_value : Value_Type;

    Entry :: struct (K: type_expr, V: type_expr) {
        next  : i32;
        key   : K;
        value : V;
    }

    init    :: init
    has     :: has
    get     :: get
    get_ptr :: get_ptr
    put     :: put
    delete  :: delete
    update  :: update
    clear   :: clear
    empty   :: empty
}

make :: ($Key: type_expr, $Value: type_expr, default := __zero_value(Value)) -> Map(Key, Value) {
    map : Map(Key, Value);
    init(^map, default = default);
    return map;
}

init :: (use map: ^Map($K, $V), default := __zero_value(V)) {
    __initialize(map);

    allocator = context.allocator;
    default_value = default;

    memory.alloc_slice(^hashes, 8, allocator=allocator);
    memory.fill_slice(hashes, -1);

    array.init(^entries, allocator=allocator);
}

free :: (use map: ^Map) {
    memory.free_slice(^hashes, allocator=allocator);
    array.free(^entries);
}

put :: (use map: ^Map, key: map.Key_Type, value: map.Value_Type) {
    lr := lookup(map, key);

    if lr.entry_index >= 0 {
        entries[lr.entry_index].value = value;
        return;
    }

    entries << .{ hashes[lr.hash_index], key, value };
    hashes[lr.hash_index] = entries.count - 1;

    if full(map) do grow(map);
}

has :: (use map: ^Map, key: map.Key_Type) -> bool {
    lr := lookup(map, key);
    return lr.entry_index >= 0;
}

get :: (use map: ^Map, key: map.Key_Type) -> map.Value_Type {
    lr := lookup(map, key);
    if lr.entry_index >= 0 do return entries[lr.entry_index].value;

    return default_value;
}

#operator []  macro (map: Map($K, $V), key: K) -> V do return (package core.map).get(^map, key);
#operator []= macro (map: Map($K, $V), key: K, value: V) do (package core.map).put(^map, key, value);
#operator ^[] macro (map: Map($K, $V), key: K) -> ^V do return (package core.map).get_ptr(^map, key);

get_ptr :: (use map: ^Map, key: map.Key_Type) -> ^map.Value_Type {
    lr := lookup(map, key);
    if lr.entry_index >= 0 do return ^entries[lr.entry_index].value;

    return null;
}

delete :: (use map: ^Map, key: map.Key_Type) {
    lr := lookup(map, key);
    if lr.entry_index < 0 do return;

    if lr.entry_prev < 0   do hashes[lr.hash_index]       = entries[lr.entry_index].next;
    else                   do entries[lr.entry_prev].next = entries[lr.entry_index].next;

    if lr.entry_index == entries.count - 1 {
        array.pop(^entries);
        return;
    }

    array.fast_delete(^entries, lr.entry_index);
    last := lookup(map, entries[lr.entry_index].key);
    if last.entry_prev >= 0    do entries[last.entry_prev].next = lr.entry_index;
    else                       do hashes[last.hash_index] = lr.entry_index;
}

update :: macro (map: ^Map, key: map.Key_Type, body: Code) {
    @Hack // Weird hack because 'lookup' exists at file scope.
    lookup_ :: lookup

    lr := lookup_(map, key);
    if lr.entry_index >= 0 {
        it := ^map.entries[lr.entry_index].value;
        #insert body;
    }
}

clear :: (use map: ^Map) {
    for i: 0 .. hashes.count do hashes.data[i] = -1;
    entries.count = 0;
}

empty :: (use map: ^Map) -> bool {
    return entries.count == 0;
}

format_map :: (output: ^conv.Format_Output, format: ^conv.Format, x: ^Map($K, $V)) {
    output->write("{\n");
    for^ x.entries {
        conv.format(output, "    {\"} => {\"}\n", it.key, it.value);
    }
    output->write("}");
}

//
// Private symbols
//

#local {
    MapLookupResult :: struct {
        hash_index  : i32 = -1;
        entry_index : i32 = -1;
        entry_prev  : i32 = -1;
    }

    lookup :: (use map: ^Map, key: map.Key_Type) -> MapLookupResult {
        if hashes.data == null do init(map);
        lr := MapLookupResult.{};

        hash_value: u32 = hash.to_u32(key); // You cannot use this type for the key, unless you add an overload.

        lr.hash_index = hash_value % hashes.count;
        lr.entry_index = hashes[lr.hash_index];

        while lr.entry_index >= 0 {
            if entries[lr.entry_index].key == key do return lr;

            lr.entry_prev = lr.entry_index;
            lr.entry_index = entries[lr.entry_index].next;
        }

        return lr;
    }

    full :: (use map: ^Map) => entries.count >= ~~(0.75f * ~~hashes.count);

    grow :: (use map: ^Map) {
        new_size := math.max(hashes.count << 1, 8);
        rehash(map, new_size);
    }

    rehash :: (use map: ^Map, new_size: i32) {
        memory.free_slice(^hashes, allocator);
        memory.alloc_slice(^hashes, new_size, allocator);
        memory.fill_slice(hashes, -1);

        for ^entry: entries do entry.next = -1;

        index := 0;
        for ^entry: entries {
            defer index += 1;

            lr := lookup(map, entry.key);
            entries[index].next = hashes[lr.hash_index];
            hashes[lr.hash_index] = index;
        }
    }
}
