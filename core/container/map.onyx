package core.map

#local {
    array  :: package core.array
    hash   :: package core.hash
    memory :: package core.memory
    math   :: package core.math
    conv   :: package core.conv

    use package core.intrinsics.onyx { __initialize }
}

#local {
    ValidKey :: interface (T as t) {
        // In order to use a certain type as a key in a Map, you must
        // provide an implementation of core.hash.to_u32() for that type,
        // and you must provide an operator overload for ==.

        { hash.to_u32(t) } -> u32;
        { t == t         } -> bool;
    }
}

#tag conv.Custom_Format.{
    #solidify format_map {K=Key_Type, V=Value_Type}
}
Map :: struct (Key_Type: type_expr, Value_Type: type_expr) where ValidKey(Key_Type) {
    allocator : Allocator;

    hashes  : [] i32;
    entries : [..] Entry(Key_Type, Value_Type);

    // The value provided by `map.get`, if nothing was found.
    default_value : Value_Type;

    Entry :: struct (K: type_expr, V: type_expr) {
        next  : i32;
        hash  : u32;
        key   : K;
        value : V;
    }

    //
    // These need to have aliases because some of them like
    // 'delete', collide with the global 'delete', which
    // causes it to map to the wrong function.
    init    :: (package core.map).init
    has     :: (package core.map).has
    get     :: (package core.map).get
    get_ptr :: (package core.map).get_ptr
    put     :: (package core.map).put
    delete  :: (package core.map).delete
    update  :: (package core.map).update
    clear   :: (package core.map).clear
    empty   :: (package core.map).empty
}

make :: ($Key: type_expr, $Value: type_expr, default := Value.{}) -> Map(Key, Value) {
    map : Map(Key, Value);
    init(^map, default = default);
    return map;
}

#match (package builtin).__make_overload macro (x: ^Map($K, $V), allocator := context.allocator) => (package core.map).make(K, V);

init :: (use map: ^Map($K, $V), default := V.{}) {
    __initialize(map);

    allocator = context.allocator;
    default_value = default;

    hashes = make([] u32, 8, allocator=allocator);
    array.fill(hashes, -1);

    array.init(^entries, allocator=allocator);
}

free :: (use map: ^Map) {
    if hashes.data != null  do memory.free_slice(^hashes, allocator=allocator);
    if entries.data != null do array.free(^entries);
}

#match (package builtin).delete (package core.map).free

put :: (use map: ^Map, key: map.Key_Type, value: map.Value_Type) {
    lr := lookup(map, key);

    if lr.entry_index >= 0 {
        entries[lr.entry_index].value = value;
        return;
    }

    entries << .{ hashes[lr.hash_index], lr.hash, key, value };
    hashes[lr.hash_index] = entries.count - 1;

    if full(map) do grow(map);
}

has :: (use map: ^Map, key: map.Key_Type) -> bool {
    lr := lookup(map, key);
    return lr.entry_index >= 0;
}

get :: (use map: ^Map, key: map.Key_Type) -> map.Value_Type {
    lr := lookup(map, key);
    if lr.entry_index >= 0 do return entries[lr.entry_index].value;

    return default_value;
}

#operator []  macro (map: Map($K, $V), key: K) -> V do return (package core.map).get(^map, key);
#operator []= macro (map: Map($K, $V), key: K, value: V) do (package core.map).put(^map, key, value);
#operator ^[] macro (map: Map($K, $V), key: K) -> ^V do return (package core.map).get_ptr(^map, key);

get_ptr :: (use map: ^Map, key: map.Key_Type) -> ^map.Value_Type {
    lr := lookup(map, key);
    if lr.entry_index >= 0 do return ^entries[lr.entry_index].value;

    return null;
}

delete :: (use map: ^Map, key: map.Key_Type) {
    lr := lookup(map, key);
    if lr.entry_index < 0 do return;

    if lr.entry_prev < 0   do hashes[lr.hash_index]       = entries[lr.entry_index].next;
    else                   do entries[lr.entry_prev].next = entries[lr.entry_index].next;

    if lr.entry_index == entries.count - 1 {
        array.pop(^entries);
        return;
    }

    array.fast_delete(^entries, lr.entry_index);
    last := lookup(map, entries[lr.entry_index].key);
    if last.entry_prev >= 0    do entries[last.entry_prev].next = lr.entry_index;
    else                       do hashes[last.hash_index] = lr.entry_index;
}

update :: macro (map: ^Map, key: map.Key_Type, body: Code) {
    @Hack // Weird hack because 'lookup' exists at file scope.
    lookup_ :: lookup

    lr := lookup_(map, key);
    if lr.entry_index >= 0 {
        it := ^map.entries[lr.entry_index].value;
        #unquote body;
    }
}

clear :: (use map: ^Map) {
    for i: 0 .. hashes.count do hashes.data[i] = -1;
    entries.count = 0;
}

empty :: (use map: ^Map) -> bool {
    return entries.count == 0;
}

format_map :: (output: ^conv.Format_Output, format: ^conv.Format, x: ^Map($K, $V)) {
    output->write("{\n");
    for^ x.entries {
        conv.format(output, "    {\"} => {\"}\n", it.key, it.value);
    }
    output->write("}");
}

//
// Private symbols
//

#local {
    MapLookupResult :: struct {
        hash_index  : i32 = -1;
        entry_index : i32 = -1;
        entry_prev  : i32 = -1;
        hash        : u32 = 0;
    }

    lookup :: (use map: ^Map, key: map.Key_Type) -> MapLookupResult {
        if hashes.data == null do init(map);
        lr := MapLookupResult.{};

        hash_value: u32 = hash.to_u32(key); // You cannot use this type for the key, unless you add an overload.
        lr.hash = hash_value;

        lr.hash_index = hash_value % hashes.count;
        lr.entry_index = hashes[lr.hash_index];

        while lr.entry_index >= 0 {
            if entries[lr.entry_index].hash == hash_value {
                if entries[lr.entry_index].key == key do return lr;
            }

            lr.entry_prev = lr.entry_index;
            lr.entry_index = entries[lr.entry_index].next;
        }

        return lr;
    }

    full :: (use map: ^Map) => entries.count >= ~~(0.75f * ~~hashes.count);

    grow :: (use map: ^Map) {
        new_size := math.max(hashes.count << 1, 8);
        rehash(map, new_size);
    }

    rehash :: (use map: ^Map, new_size: i32) {
        memory.free_slice(^hashes, allocator);
        hashes = make([] u32, new_size, allocator=allocator);
        array.fill(hashes, -1);

        for ^entry: entries do entry.next = -1;

        index := 0;
        for ^entry: entries {
            defer index += 1;

            lr := lookup(map, entry.key);
            entries[index].next = hashes[lr.hash_index];
            hashes[lr.hash_index] = index;
        }
    }
}
