package core.memory

align :: #match {
    (size: ^u64, align: u64) {
        if *size % align != 0 {
            *size += align - (*size % align);
        }
    },

    (size: u64, align: u64) -> u64 {
        if size % align != 0 {
            size += align - (size % align);
        }
        return size;
    }        
}

copy :: core.intrinsics.wasm.memory_copy
set  :: core.intrinsics.wasm.memory_fill

alloc_slice :: (sl: ^[] $T, count: i32, allocator := context.allocator) {
    sl.data  = raw_alloc(allocator, sizeof T * count);
    sl.count = count;
}

make_slice :: ($T: type_expr, count: i32, allocator := context.allocator) -> [] T {
    return .{
        data = raw_alloc(allocator, sizeof T * count),
        count = count
    };
}

free_slice :: (sl: ^[] $T, allocator := context.allocator) {
    if sl.data == null do return;

    raw_free(allocator, sl.data);
    sl.data = null;
    sl.count = 0;
}

copy_slice :: (sl: [] $T, allocator := context.allocator) -> [] T {
    data := raw_alloc(allocator, sl.count * sizeof T);
    copy(data, sl.data, sl.count * sizeof T);

    return .{ data = data, count = sl.count };
}

resize_slice :: (sl: [] $T, new_size: i32, allocator := context.allocator) -> [] T {
    new_slice: [] T;
    new_slice.data = raw_alloc(allocator, sizeof T * new_size);
    new_slice.count = new_size;

    copy(new_slice.data, sl.data, sl.count * sizeof T);

    return new_slice;
}


#overload
builtin.__make_overload :: macro (_: ^[] $T, count: u32, allocator := context.allocator) -> [] T {
    return (package core.memory).make_slice(T, count, allocator);
}

#overload
builtin.delete :: macro (x: ^[] $T) {
    core.memory.free_slice(x);
}
