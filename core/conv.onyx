package core.conv

Enable_Custom_Formatters :: true

#local {
    map :: package core.map
    string :: package core.string

    custom_formatters: Map(type_expr, (^Format_Output, ^Format, rawptr) -> void);
    custom_parsers   : Map(type_expr, (rawptr, str, Allocator) -> bool);
}

custom_formatters_initialized :: #init () {
    map.init(^custom_formatters, default=null_proc);
    map.init(^custom_parsers,    default=null_proc);

    #if Enable_Custom_Formatters {
        use type_info;

        for type_idx: type_table.count {
            type := type_table[type_idx];
            if type.kind != .Struct do continue;

            s_info := cast(^Type_Info_Struct) type;
            for s_info.tags {
                if it.type == Custom_Format {
                    custom_format := cast(^Custom_Format) it.data;
                    custom_formatters[cast(type_expr) type_idx] = custom_format.format;
                }

                if it.type == Custom_Parse {
                    custom_parse := cast(^Custom_Parse) it.data;
                    custom_parsers[cast(type_expr) type_idx] = custom_parse.parse;
                }
            } 
        }
    }
}

register_custom_formatter :: (formatter: (^Format_Output, ^Format, ^$T) -> void) {
    custom_formatters[T] = formatter;
}

register_custom_parser :: (parser: (^$T, str, Allocator) -> bool) {
    custom_parsers[T] = parser;
}

Custom_Format :: struct {
    format: (^Format_Output, ^Format, rawptr) -> void;
}

Custom_Parse :: struct {
    parse: (rawptr, str, Allocator) -> bool;
}

str_to_i64 :: (s: str, base: u32 = 10) -> i64 {
    use package core

    value: i64 = 0;
    mul := 1;

    if s[0] == #char "-" {
        mul = -1;
        s = string.advance(s, 1);
    }

    if s[0] == #char "+" {
        s = string.advance(s, 1);
    }

    for c: s do switch c {
        case #char "0" .. #char "9" {
            value *= ~~base;
            value += ~~(c - #char "0");
        }

        case #char "A" .. #char "Z" {
            if base <= 10 do fallthrough;

            value *= ~~base;
            value += ~~(c - #char "A");
        }
        
        case #char "a" .. #char "z" {
            if base <= 10 do fallthrough;

            value *= ~~base;
            value += ~~(c - #char "a");
        }

        case #default do break break;
    }

    return value * ~~mul;
}

str_to_f64 :: (s_: str) -> f64 {
    use package core

    // 's' needs to live on the stack to take its address. Stupid optimization
    // that simple structs turn into registers for parameters.
    s := s_;
    string.strip_leading_whitespace(^s);

    sign := parse_sign(^s);
    value, _ := parse_digits(^s);    

    if s[0] == #char "." {
        string.advance(^s, 1);
        fraction, fraction_digits := parse_digits(^s);
        while fraction_digits > 0 {
            fraction_digits -= 1;
            fraction /= 10;
        }
        value += fraction;
    }

    value *= sign;

    if s[0] != #char "e" && s[0] != #char "E" do return value;
    string.advance(^s, 1);

    exponent_sign := parse_sign(^s);
    exponent, _   := parse_digits(^s);
    if exponent_sign > 0 {
        while exponent > 0 {
            value *= 10;
            exponent -= 1;
        }
    } else {
        while exponent > 0 {
            value /= 10;
            exponent -= 1;
        }
    }

    return value;


    parse_sign :: (s: ^str) -> f64 {
        switch s.data[0] {
            case #char "-" { string.advance(s, 1); return -1; }
            case #char "+" { string.advance(s, 1); return  1; }
            case #default  { return 1; }
        }
    }

    parse_digits :: (s: ^str) -> (f64, digit_count: i32) {
        value: f64 = 0;
        count := 0;
        while s.count > 0 do switch s.data[0] {
            case #char "0" .. #char "9" {
                value = value * 10 + ~~cast(i32)(s.data[0] - #char "0");
                string.advance(s, 1);
                count += 1;
            }

            case #default do break break;
        }
        return value, count;
    }
}

i64_to_str :: (n: i64, base: u64, buf: [] u8, min_length := 0, prefix := false) -> str {
    is_neg := false;
    if n < 0 && base == 10 {
        is_neg = true;
        n = -n;
    }

    c := ^buf[buf.count - 1];
    len := 0;

    BASE64_MAP := "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/";

    while n > 0 {
        m := cast(u64) n % base;

        *c = BASE64_MAP[cast(u32) m];
        len += 1;
        c -= 1;

        n /= base;

    } else {
        *c = #char "0";
        len += 1;
        c -= 1;
    }

    if min_length > 0 && len < min_length {
        for i: min_length - len {
            *c = #char "0";
            len += 1;
            c -= 1;
        }
    }

    if prefix {
        if base == 16 {
            *c = #char "x";
            len += 1;
            c -= 1;
            *c = #char "0";
            len += 1;
            c -= 1;
        }

        if base == 2 {
            *c = #char "b";
            len += 1;
            c -= 1;
            *c = #char "0";
            len += 1;
            c -= 1;
        }
    }

    if is_neg {
        *c = #char "-";
        len += 1;
        c -= 1;
    }

    return str.{ data = c + 1, count = len };
}

// This is better than what used to be, but still relies on converting the integer
// part of the float to an integer, which could overflow.
f64_to_str :: (f: f64, buf: [] u8, digits_after_decimal := 4) -> str {
    math :: package core.math

    len := 0;

    if f < 0 {
        f = -f;
        buf[0] = #char "-";
        len += 1;
    }

    dec_part := f - math.trunc(f);
    int_part := f - dec_part;
    dec_part  = math.abs(dec_part);

    s1 := i64_to_str(~~int_part, 10, buf);
    for i: 0 .. s1.count do buf.data[i + len] = s1.data[i];
    buf.data[s1.count + len] = #char ".";
    len += s1.count + 1;

    digits := "0123456789";

    for i: digits_after_decimal {
        dec_part *= 10;
        v := math.trunc(dec_part);
        dec_part -= v;

        buf.data[len + i] = digits[cast(i32) v];
    }
    len += digits_after_decimal;

    return str.{ buf.data, len };
}

@Remove // old aliases to not break old programs
str_format :: format
str_format_va :: format_va

Format_Output :: struct {
    data: ^u8;
    count: u32;
    capacity: u32;

    write :: #match {
        (use output: ^Format_Output, c: u8) {
            if count >= capacity do return;

            data[count] = c;
            count += 1;
        },

        (use output: ^Format_Output, s: str) {
            for c: s {
                if count >= capacity do return;

                data[count] = c;
                count += 1;
            }
        }
    }
}

Format :: struct {
    pretty_printing      := false;
    quote_strings        := false;
    dereference          := false;
    custom_format        := true;
    interpret_numbers    := true;
    digits_after_decimal := cast(u32) 4;

    indentation   := cast(u32) 0;
    base          := cast(u64) 10;
    minimum_width := cast(u32) 0;
}


format :: #match {}
#match format (buffer: [] u8, format: str, va: ..any) -> str {
    return format_va(buffer, format, ~~va); 
}
#match format (output: ^Format_Output, format: str, va: ..any) -> str {
    return format_va(output, format, ~~va); 
}
#match format (buffer: ^[..] u8, format: str, va: ..any) {
    buffer.count = buffer.capacity;
    out := format_va(*buffer, format, ~~va);
    buffer.count = out.count;
}

format_va :: #match {}
#match format_va (buffer: [] u8, format: str, va: [] any) -> str {
    output := Format_Output.{ buffer.data, 0, buffer.count };
    return format_va(^output, format, va);
}
#match format_va (buffer: ^[..] u8, format: str, va: [] any) {
    buffer.count = buffer.capacity;
    out := format_va(*buffer, format, va);
    buffer.count = out.count;
}

#match format_va (output: ^Format_Output, format: str, va: [] any) -> str {
    vararg_index := 0;

    while i := 0; i < format.count {
        defer i += 1;

        ch := format[i];
        formatting := Format.{};

        if ch == #char "{" {
            if format[i + 1] == #char "{" {
                output->write(#char "{");
                i += 1;
                continue;
            }

            i += 1;
            while true {
                ch = format[i];

                switch ch {
                    case #char "*" {
                        i += 1;
                        formatting.dereference = true;
                    }

                    case #char "." {
                        i += 1;

                        digits := 0;
                        while format[i] >= #char "0" && format[i] <= #char "9" {
                            digits *= 10;
                            digits += ~~(format[i] - #char "0");
                            i += 1;
                        }

                        ch = format[i];
                        formatting.digits_after_decimal = digits;
                    }

                    case #char "p" {
                        i += 1;
                        formatting.pretty_printing = true;
                    }

                    case #char "x" {
                        i += 1;
                        formatting.base = 16;
                    }

                    case #char "b" {
                        i += 1;

                        digits := 0;
                        while format[i] >= #char "0" && format[i] <= #char "9" {
                            digits *= 10;
                            digits += ~~(format[i] - #char "0");
                            i += 1;
                        }

                        formatting.base = ~~digits;
                    }

                    case #char "w" {
                        i += 1;

                        digits := 0;
                        while format[i] >= #char "0" && format[i] <= #char "9" {
                            digits *= 10;
                            digits += ~~(format[i] - #char "0");
                            i += 1;
                        }

                        formatting.minimum_width = ~~digits;
                    }

                    case #char "!" {
                        i += 1;
                        formatting.custom_format = false;
                    }

                    case #char "\"" {
                        i += 1;
                        formatting.quote_strings = true;
                    }

                    case #char "d" {
                        i += 1;
                        formatting.interpret_numbers = false;
                    }

                    case #char "}" {
                        arg := va[vararg_index];
                        vararg_index += 1;
                        format_any(output, ^formatting, arg);

                        break break;
                    }

                    case #default do break break;
                }
            }
        }

        if ch == #char "}" {
            if format[i + 1] == #char "}" {
                output->write(#char "}");
                i += 1;
                continue;
            }

            continue;
        }

        output->write(ch);
    }

    return .{ output.data, output.count };
}

format_any :: (output: ^Format_Output, formatting: ^Format, v: any) {
    use package builtin.type_info
    array :: package core.array;

    if formatting.dereference {
        ti := get_type_info(v.type);
        if ti.kind == .Pointer {
            formatting.dereference = false;

            new_any: any;
            new_any.type = (cast(^Type_Info_Pointer) ti).to;
            new_any.data = *(cast(^rawptr) v.data);
            format_any(output, formatting, new_any);
            return;
        }
    }

    if formatting.custom_format && custom_formatters->has(v.type) {
        custom_formatters[v.type](output, formatting, v.data);
        return;
    }

    switch v.type {
        case bool {
            value := *(cast(^bool) v.data);
            if value do output->write("true");
            else     do output->write("false");
        }

        case u8 {
            value := *(cast(^u8) v.data);

            if value > 31 {
                output->write(value);

            } else {
                ibuf : [128] u8;
                istr := i64_to_str(~~value, 16, ~~ibuf, prefix=true);
                output->write(istr);
            }
        }

        case i16, u16 {
            value := *(cast(^i16) v.data);

            ibuf : [128] u8;
            istr := i64_to_str(~~value, formatting.base, ~~ibuf, min_length=formatting.minimum_width);
            output->write(istr);
        }

        case i32, u32 {
            value := *(cast(^i32) v.data);

            ibuf : [128] u8;
            istr := i64_to_str(~~value, formatting.base, ~~ibuf, min_length=formatting.minimum_width);
            output->write(istr);
        }

        case i64, u64 {
            value := *(cast(^i64) v.data);

            ibuf : [128] u8;
            istr := i64_to_str(~~value, formatting.base, ~~ibuf);
            output->write(istr);
        }

        case f32 {
            value := *(cast(^f32) v.data);

            fbuf : [128] u8;
            fstr := f64_to_str(~~value, ~~fbuf, formatting.digits_after_decimal);
            output->write(fstr);
        }

        case f64 {
            value := *(cast(^f64) v.data);

            fbuf : [128] u8;
            fstr := f64_to_str(~~value, ~~fbuf, formatting.digits_after_decimal);
            output->write(fstr);
        }

        case str {
            if formatting.quote_strings do output->write("\"");
            width := formatting.minimum_width;
            to_output := *cast(^str) v.data;

            @Todo // escape '"' when quote_strings is enabled.
            output->write(to_output);
            if to_output.count < width && !formatting.quote_strings {
                for width - to_output.count do output->write(#char " ");
            }

            if formatting.quote_strings do output->write("\"");
        }

        case rawptr {
            value := *(cast(^rawptr) v.data);

            if value == null {
                output->write("(null)");
            } else {
                ibuf : [128] u8;
                istr := i64_to_str(~~value, 16, ~~ibuf, prefix=true);
                output->write(istr);
            }
        }

        case type_expr {
            value := *(cast(^type_expr) v.data);

            io :: package core.io

            buf : [256] u8;          

            // This is a little gross but the only way to output the type name for a type_expr
            // is through a io.Writer. That should maybe be changed in the future? Also, I think
            // 256 bytes is enough for the name of a type but I'm not entirely sure...
            stream := io.string_stream_make(~~buf);
            writer := io.writer_make(^stream);
            type_info.write_type_name(^writer, value);

            output->write(io.string_stream_to_str(^stream));
        }

        case #default {
            info := get_type_info(v.type);

            if info.kind == .Struct {
                s := cast(^Type_Info_Struct) info;

                if s.name.count > 0 {
                    output->write(s.name);
                    output->write(" { ");
                } else {
                    output->write("{ ");
                }

                {
                    format := *formatting;
                    format.quote_strings = true;
                    if format.pretty_printing {
                        format.indentation += 4;
                    }
                    
                    for ^member: s.members {
                        if member != s.members.data do output->write(", ");

                        if formatting.pretty_printing {
                            output->write(#char "\n");
                            for i: format.indentation do output->write(#char " ");
                        }

                        output->write(member.name);
                        output->write(" = ");

                        format_any(output, ^format, .{ ~~(cast(^u8) v.data + member.offset), member.type });
                    }
                }
                
                if formatting.pretty_printing {
                    output->write(#char "\n");
                    for i: formatting.indentation do output->write(#char " ");
                    output->write("}");
                    
                } else {
                    output->write(" }");
                }
            }

            if info.kind == .Function {
                output->write("func[");

                value := *(cast(^i32) v.data);

                ibuf : [128] u8;
                istr := i64_to_str(~~value, 10, ~~ibuf);
                output->write(istr);

                output->write("]");
            }

            if info.kind == .Pointer {
                value := *(cast(^rawptr) v.data);

                ibuf : [128] u8;
                istr := i64_to_str(~~value, 16, ~~ibuf, prefix=true);
                output->write(istr);
            }

            // This assumes that the following type_info kinds are basically the same.
            if info.kind == .Dynamic_Array || info.kind == .Slice || info.kind == .Variadic_Argument {
                if formatting.pretty_printing {
                    output->write("[");
                } else {
                    output->write("[ ");
                }

                a := cast(^Type_Info_Dynamic_Array) info;
                arr := cast(^array.Untyped_Array) v.data;
                data  := arr.data;
                count := arr.count;

                format := *formatting;
                format.quote_strings = true;
                if format.pretty_printing do format.indentation += 4;

                for i: count {
                    if i != 0 do output->write(", ");

                    if formatting.pretty_printing {
                        output->write("\n");
                        for _: format.indentation do output->write(#char " ");
                    }

                    format_any(output, ^format, .{ ~~(cast(^u8) data + get_type_info(a.of).size * i), a.of });
                }


                if formatting.pretty_printing {
                    format.indentation -= 4;
                    output->write("\n");
                    for _: format.indentation do output->write(#char " ");
                    output->write(#char "]");

                } else {
                    output->write(" ]");
                }
            }

            if info.kind == .Array {
                output->write("[ ");

                a := cast(^Type_Info_Array) info;
                data := v.data;

                for i: a.count {
                    if i != 0 do output->write(", ");

                    format_any(output, formatting, .{ ~~(cast(^u8) data + get_type_info(a.of).size * i), a.of });
                }

                output->write(" ]");
            }

            if info.kind == .Enum {
                e := cast(^Type_Info_Enum) info;

                value: u64;
                switch e.backing_type {
                    case i8,  u8  do value = cast(u64) *(cast(^u8) v.data);
                    case i16, u16 do value = cast(u64) *(cast(^u16) v.data);
                    case i32, u32 do value = cast(u64) *(cast(^u32) v.data);
                    case i64, u64 do value = cast(u64) *(cast(^u64) v.data);
                    case #default do assert(false, "Bad enum backing type");
                }

                if !formatting.interpret_numbers {
                    format_any(output, formatting, .{^value, u64});
                    break;
                }

                if !e.is_flags {
                    for ^member: e.members {
                        if value == member.value {
                            output->write(member.name);
                            break break;
                        }
                    }

                    output->write("UNKNOWN");

                } else {
                    first := true;
                    for ^member: e.members {
                        if value & member.value != 0 {
                            if !first do output->write(" | ");
                            output->write(member.name);
                            first = false;
                        }
                    }

                    if first {
                        output->write("None");
                    }
                }
            }

            if info.kind == .Distinct {
                d := cast(^Type_Info_Distinct) info;

                if formatting.interpret_numbers {
                    output->write(d.name);
                    output->write("[");
                }

                format_any(output, formatting, any.{ v.data, d.base_type });

                if formatting.interpret_numbers {
                    output->write("]");
                }
            }
        }
    }
}

//
// This should be called with a pointer for the first argument.
//
//      x: i32;
//      parse_any(^x, "12.34");
parse_any :: #match {}
#match parse_any (v: any, to_parse: str, string_allocator := context.allocator) -> bool {
    use type_info;

    info := get_type_info(v.type);
    if info.kind != .Pointer do return false;

    data_type := (cast(^Type_Info_Pointer) info).to;
    target := *cast(^rawptr) v.data;
    return parse_any(target, data_type, to_parse, string_allocator);
}

#match parse_any (target: rawptr, data_type: type_expr, to_parse: str, string_allocator := context.allocator) -> bool {
    if custom_parsers->has(data_type) {
        return custom_parsers[data_type](target, to_parse, string_allocator);
    }

    use type_info;
    info := get_type_info(data_type);

    switch data_type {
        case bool {
            dest := cast(^bool) target;
            *dest = false;
            if to_parse[0] == #char "t" || to_parse[0] == #char "T" {
                *dest = true;
            }
            return true;
        }

        integer_case :: macro (T: type_expr) {
            case T {
                dest := cast(^T) target;
                *dest = cast(T) str_to_i64(to_parse);
                return true;
            }
        }

        integer_case(i8);
        integer_case(i16);
        integer_case(i32);
        integer_case(i64);
        integer_case(u8);
        integer_case(u16);
        integer_case(u32);
        integer_case(u64);

        case f32 {
            dest := cast(^f32) target;
            *dest = ~~ str_to_f64(to_parse);
            return true;
        }

        case f64 {
            dest := cast(^f64) target;
            *dest = ~~ str_to_f64(to_parse);
            return true;
        }

        case str {
            if to_parse[0] != #char "\"" do return false;
            line := to_parse;
            string.advance(^line);

            //
            // For now, this will return a substring in the original to_parse.
            dest := cast(^str) target;
            *dest = string.read_until(^line, #char "\"") |> string.alloc_copy(string_allocator); @BUG // This does not handle escaped strings!
            return true;
        }

        case #default {
            if info.kind == .Enum {
                // TEMPORARY this needs to look at the backing type for the
                // enum in order to know how large this integer should be.
                *cast(^u32) target = ~~ str_to_i64(to_parse);
                return true;
            }
        }
    }

    return false;
}


