
package core.js

use core.iter
use core.math

Value :: #distinct u64

Type :: enum {
    Undefined :: 0;
    Null      :: 1;
    Boolean   :: 2;
    Number    :: 3;
    String    :: 4;
    Symbol    :: 5;
    Object    :: 6;
    Function  :: 7;
}

#inject Value {
    Undefined  :: Value.{0}
    NaN        :: Value.{0x7ff8000000000000}
    Zero       :: Value.{0x7ff8000000000001}
    Null       :: Value.{0x7ff8000000000002}
    True       :: Value.{0x7ff8000000000003}
    False      :: Value.{0x7ff8000000000004}
    Global     :: Value.{0x7ff8000000000005}
    Onyx       :: Value.{0x7ff8000000000006}

    new_object :: () -> Value {
        return __new_object();
    }

    from :: (a: any) -> ? Value {
        switch a.type {
            case i32, u32 {
                // Integers are simply upcasted to float64s
                v := cast(f64) *cast(&i32, a.data);
                if v == 0 do return Value.Zero;

                return *cast(&Value) &v;
            }

            case i64, u64 {
                // Integers are simply upcasted to float64s, even with a loss of precision
                // Gotta love JS.
                v := cast(f64) *cast(&i64, a.data);
                if v == 0 do return Value.Zero;

                return *cast(&Value) &v;
            }

            case f32 {
                v := cast(f64) *cast(&f32, a.data);
                if v == 0 do return Value.Zero;

                return *cast(&Value) &v;
            }

            case f64 {
                v := *cast(&f64, a.data);
                if v == 0 do return Value.Zero;

                return *cast(&Value) &v;
            }

            case bool {
                if *cast(&bool, a.data) do return Value.True;
                else                    do return Value.False;
            }
        }

        if a.type == str {
            return __from_str(*cast(&str) a.data);
        }

        if a.type == #type (Value, [] Value) -> Value {
            f := *cast(&(Value, [] Value) -> Value) a.data;
            return cast(Value) Func.from(f);
        }

        if a.type == Value do return *cast(&Value) a.data;
        if a.type == Func  do return *cast(&Value) a.data; // Funcs right now are just values

        return .None;
    }

    as_bool :: (v: Value) -> ? bool {
        if cast(u64) v == cast(u64) Value.True  do return true;
        if cast(u64) v == cast(u64) Value.False do return false;

        return .None;
    }

    as_float :: (v: Value) -> ? f64 {
        v_u64 := cast(u64, v);
        v_f64 := *cast(&f64, &v_u64);
        if !math.is_nan(v_f64) {
            return v_f64;
        }

        return .None;
    }

    as_int :: (v: Value) -> ? i32 {
        v_u64 := cast(u64, v);
        v_f64 := *cast(&f64, &v_u64);
        if !math.is_nan(v_f64) {
            return cast(i32) v_f64;
        }

        return .None;
    }

    as_str :: (v: Value) -> ? str {
        // If is identifier, look up string length
            // Call another procedure to get data
    }

    type :: (v: Value) -> Type {
        v_u64 := cast(u64, v);

        // TODO: Cleanup these magic constants.
        if v_u64 == 0                  do return .Undefined;
        if v_u64 == 0x7ff8000000000001 do return .Number;
        if v_u64 == 0x7ff8000000000002 do return .Null;
        if v_u64 == 0x7ff8000000000003 do return .Boolean;
        if v_u64 == 0x7ff8000000000004 do return .Boolean;
        if v_u64 == 0x7ff8000000000005 do return .Object;
        if v_u64 == 0x7ff8000000000006 do return .Object;

        if !math.is_nan(*cast(&f64, &v_u64)) do return .Number;

        type_flag: u32 = ~~((v_u64 >> 32) & 7);
        switch type_flag {
            case 0 do return .Null;
            case 1 do return .Object;
            case 2 do return .String;
            case 3 do return .Symbol;
            case 4 do return .Function;
        }

        return .Undefined;
    }

    call :: (v: Value, method: str, args: ..any) -> Value {
        transform_args(cast([] any) args, [](__method(v, method, mapped_args)));
    }

    invoke :: (v: Value, args: ..any) -> Value {
        transform_args(cast([] any) args, [](do {
            return __call(v, mapped_args);
        }));
    }

    free :: (v: Value) {
        return __free(v);
    }

    delete :: (v: Value, property: str) {
        return __delete(v, property);
    }

    equals :: (v1: Value, v2: Value) -> bool {
        return cast(u64, v1) == cast(u64, v2) && cast(u64, v1) != cast(u64, Value.NaN);
    }

    is_null :: (v: Value) -> bool {
        return cast(u64) v == cast(u64) Value.Null;
    }

    is_undefined :: (v: Value) -> bool {
        return cast(u64) v == cast(u64) Value.Undefined;
    }

    is_nan :: (v: Value) -> bool {
        return cast(u64) v == cast(u64) Value.NaN;
    }

    instance_of :: (v: Value, base: Value) -> bool {
        return __instance_of(v, base);
    }

    new :: (v: Value, args: ..any) -> Value {
        transform_args(cast([] any) args, [](__new(v, mapped_args)));
    }

    get :: (v: Value, prop: str) -> Value {
        return __dot(v, prop);
    }

    set :: #match #locked {
        (v: Value, prop: str, value: Value) {
            __set(v, prop, value);
        },

        (v: Value, prop: str, value: any) {
            js_value := Value.from(value) ?? Value.Undefined;
            __set(v, prop, js_value);
            js_value->free();
        },

        (v: Value, index: i32, value: Value) {
            __set_index(v, index, value);
        },

        (v: Value, index: i32, value: any) {
            js_value := Value.from(value) ?? Value.Undefined;
            __set_index(v, index, js_value);
            js_value->free();
        }
    }

    index :: (v: Value, i: i32) -> Value {
        return __sub(v, i);
    }
    
    truthy :: (v: Value) -> bool {

    }
}


#local
transform_args :: macro (args: [] any, $body: Code) {
    mapped_args:  [..] Value;
    args_to_free: [..] Value;
    defer {
        for to_free in args_to_free {
            to_free->free();
        }

        delete(&mapped_args);
        delete(&args_to_free);
    }
    
    for arg in args {
        if arg.type == Value || arg.type == Func {
            mapped_args << *cast(&Value, arg.data);
        } else {
            generated := Value.from(arg) ?? Value.Undefined;
            mapped_args << generated;
            args_to_free << generated;
        }
    }

    return #unquote body;
}


