package core.io

memory :: package core.memory
math   :: package core.math

Reader :: struct {
    stream : ^Stream;

    buffer: [] u8;
    buffer_allocator: Allocator;

    start, end: u32; // The start and ending positions of the edges of the buffer "window".    

    last_byte: i32;

    error: Error;

    done : bool; // If an .EOF was reached.
}

reader_make :: (s: ^Stream, buffer_size := 4096, allocator := context.allocator) -> Reader {
    assert(s.vtable != null, "Stream vtable was not setup correctly.");

    reader: Reader;
    reader.stream = s;
    reader.error = .None;

    memory.alloc_slice(^reader.buffer, buffer_size, allocator);
    reader.buffer_allocator = allocator;

    reader_reset(^reader);

    return reader;
}

reader_reset :: (use reader: ^Reader) {
    start, end = 0, 0;
    last_byte = #char "\0";
    done = false;
}

reader_free :: (use reader: ^Reader) {
    memory.free_slice(^buffer, buffer_allocator);
}

// You need to free the StringStream from the context.allocator when you use this. For example,
//      reader, stream := reader_from_string(s);
//      defer cfree(stream);
reader_from_string :: (s: str) -> (Reader, ^StringStream) {
    stream_ptr := new(StringStream);
    *stream_ptr = string_stream_make(s);

    return reader_make(stream_ptr), stream_ptr;
}

reader_get_buffered :: (use reader: ^Reader) -> i32 {
    return end - start;
}

reader_empty :: (use reader: ^Reader) -> bool {
    return done && reader_get_buffered(reader) == 0;
}

read_all :: (use reader: ^Reader, allocator := context.allocator) -> [] u8 {
    array :: package core.array
    output := array.make(u8, 128, allocator=allocator);

    while !reader_empty(reader) {
        if err := reader_read_next_chunk(reader); err != .None do break;
        if error != .None {
            reader_consume_error(reader);
            break;
        }

        buffered := reader_get_buffered(reader);
        if buffered > 0 {
            array.ensure_capacity(^output, output.count + buffered);
            memory.copy(output.data + output.count, buffer.data, buffered);
            output.count += buffered;
            start = end;
        }
    }

    return output;
}

read_byte :: (use reader: ^Reader) -> u8 {
    while start == end {
        if reader_empty(reader) do return 0;

        if error != .None {
            reader_consume_error(reader);
            return 0;
        }

        if err := reader_read_next_chunk(reader); err != .None {
            return 0;
        }
    }

    byte := buffer[start];
    start += 1;
    last_byte = cast(i32) byte;
    return byte;
}

unread_byte :: (use reader: ^Reader) -> Error {
    if last_byte < 0 || (start == 0 && end > 0) {
        return .InvalidUnread;
    }

    if start > 0 {
        start -= 1;
    } else {
        end = 1;
    }

    buffer[start] = cast(u8) last_byte;
    last_byte = -1;
    return .None;
}

read_bytes :: (use reader: ^Reader, bytes: [] u8) -> (i32, Error) {
    n := bytes.count;
    if n == 0 {
        if reader_get_buffered(reader) > 0 do return 0, .None;
        return 0, reader_consume_error(reader);
    }

    if start == end {
        if error != .None do return 0, reader_consume_error(reader);
        if reader_empty(reader) do return 0, reader_consume_error(reader);

        if n >= buffer.count {
            error, n = stream_read(stream, bytes);

            if n > 0 do last_byte = cast(i32) bytes[n - 1];

            return n, reader_consume_error(reader);
        }

        start, end = 0, 0;
        error, n = stream_read(stream, buffer);
        if n == 0 do return 0, reader_consume_error(reader);
        end += n;
    }

    memory.copy(bytes.data, buffer.data + start, n);
    start += n;
    last_byte = cast(i32) buffer[start - 1];
    return n, .None;
}

read_string :: (use reader: ^Reader, bytes := 1, allocator := context.allocator) -> str {
    buf := memory.make_slice(u8, bytes, allocator);
    bytes_read, err := read_bytes(reader, buf);
    return buf[0 .. bytes_read];
};

read_i32 :: (use reader: ^Reader) -> i32 {
    n: i32 = 0;

    skip_whitespace(reader);

    is_negative := false;
    curr, err := peek_byte(reader);
    if curr == #char "-" {
        is_negative = true;
        start += 1;
    }

    curr, err = peek_byte(reader);
    while curr >= #char "0" && curr <= #char "9" {
        n *= 10;
        n += cast(u32) (curr - #char "0"); 

        start += 1;
        curr, err = peek_byte(reader);
        if err != .None || start == end do break;
    }

    if is_negative do n = -n;
    return n;
}

read_i64 :: (use reader: ^Reader) -> i64 {
    n: i64 = 0;

    skip_whitespace(reader);

    is_negative := false;
    curr, err := peek_byte(reader);
    if curr == #char "-" {
        is_negative = true;
        start += 1;
    }

    curr, err = peek_byte(reader);
    while curr >= #char "0" && curr <= #char "9" {
        n *= 10;
        n += cast(u64) (curr - #char "0"); 

        start += 1;
        curr, err = peek_byte(reader);
        if err != .None || start == end do break;
    }

    if is_negative do n = -n;
    return n;
}

read_u32 :: (use reader: ^Reader) -> u32 {
    n: u32 = 0;

    skip_whitespace(reader);

    curr, err := peek_byte(reader);
    while curr >= #char "0" && curr <= #char "9" {
        n *= 10;
        n += cast(u32) (curr - #char "0"); 

        start += 1;
        curr, err = peek_byte(reader);
        if err != .None || start == end do break;
    }

    return n;
}

read_u64 :: (use reader: ^Reader) -> u64 {
    n: u64 = 0;

    skip_whitespace(reader);

    curr, err := peek_byte(reader);
    while curr >= #char "0" && curr <= #char "9" {
        n *= 10;
        n += cast(u64) (curr - #char "0"); 

        start += 1;
        curr, err = peek_byte(reader);
        if err != .None || start == end do break;
    }

    return n;
}

read_line :: (use reader: ^Reader, consume_newline := true, allocator := context.allocator, inplace := false) -> str {
    reader_read_next_chunk(reader);

    count := start;
    defer start = count;

    while count < end && buffer[count] != #char "\n" {
        count += 1;
    }

    if consume_newline && count < end {
        count += 1;
    }

    if inplace do return buffer[start .. count];

    out := memory.make_slice(u8, count - start);
    memory.copy(out.data, buffer.data + start, count - start);
    return out;
}

read_word :: (use reader: ^Reader, numeric_allowed := false, allocator := context.allocator, inplace := false) -> str {
    skip_whitespace(reader);
    reader_read_next_chunk(reader);

    count := start;
    defer start = count;
    while count < end {
        curr := buffer[count];
        if     (curr >= #char "a" && curr <= #char "z")
            || (curr >= #char "A" && curr <= #char "Z")
            || curr == #char "_" {
            count += 1;
        } elseif numeric_allowed && (curr >= #char "0" && curr <= #char "9") {
            count += 1;
        } else {
            break;
        }
    }

    if inplace do return buffer[start .. count];

    out := memory.make_slice(u8, count - start);
    memory.copy(out.data, buffer.data + start, count - start);
    return out;
}

read_until :: (use reader: ^Reader, until: u8, skip: u32 = 0, allocator := context.allocator, consume_end := false, inplace := false) -> str {
    reader_read_next_chunk(reader);

    count := start;
    defer start = count;
    while count < end {
        curr := buffer[count];
        if curr != until {
            count += 1;
        } else {
            if skip == 0 do break;
            else do skip -= 1;
        }
    }

    if consume_end && count < end do count += 1;

    if inplace do return buffer[start .. count];

    out := memory.make_slice(u8, count - start);
    memory.copy(out.data, buffer.data + start, count - start);
    return out;
}

peek_byte :: (use reader: ^Reader) -> (u8, Error) {
    if start == end {
        if fill_err := reader_read_next_chunk(reader); fill_err != .None {
            return 0, fill_err;
        }
    }

    return buffer[start], .None;
}

advance_line :: (use reader: ^Reader) {
    while true {
        if start == end {
            if fill_err := reader_read_next_chunk(reader); fill_err != .None {
                return;
            }
        }

        defer start += 1;
        if buffer[start] == #char "\n" {
            return;
        }
    }
}

skip_whitespace :: (use reader: ^Reader) {
    while start < end {
        if start == end {
            if fill_err := reader_read_next_chunk(reader); fill_err != .None {
                return;
            }
        }

        switch buffer[start] {
            case #char " ", #char "\t", #char "\n", #char "\r" {
                start += 1;
            }

            case #default do return;
        }
    }
}

skip_bytes :: (use reader: ^Reader, bytes: u32) -> (skipped: i32, err: Error) {
    if bytes == 0 do return 0, .None;

    remaining := bytes;
    while true {
        skip := reader_get_buffered(reader);
        if skip == 0 {
            if fill_err := reader_read_next_chunk(reader); fill_err != .None {
                return 0, fill_err;
            }

            skip = reader_get_buffered(reader);
        }

        skip = math.min(skip, remaining);
        start += skip;
        remaining -= skip;

        if remaining == 0 do return bytes, .None;

        if error != .None {
            return bytes - remaining, reader_consume_error(reader);
        }
    }

    return 0, .None;
}

#local reader_consume_error :: (use reader: ^Reader) -> Error {
    defer error = .None;
    return error;
}

#local reader_read_next_chunk :: (use reader: ^Reader) -> Error {
    if done do return .None;

    if start > 0 {
        // This assumes that memory.copy behaves like memmove, in that the
        // buffer may overlap, but it should do the right thing.
        memory.copy(buffer.data, buffer.data + start, end - start);
        end -= start;
        start = 0;
    }

    if end >= buffer.count {
        return .BufferFull;
    }

    // Try to re-read multiple times
    for 16 {
        err, n := stream_read(stream, buffer[end .. buffer.count]);
        end += n;
        if err != .None {
            if err == .EOF do done = true;

            error = err;
            return .None;
        }

        if n > 0 {
            return .None;
        }
    }

    done = true;
    error = .NoProgress;
    return .None;
}