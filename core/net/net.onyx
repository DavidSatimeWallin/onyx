package core.net

#if !runtime.platform.Supports_Networking {
    #error "Cannot include this file. Platform not supported.";
}

use core {*}
use runtime

Socket :: struct {
    use stream : io.Stream;
    handle: runtime.platform.SocketData;

    type: SocketType;
    family: SocketFamily;
    proto: SocketProto;
}

// Inject methods for the socket
#inject Socket {
    close     :: socket_close
    setting   :: socket_setting
    is_alive  :: socket_is_alive
    bind      :: socket_bind
    listen    :: socket_listen
    accept    :: socket_accept
    connect   :: socket_connect
    shutdown  :: socket_shutdown
    send      :: socket_send
    sendto    :: socket_sendto
    sendall   :: socket_sendall
    recv      :: socket_recv
    recv_into :: socket_recv_into
    recvfrom  :: socket_recvfrom
    poll      :: socket_poll
}

SocketFamily :: enum {
    Unknown :: 0x00;
    Inet    :: 0x01;
    Inet6   :: 0x02;
    Unix    :: 0x03;
}

SocketType :: enum {
    Stream :: 0x00;
    Dgram  :: 0x01;
}

SocketProto :: enum {
    IP   :: 0x00;
    ICMP :: 0x01;
    IGMP :: 0x02;
    TCP  :: 0x06;
    UDP  :: 0x11;
    IPV6 :: 0x29;
}

SocketSetting :: enum {
    NonBlocking  :: 0x01;
    Broadcast    :: 0x02;
    ReuseAddress :: 0x03;
}

SocketShutdown :: enum {
    Read :: 0;
    Write :: 1;
    ReadWrite :: 2;
}

#local UNIX_SOCKET_PATH_LEN :: 256

SocketAddress :: union {
    // Null-terminated string
    Unix: [UNIX_SOCKET_PATH_LEN] u8;

    Inet: struct {
        port: u16;
        addr: u32;
    };

    Inet6: struct {
        port: u16;
        addr_h: u64;
        addr_l: u64;
    };
}

#inject
SocketAddress.addr_as_str :: (this: &SocketAddress, allocator := context.allocator) -> str {
    return switch *this {
        case path: .Unix => string.as_str(cast(cstr) path);
        case inet: .Inet => do {
            str_addr := ipv4_to_str(inet.addr);
            out := make(dyn_str, allocator);
            return conv.format(&out, "{}:{}", str_addr, inet.port);
        }
        case inet6: .Inet6 => do {
            str_addr := ipv6_to_str(inet6.addr_h, inet6.addr_l);
            out := make(dyn_str, allocator);
            return conv.format(&out, "{}:{}", str_addr, inet6.port);
        }
    };
}

make_ipv4_address :: (out: &SocketAddress, addr: u32, port: u16) {
    *out = .{ Inet = .{ port = port, addr = addr } };
}

make_unix_address :: (out: &SocketAddress, path: str) {
    *out = .{ Unix = .{} };

    out_path := cast([&] u8) out + alignof out.tag_enum;
    offset   := 0;
    while offset < math.min(path.count, UNIX_SOCKET_PATH_LEN - 1) {
        defer offset += 1;

        out_path[offset] = path[offset];
    }

    out_path[offset] = 0;
}

socket_create :: (family: SocketFamily, type: SocketType, proto: SocketProto) -> Result(Socket, io.Error) {
    s: Socket;
    s.type = type;
    s.family = family;
    s.proto = proto;

    socket := runtime.platform.__net_sock_create(family, type, proto)?;
    s.handle = socket;

    s.flags |= .Block_On_Read;

    return .{ Ok = s };
}

socket_from_fd :: (fd: runtime.platform.SocketData) -> Socket {
    return Socket.{
        stream = .{ vtable = &__net_socket_vtable },
        handle = fd,
    };
}

socket_close :: (s: &Socket) {
    runtime.platform.__net_sock_close(s.handle);
}

socket_setting :: (s: &Socket, setting: SocketSetting, flag: bool) {
    if runtime.platform.__net_sock_opt_flag(s.handle, setting, flag) {
        if setting == .NonBlocking {
            if flag do s.flags = ~~ (cast(u32) s.flags & cast(u32) ~io.Stream_Flags.Block_On_Read);
            else do    s.flags |= io.Stream_Flags.Block_On_Read;
        }
    }
}

socket_is_alive :: (s: &Socket) -> bool {
    return runtime.platform.__net_sock_status(s.handle) == .Open;
}

socket_connect :: (s: &Socket, addr: &SocketAddress) -> io.Error {
    return runtime.platform.__net_sock_connect(s.handle, addr);
}

socket_bind :: (s: &Socket, bind_address: &Socket_Address) -> bool {
    return runtime.platform.__net_sock_bind(s.handle, bind_address);
}

socket_listen :: (s: &Socket, backlog := 32) -> bool {
    return runtime.platform.__net_sock_listen(s.handle, backlog);
}

socket_shutdown :: (s: &Socket, how: SocketShutdown) -> io.Error {
    return runtime.platform.__net_socket_shutdown(s.handle, how);
}

SocketAcceptResult :: struct {
    socket: Socket;
    addr:   SocketAddress;
}

socket_accept :: (s: &Socket) -> Result(SocketAcceptResult, io.Error) {
    new_addr: SocketAddress;
    sock_fd := runtime.platform.__net_sock_accept(s.handle, &new_addr)?;

    return .{
        Ok = .{
            socket = socket_from_fd(sock_fd),
            addr   = new_addr
        }
    };
}

Socket_Poll_Status :: enum {
    No_Change :: 0;
    Readable  :: 1;
    Closed    :: 2;
}

socket_poll_all :: (sockets: [] &Socket, stat_buff: [] Socket_Poll_Status, timeout := -1) {
    if sockets.count > stat_buff.count do return;

    handles := alloc.array_from_stack(runtime.platform.PollDescription, sockets.count);
    for i: sockets.count {
        handles[i] = .{
            ~~cast(i32) sockets[i].handle, .Read
        };
    }

    runtime.platform.__poll(handles, timeout);
    for i: sockets.count {
        stat_buff[i] = switch handles[i].out {
            case .None => .No_Change
            case .Read => .Readable
            case .Closed => .Closed
        };
    }
}

socket_poll :: (socket: &Socket, timeout := -1) -> Socket_Poll_Status {
    fds := runtime.platform.PollDescription.[
        .{ ~~cast(i32) socket.handle, .Read }
    ];

    runtime.platform.__poll(fds, timeout);

    return switch fds[0].out {
        case .None => .No_Change
        case .Read => .Readable
        case .Closed => .Closed
    };
}

socket_send :: (s: &Socket, data: [] u8) -> i32 {
    res := runtime.platform.__net_sock_send(s.handle, data);
    return res.Ok ?? -1;
}

socket_sendto :: (s: &Socket, data: [] u8, addr: &SocketAddress) -> i32 {
    res := runtime.platform.__net_sock_sendto(s.handle, data, addr);
    return res.Ok ?? -1;
}

socket_sendall :: (s: &Socket, data: [] u8) {
    to_send := data;

    while to_send.count > 0 {
        sent := socket_send(s, to_send);
        if sent < 0 { return; }
        else        do to_send = to_send[sent .. to_send.count];
    }
}

socket_recv :: (s: &Socket, maxlen := 1024, allocator := context.allocator) -> ? [] u8 {
    buffer := alloc.array_from_stack(u8, maxlen);
    res := runtime.platform.__net_sock_recv(s.handle, buffer);
    if res.Err {
        return .{};
    }

    return slice.copy(buffer[0 .. res.Ok->unwrap()], allocator);

    // buffer := alloc.from_stack(maxlen);
    // would_block: bool;
    // received := __net_recv(s.handle, .{ buffer, maxlen }, &would_block);
    // if received < 0 { 
    //     if !would_block do s.vtable = null;
    //     return .[];
    // }

    // result := memory.make_slice(u8, received, allocator=allocator);
    // memory.copy(result.data, buffer, received);

    // return result;
}

socket_recv_into :: (s: &Socket, buffer: [] u8) -> i32 {
    res := runtime.platform.__net_sock_recv(s.handle, buffer);
    if res.Err {
        return 0;
    }

    return res.Ok->unwrap();

    // would_block: bool;
    // received := __net_recv(s.handle, buffer, &would_block);
    // if received < 0 && !would_block do s.vtable = null;
    // if would_block do return 0;

    // return received;
}

SocketRecvFromResult :: struct {
    addr: SocketAddress;
    count: i32;
}

socket_recvfrom :: (s: &Socket, buffer: [] u8) -> ? SocketRecvFromResult {
    sender_addr: SocketAddress;
    res := runtime.platform.__net_sock_recvfrom(s.handle, buffer, &sender_addr);
    if res.Err do return .{};

    return .{ Some = .{ addr = sender_addr, res.Ok->unwrap() } };

    // would_block: bool;
    // sa: SocketAddress;

    // received := __net_recvfrom(s.handle, buffer, &sa, &would_block);
    // if received < 0 && !would_block do s.vtable = null;
    // if would_block do return sa, 0;

    // return sa, received;
}

// TODO: Add these back
// host_to_network :: #match #local {}
// #match host_to_network (x: u16) => __net_host_to_net_s(x);
// #match host_to_network (x: u32) => __net_host_to_net_l(x);

// network_to_host :: #match #local {}
// #match network_to_host (x: u16) => __net_net_to_host_s(x);
// #match network_to_host (x: u32) => __net_net_to_host_l(x);

#local __net_socket_vtable := io.Stream_Vtable.{
    read = (use s: &Socket, buffer: [] u8) -> (io.Error, u32) {
        if cast(i32) handle == 0 do return .BadFile, 0;
        
        res := runtime.platform.__net_sock_recv(handle, buffer);
        res->ok()->with([bytes_read] {
            if bytes_read == 0 do return .EOF, 0;

            return .None, bytes_read;
        });

        res->err()->with([err] {
            if err == .NoData do return .ReadLater, 0;

            return err, 0;
        });
    },

    write_byte = (use s: &Socket, byte: u8) -> io.Error {
        if cast(i32) handle == 0 do return .BadFile;

        res := runtime.platform.__net_sock_send(handle, .[ byte ]);
        res->err()->with([err] {
            return err;
        });

        if res->ok()->unwrap() > 0 do return .None;
        return .BufferFull;
    },

    write = (use s: &Socket, buffer: [] u8) -> (io.Error, u32) {
        if cast(i32) handle == 0 do return .BadFile, 0;
        
        res := runtime.platform.__net_sock_send(handle, .[ byte ]);
        res->err()->with([err] {
            return err, 0;
        });

        return .None, res->ok()->unwrap();
    },

    poll = (use s: &Socket, ev: io.PollEvent, timeout: i32) -> (io.Error, bool) {
        if ev == .Write do return .None, true;

        status := socket_poll(s, timeout);

        if status == .Closed {
            return .EOF, false;
        }

        return .None, status == .Readable;
    },

    close = (use p: &Socket) -> io.Error {
        socket_close(p);
        return .None;
    }
};

//
// Non-socket related helper functions
//

str_to_ipv4 :: (ip: str) -> u32 {
    ip_ := ip;

    res: u32;
    for 4 {
        octet := string.read_until(&ip_, #char ".");
        string.advance(&ip_, 1);

        res = res << 8;
        res |= ~~(conv.str_to_i64(octet) & cast(i64) 0xFF);
    }

    return res;
}

// This returns a volatile buffer that should be copied.
ipv4_to_str :: (addr: u32) -> str {
    #persist out: [64] u8;
    str_addr := conv.format(out, "{}.{}.{}.{}",
        (addr >> 24) & 0xff,
        (addr >> 16) & 0xff,
        (addr >>  8) & 0xff,
        (addr >>  0) & 0xff);
    return str_addr;
}

// This returns a volatile buffer that should be copied.
ipv6_to_str :: (addr_h: u64, addr_l: u64) -> str {
    #persist out: [64] u8;
    str_addr := conv.format(out, "{w2b16}:{w2b16}:{w2b16}:{w2b16}:{w2b16}:{w2b16}:{w2b16}:{w2b16}",
        (addr_h >> 24) & 0xff,
        (addr_h >> 16) & 0xff,
        (addr_h >>  8) & 0xff,
        (addr_h >>  0) & 0xff,
        (addr_l >> 24) & 0xff,
        (addr_l >> 16) & 0xff,
        (addr_l >>  8) & 0xff,
        (addr_l >>  0) & 0xff);
    return str_addr;
}

