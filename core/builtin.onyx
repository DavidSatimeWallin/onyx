package builtin

string  :: #type []u8;
cstring :: #type ^u8;

Buffer :: #type []void;

null :: cast(rawptr) 0;

DEFAULT_ALLOCATION_ALIGNMENT :: 16

AllocAction :: enum {
    Alloc;
    Free;
    Resize;
}

allocator_proc :: #type proc (rawptr, AllocAction, u32, u32, rawptr) -> rawptr;

Allocator :: struct {
    data: rawptr;
    func: allocator_proc;
}

alloc :: proc (use a: Allocator, size: u32) -> rawptr {
    return func(data, AllocAction.Alloc, size, DEFAULT_ALLOCATION_ALIGNMENT, null);
}

resize :: proc (use a: Allocator, ptr: rawptr, size: u32) -> rawptr {
    return func(data, AllocAction.Resize, size, DEFAULT_ALLOCATION_ALIGNMENT, ptr);
}

free :: proc (use a: Allocator, ptr: rawptr) {
    func(data, AllocAction.Free, 0, 0, ptr);
}

calloc  :: proc (size: u32) -> rawptr do return alloc(context.allocator, size);
cresize :: proc (ptr: rawptr, size: u32) -> rawptr do return resize(context.allocator, ptr, size);
cfree   :: proc (ptr: rawptr) do free(context.allocator, ptr);

array_init :: proc(arr: ^[..] $T) {
    arr.count = 0;
    arr.capacity = 4;
    arr.data = calloc(sizeof T * arr.capacity);
}

array_add :: proc (arr: ^[..] $T, x: T) {
    if arr.count + 1 > arr.capacity {
        arr.capacity <<= 1;
        arr.data = cresize(arr.data, sizeof T * arr.capacity);
    }

    arr.data[arr.count] = x;
    arr.count += 1;
}

context : struct {
	allocator      : Allocator;
	temp_allocator : Allocator;
}