package builtin

// CLEANUP: Should builtin.onyx really be including other files in the compilation?
// Does that complicate things too much?
#load "core/runtime/build_opts"
#local runtime :: package runtime

str  :: #type []u8;
cstr :: #type ^u8;

@Note
// Because of many implementation details, all fields of this
// struct are required to be i32's.
range :: struct {
    low  : i32;
    high : i32;
    step : i32 = 1;
}

@Deprecated
vararg :: #type ^struct {
    data:  rawptr;
    count: i32;
}

@Deprecated
vararg_get :: #match {
    (va: vararg, ret: ^$T) -> bool {
        if va.count <= 0 do return false;
        *ret = *cast(^T) va.data;
        va.data = cast(rawptr) (cast(^u8) va.data + sizeof T);
        va.count -= 1;
        return true;
    },

    (va: vararg, $T: type_expr, default: T = 0) -> (bool, T) {
        if va.count <= 0 do return false, default;
        ret := *cast(^T) va.data;
        va.data = cast(rawptr) (cast(^u8) va.data + sizeof T);
        va.count -= 1;
        return true, ret;
    }
}

@NullProcHack
null_proc :: () -> void #null ---
null      :: cast(rawptr) 0;

// I find myself wanting to return a completely nullified string like the
// one below that I decided to added a builtin binding for it. This might
// go away at some point and would just need to be defined in every file.
null_str  :: str.{ null, 0 }

OnyxContext :: struct {
    allocator      : Allocator;
    temp_allocator : Allocator;

    logger         : Logger = .{ default_logger, null };

    assert_handler : (msg: str, site: CallSite) -> void;

    thread_id      : i32;
}

#if runtime.runtime != .Custom {
    #local default_logger :: (data: rawptr, msg: str) {
        use package core
        println(msg);
    }

} else {
    #local default_logger :: (data: rawptr, msg: str) {
        // In a custom runtime, there is no way to know how to log something.
    }
}

#thread_local context : OnyxContext;

assert :: (cond: bool, msg: str, site := #callsite) {
    if !cond do context.assert_handler(msg, site);
}


//
// Basic logging
//

Logger :: struct {
    func : (data: rawptr, msg: str) -> void;
    data : rawptr;
}

log :: (msg: str, use logger: Logger = context.logger) {
    func(data, msg);
}


//
// Basic allocation structures.
// The implementations of all of the allocators can be found in core/alloc/.
// These need to be here so the context structure has the types and enum values.
//
#local
Default_Allocation_Alignment :: 16

AllocationAction :: enum {
    Alloc;
    Free;
    Resize;
}

#local
allocator_proc :: #type (data: rawptr, action: AllocationAction, size: u32, align: u32, old_ptr: rawptr) -> rawptr;

Allocator :: struct {
    data: rawptr;
    func: allocator_proc;
}

raw_alloc :: (use a: Allocator, size: u32, alignment := Default_Allocation_Alignment) -> rawptr {
    return func(data, AllocationAction.Alloc, size, alignment, null);
}

raw_resize :: (use a: Allocator, ptr: rawptr, size: u32, alignment := Default_Allocation_Alignment) -> rawptr {
    return func(data, AllocationAction.Resize, size, alignment, ptr);
}

raw_free :: (use a: Allocator, ptr: rawptr) {
    func(data, AllocationAction.Free, 0, 0, ptr);
}

// Allocators using the context structure.
calloc  :: (size: u32) -> rawptr do return raw_alloc(context.allocator, size);
cresize :: (ptr: rawptr, size: u32) -> rawptr do return raw_resize(context.allocator, ptr, size);
cfree   :: (ptr: rawptr) do raw_free(context.allocator, ptr);

new :: #match {
    ($T: type_expr, allocator := context.allocator) -> ^T {
        use package core.intrinsics.onyx { __initialize }
        memory :: package core.memory

        res := cast(^T) raw_alloc(allocator, sizeof T);
        memory.set(res, 0, sizeof T);
        __initialize(res);

        return res;
    },

    (T: type_expr, allocator := context.allocator) -> rawptr {
        memory :: package core.memory

        info := type_info.get_type_info(T);
        size := type_info.size_of(T);
        if size == 0 do return null;

        res := raw_alloc(allocator, size);
        memory.set(res, 0, size);

        if info.kind == .Struct {
            s_info := cast(^type_info.Type_Info_Struct) info;
            for s_info.members {
                if it.default != null {
                    member_size := type_info.size_of(it.type);
                    memory.copy(cast(^u8) res + it.offset, it.default, member_size);
                }
            }
        }

        return res;
    }
}

make :: #match {
    macro ($T: type_expr, allocator := context.allocator) => {
        return __make_overload(cast(^T) null, allocator=allocator);
    },

    macro ($T: type_expr, n: u32, allocator := context.allocator) => {
        return __make_overload(cast(^T) null, n, allocator=allocator);
    },
}

__make_overload :: #match {
    //
    // This is the fallback option for make. It simply allocates a zero-intialized
    // element of type T.
    #precedence 1000 (_: ^$T, allocator := context.allocator) -> ^T {
        memory :: package core.memory

        res := cast(^T) raw_alloc(allocator, sizeof T);
        memory.set(res, 0, sizeof T);
        return res;
    },
}


Iterator :: struct (Iter_Type: type_expr) {
    data:   rawptr;
    next:   (data: rawptr) -> (Iter_Type, bool);
    close:  (data: rawptr) -> void = null_proc;
    remove: (data: rawptr) -> void = null_proc;
}



// This structure represents the result of a '#callsite' expression. Currently,
// #callsite is only valid (and parsed) as a default value for a procedure parameter.
// It allows the function to get the address of the calling site, which can be
// used for error printing, unique hashes, and much more.
CallSite :: struct {
    file   : str;
    line   : u32;
    column : u32;
}


any :: struct {
    data: rawptr;
    type: type_expr;
}


// Represents a code block. Not constructable outside of using a '#quote' directive.
Code :: struct {_:i32;}


// Define aliases for common datastructures in the core library, if the core library is available.
// I'm on the fence about keeping this, as the programmer may want to use these names for their own
// structures, but for the moment I don't see any harm. I'm also thinking about removing the '[..]'
// syntax for dynamic arrays and just make them like Map's and Set's, i.e. Array(T). This would
// remove some confusion around the 3 different array types as dynamic arrays would clearly just be
// normal structures. With the recent addition of macros and iterators, there really wouldn't be much
// difference anyway.
#if #defined((package core.map).Map) {
    Map :: (package core.map).Map;
}

#if #defined((package core.set).Set) {
    Set :: (package core.set).Set;
}


// This procedure is a special compiler generated procedure that initializes all the data segments
// in the program. It should only be called once, by the main thread, at the start of execution. It
// is undefined behaviour if it is called more than once.
__initialize_data_segments :: () -> void ---

// This is also a special compiler generated procedure that calls all procedures specified with
// #init, in the specified order. It should theoritically only be called once on the main thread.
__run_init_procedures :: () -> void ---
