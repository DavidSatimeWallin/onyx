package builtin

str  :: #type []u8;
cstr :: #type ^u8;

// NOTE: Because of many implementation details, all fields of this
// struct are required to be i32's.
range :: struct {
    low  : i32;
    high : i32;
    step : i32 = 1;
}

vararg :: #type ^struct {
    data:  rawptr;
    count: i32;
}

vararg_get :: proc {
    (va: vararg, ret: ^$T) -> bool {
        if va.count <= 0 do return false;
        *ret = *cast(^T) va.data;
        va.data = cast(rawptr) (cast(^u8) va.data + sizeof T);
        va.count -= 1;
        return true;
    },

    (va: vararg, $T: type_expr, default: T = 0) -> T {
        if va.count <= 0 do return default;
        ret := *cast(^T) va.data;
        va.data = cast(rawptr) (cast(^u8) va.data + sizeof T);
        va.count -= 1;
        return res;
    }
}

// HACK: NullProcHack
null_proc :: proc () #null ---
null      :: cast(rawptr) 0;

// I find myself wanting to return a completely nullified string like the
// one below that I decided to added a builtin binding for it. This might
// go away at some point and would just need to be defined in every file.
null_str  :: str.{ null, 0 }

OnyxContext :: struct {
    allocator      : Allocator;
    temp_allocator : Allocator;

    assert_handler : (msg: str, file: str) -> void;
}

// @Robustness
// Currently, because the only compilation target is WebAssembly, which is only
// single threaded for the moment, it is safe to store the context in a global
// variable. If other compilations targets are added, or if WebAssembly standardizes
// a multi-threading proposal, this context will need to be changed. Either it will
// need to be a thread-local variable, or it needs to be implicitly passed as the
// first parameter to ALL procedures in a compilation unit.
context : OnyxContext;

assert :: (cond: bool, msg: str, file: str = null_str) {
    if !cond do context.assert_handler(msg, file);
}


//
// Basic allocation structures.
// The implementations of all of the allocators can be found in core/alloc/.
// These need to be here so the context structure has the types and enum values.
//
#private_file
Default_Allocation_Alignment :: 16

AllocationAction :: enum {
    Alloc;
    Free;
    Resize;
}

allocator_proc :: #type (data: rawptr, action: AllocationAction, size: u32, align: u32, old_ptr: rawptr) -> rawptr;

Allocator :: struct {
    data: rawptr;
    func: allocator_proc;
}

raw_alloc :: (use a: Allocator, size: u32, alignment := Default_Allocation_Alignment) -> rawptr {
    return func(data, AllocationAction.Alloc, size, alignment, null);
}

raw_resize :: (use a: Allocator, ptr: rawptr, size: u32, alignment := Default_Allocation_Alignment) -> rawptr {
    return func(data, AllocationAction.Resize, size, alignment, ptr);
}

raw_free :: (use a: Allocator, ptr: rawptr) {
    func(data, AllocationAction.Free, 0, 0, ptr);
}

// Allocators using the context structure.
calloc  :: (size: u32) -> rawptr do return raw_alloc(context.allocator, size);
cresize :: (ptr: rawptr, size: u32) -> rawptr do return raw_resize(context.allocator, ptr, size);
cfree   :: (ptr: rawptr) do raw_free(context.allocator, ptr);

new :: ($T: type_expr, allocator := context.allocator) -> ^T {
    res := cast(^T) calloc(sizeof T);
    
    // At some point, it would be nice to initialize the resulting memory, i.e.
    // *res = T.{};

    return res;
}
