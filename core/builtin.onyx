package builtin

//
// Explanation of `package builtin`
//
// The package "builtin" is a special package, and this file is a special file.
// This file is automatically included in EVERY Onyx compilation. It contains
// many of the core data types and "magic" functions that Onyx needs to operate.
// There is no way to not include this file, so the number of things in here
// have, and should continue, to remain limited.
//
// "builtin" is a special package. Because many of these core data types are
// needed in every single Onyx file, it would be nice if they were always
// accessible. To make this possible, the *public* scope of the builtin package
// is actually the *global* scope, the scope above every package. The global
// scope is visible to every file. By mapping builtin's public scope to the
// global scope, everything in this file can be accessed without needing to
// 'use' or prefix anything.
//





// CLEANUP: Should builtin.onyx really be including other files in the compilation?
// Does that complicate things too much?
#load "core/runtime/build_opts"

//
// The builtin string and C-string types.
// A string is simply a slice of bytes, and a c-string is a pointer
// to byte, with a null-terminator ('\0') at the end.
str  :: #type [] u8;
cstr :: #type  ^ u8;




//
// This is the type of a range literal (i.e. 1 .. 5).
// This is a special type that the compiler knows how to iterator through.
// So, one can simply write:
//
//      for x: 1 .. 5 { ... }
//
// Although not controllable from the literal syntax, there is a `step`
// member that allows you control how many numbers to advance each iteration.
// For example, range.{ 0, 100, 2 } would iterate over the even numbers, and
// range.{ 100, 0, -1 } would count backwards from 100 to 0 (and including 0).
range :: struct {
    low  : i32;
    high : i32;
    step : i32 = 1;
}




//
// `null` in Onyx is simply the address 0, as a rawptr, so it implicitly
// casts to all other pointer types.
null :: cast(rawptr) 0

//
// `null_proc` is a special function that breaks the normal rules of type
// checking. `null_proc`, or any procedure marked with `#null`, is assignable
// to any function type, regardless of if the types match. For example,
//
//     f: (i32) -> i32 = null_proc;
//
// Even though `null_proc` is a `() -> void` function, it bypasses that check
// and gets assigned to `f`. If f is called, there will be a runtime exception.
// This is by design.
null_proc :: () -> void #null ---

//
// I find myself wanting to return a completely nullified string like the
// one below that I decided to added a builtin binding for it. This might
// go away at some point and would just need to be defined in every file.
null_str  :: str.{ null, 0 }



//
// 
#thread_local context : OnyxContext;

//
//
OnyxContext :: struct {
    allocator      : Allocator;
    temp_allocator : Allocator;

    logger         : Logger = .{ default_logger_proc, ^default_logger };

    assert_handler : (msg: str, site: CallSite) -> void;

    thread_id      : i32;

    user_data: rawptr;
    user_data_type: type_expr;
}

//
//
#inject OnyxContext {
    set_user_data :: macro (c: ^OnyxContext, data: ^$T) {
        c.user_data = data;
        c.user_data_type = T;
    }

    get_user_data :: macro (c: ^OnyxContext, $T: type_expr) -> ^T {
        if c.user_data_type != T do return null;
        return ~~ c.user_data;
    }
}



//
//
assert :: (cond: bool, msg: str, site := #callsite) {
    if !cond {
        context.assert_handler(msg, site);
    }
}


//
// Basic logging
//

Log_Level :: enum {
    Debug;
    Info;
    Warning;
    Error;
    Critical;
}

Logger :: struct {
    func : (data: rawptr, level: Log_Level, msg: str, module: str) -> void;
    data : rawptr;
}

log :: #match #local {}

#overload
log :: (level: Log_Level, msg: str) {
    context.logger.func(context.logger.data, level, msg, "");
}

#overload
log :: (level: Log_Level, module, msg: str) {
    context.logger.func(context.logger.data, level, msg, module);
}



//
// A sensible default logger.
//
Default_Logger :: struct {
    minimum_level: Log_Level;
}

#local #thread_local default_logger: Default_Logger;

default_log_level :: (level: Log_Level) {
    default_logger.minimum_level = level;
}

#if runtime.runtime != .Custom {
    #local default_logger_proc :: (logger: ^Default_Logger, level: Log_Level, msg: str, module: str) {
        if level < logger.minimum_level do return;

        if module {
            core.printf("[{}][{}] {}\n", level, module, msg);
        } else {
            core.printf("[{}] {}\n", level, msg);
        }
    }

} else {
    #local default_logger_proc :: (data: rawptr, level: Log_Level, msg: str, module: str) {
        // In a custom runtime, there is no way to know how to log something.
    }
}



//
// Basic allocation structures.
// The implementations of all of the allocators can be found in core/alloc/.
// These need to be here so the context structure has the types and enum values.
//
#local
Default_Allocation_Alignment :: 16

AllocationAction :: enum {
    Alloc;
    Free;
    Resize;
}

#local
allocator_proc :: #type (data: rawptr, action: AllocationAction, size: u32, align: u32, old_ptr: rawptr) -> rawptr;

Allocator :: struct {
    data: rawptr;
    func: allocator_proc;
}

raw_alloc :: (use a: Allocator, size: u32, alignment := Default_Allocation_Alignment) -> rawptr {
    return func(data, AllocationAction.Alloc, size, alignment, null);
}

raw_resize :: (use a: Allocator, ptr: rawptr, size: u32, alignment := Default_Allocation_Alignment) -> rawptr {
    return func(data, AllocationAction.Resize, size, alignment, ptr);
}

raw_free :: (use a: Allocator, ptr: rawptr) {
    func(data, AllocationAction.Free, 0, 0, ptr);
}

// Allocators using the context structure.
calloc  :: (size: u32) -> rawptr do return raw_alloc(context.allocator, size);
cresize :: (ptr: rawptr, size: u32) -> rawptr do return raw_resize(context.allocator, ptr, size);
cfree   :: (ptr: rawptr) do raw_free(context.allocator, ptr);

//
// This cannot be used in a custom runtime, as the other core
// packages are not included.
#if runtime.runtime != .Custom {
    new :: #match {
        ($T: type_expr, allocator := context.allocator) -> ^T {
            use package core.intrinsics.onyx { __initialize }
            memory :: package core.memory

            res := cast(^T) raw_alloc(allocator, sizeof T);
            memory.set(res, 0, sizeof T);
            __initialize(res);

            return res;
        },

        (T: type_expr, allocator := context.allocator) -> rawptr {
            memory :: package core.memory
            type_info :: package runtime.info

            info := type_info.get_type_info(T);
            size := type_info.size_of(T);
            if size == 0 do return null;

            res := raw_alloc(allocator, size);
            memory.set(res, 0, size);

            if info.kind == .Struct {
                s_info := cast(^type_info.Type_Info_Struct) info;
                for s_info.members {
                    if it.default != null {
                        member_size := type_info.size_of(it.type);
                        memory.copy(cast(^u8) res + it.offset, it.default, member_size);
                    }
                }
            }

            return res;
        }
    }

    new_temp :: macro (T: type_expr) => {
        return new(T, allocator=context.temp_allocator);
    }

    make :: #match {
        macro ($T: type_expr, allocator := context.allocator) => {
            return __make_overload(cast(^T) null, allocator=allocator);
        },

        macro ($T: type_expr, n: u32, allocator := context.allocator) => {
            return __make_overload(cast(^T) null, n, allocator=allocator);
        },
    }

    make_temp :: macro (T: type_expr) => {
        return make(T, allocator=context.temp_allocator);
    }

    //
    // This is a rather unique way of using the type matching system
    // to select an overload. What is desired here is that when you say:
    //
    //    make(Foo)
    //
    // You match the overload for make that is designed for making a Foo.
    // However, you cannot use the type matching system to match by value.
    // In order to get around this, `make` will pass a null pointer to this
    // match procedure, that is casted to be a *pointer* to the desired type.
    // Therefore, if you want to add your own make overload, you have to add
    // a match to `__make_overload` that takes a *pointer* to the desired
    // type as the first argument, and then an allocator as the second.
    // Optionally, you can take a parameter between them that is an integer,
    // useful when constructing things like arrays.
    //
    // See core/container/array.onyx for an example.
    //
    __make_overload :: #match {
        //
        // This is the fallback option for make. It simply allocates a zero-intialized
        // element of type T.
        #order 1000 (_: ^$T, allocator := context.allocator) -> ^T {
            memory :: package core.memory

            res := cast(^T) raw_alloc(allocator, sizeof T);
            memory.set(res, 0, sizeof T);
            return res;
        },
    }

    delete :: #match {
        #order 1000 macro (x: ^$T, allocator := context.allocator) {
            if x != null do raw_free(allocator, x);
        }
    }
}


Iterator :: struct (Iter_Type: type_expr) {
    data:   rawptr;
    next:   (data: rawptr) -> (Iter_Type, bool);
    close:  (data: rawptr) -> void = null_proc;
    remove: (data: rawptr) -> void = null_proc;
}



// This structure represents the result of a '#callsite' expression. Currently,
// #callsite is only valid (and parsed) as a default value for a procedure parameter.
// It allows the function to get the address of the calling site, which can be
// used for error printing, unique hashes, and much more.
CallSite :: struct {
    file   : str;
    line   : u32;
    column : u32;
}


any :: struct {
    data: rawptr;
    type: type_expr;
}


// Represents a code block that can be passed around at compile-time.
// This is commonly used with macros or polymorphic procedures to create
// very power extensions to the syntax.
Code :: struct {_:i32;}


// Define aliases for common datastructures in the core library, if the core library is available.
// I'm on the fence about keeping this, as the programmer may want to use these names for their own
// structures, but for the moment I don't see any harm. I'm also thinking about removing the '[..]'
// syntax for dynamic arrays and just make them like Map's and Set's, i.e. Array(T). This would
// remove some confusion around the 3 different array types as dynamic arrays would clearly just be
// normal structures. With the recent addition of macros and iterators, there really wouldn't be much
// difference anyway.
#if #defined((package core.map).Map) {
    Map :: (package core.map).Map;
}

#if #defined((package core.set).Set) {
    Set :: (package core.set).Set;
}


// This procedure is a special compiler generated procedure that initializes all the data segments
// in the program. It should only be called once, by the main thread, at the start of execution. It
// is undefined behaviour if it is called more than once.
__initialize_data_segments :: () -> void ---

// This is also a special compiler generated procedure that calls all procedures specified with
// #init, in the specified order. It should theoretically only be called once on the main thread.
__run_init_procedures :: () -> void ---

// This overloaded procedure allow you to define an implicit rule for how to convert any value
// into a boolean. A default is provided for ALL pointer types and array types, but this can
// be used for structures or distinct types.
__implicit_bool_cast :: #match -> bool {}


#local {
    #if runtime.runtime == .Onyx {
        IMPORT_MEMORY_DEFAULT :: true;
        IMPORT_MEMORY_MODULE_NAME_DEFAULT :: "onyx";
        IMPORT_MEMORY_IMPORT_NAME_DEFAULT :: "memory";

    } else {
        IMPORT_MEMORY_DEFAULT :: false;
        IMPORT_MEMORY_MODULE_NAME_DEFAULT :: "";
        IMPORT_MEMORY_IMPORT_NAME_DEFAULT :: "";
    }
}

// Should this be here? and/or should its name be so generic?
Link_Options :: struct {
    stack_first     := false;
    stack_size      := 16 * 65536;  // 16 pages * 65536 bytes per page = 1 MiB stack
    stack_alignment := 16;

    null_reserve_size := 16;

    import_memory := IMPORT_MEMORY_DEFAULT;
    import_memory_module_name := IMPORT_MEMORY_MODULE_NAME_DEFAULT;
    import_memory_import_name := IMPORT_MEMORY_IMPORT_NAME_DEFAULT;

    export_memory := true;
    export_memory_name := "memory";

    export_func_table := true;
    export_func_table_name := "func_table";

    memory_min_size := 1024;
    memory_max_size := 65536;
}


package_id :: #distinct u32
any_package :: cast(package_id) 0
#operator == macro (p1, p2: package_id) => cast(u32) p1 == cast(u32) p2;
#operator != macro (p1, p2: package_id) => cast(u32) p1 != cast(u32) p2;



//
// DEPRECATED THINGS
//

//
// This is the special type of a paramter that was declared to have the type '...'.
// This is an old feature of the language now called  'untyped varargs'. It had
// a similar construction to varargs in C/C++. Because it is incredibly unsafe
// and not programmer friendly, this way of doing it has been deprecated in
// favor of  using '..any', which provides type information along with the data.
vararg :: #type ^struct {
    data:  rawptr;
    count: i32;
}
